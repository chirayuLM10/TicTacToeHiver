{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _toConsumableArray = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _require = require(\"xmlchars/xml/1.0/ed5\"),\n    isS = _require.isS,\n    isChar = _require.isChar,\n    isNameStartChar = _require.isNameStartChar,\n    isNameChar = _require.isNameChar,\n    S_LIST = _require.S_LIST;\n\nvar _require2 = require(\"xmlchars/xmlns/1.0/ed3\"),\n    isNCNameStartChar = _require2.isNCNameStartChar,\n    isNCNameChar = _require2.isNCNameChar;\n\nvar XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nvar XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nvar rootNS = {\n  __proto__: null,\n  xml: XML_NAMESPACE,\n  xmlns: XMLNS_NAMESPACE\n};\nvar XML_ENTITIES = {\n  __proto__: null,\n  amp: \"&\",\n  gt: \">\",\n  lt: \"<\",\n  quot: \"\\\"\",\n  apos: \"'\"\n};\nvar S_BEGIN_WHITESPACE = \"sBeginWhitespace\"; // leading whitespace\n\nvar S_TEXT = \"sText\"; // general stuff\n\nvar S_ENTITY_FIRST_CHAR = \"sEntityFirstChar\"; // &amp and such, first char\n\nvar S_ENTITY_REST = \"sEntityRest\"; // &amp and such, rest of the name\n\nvar S_OPEN_WAKA = \"sOpenWaka\"; // <\n\nvar S_OPEN_WAKA_BANG = \"sOpenWakaBang\"; // <!...\n\nvar S_DOCTYPE = \"sDoctype\"; // <!DOCTYPE\n\nvar S_DOCTYPE_QUOTED = \"sDoctypeQuoted\"; // <!DOCTYPE \"//blah\n\nvar S_DOCTYPE_DTD = \"sDoctypeDTD\"; // <!DOCTYPE \"//blah\" [ ...\n\nvar S_DOCTYPE_DTD_QUOTED = \"sDoctypeDTDQuoted\"; // <!DOCTYPE \"//blah\" [ \"foo\n\nvar S_COMMENT = \"sComment\"; // <!--\n\nvar S_COMMENT_ENDING = \"sCommentEnding\"; // <!-- blah -\n\nvar S_COMMENT_ENDED = \"sCommentEnded\"; // <!-- blah --\n\nvar S_CDATA = \"sCData\"; // <![CDATA[ something\n\nvar S_CDATA_ENDING = \"sCDataEnding\"; // ]\n\nvar S_CDATA_ENDING_2 = \"sCDataEnding2\"; // ]]\n\nvar S_PI_FIRST_CHAR = \"sPIFirstChar\"; // <?hi, first char\n\nvar S_PI_REST = \"sPIRest\"; // <?hi, rest of the name\n\nvar S_PI_BODY = \"sPIBody\"; // <?hi there\n\nvar S_PI_ENDING = \"sPIEnding\"; // <?hi \"there\" ?\n\nvar S_OPEN_TAG = \"sOpenTag\"; // <strong\n\nvar S_OPEN_TAG_SLASH = \"sOpenTagSlash\"; // <strong /\n\nvar S_ATTRIB = \"sAttrib\"; // <a\n\nvar S_ATTRIB_NAME = \"sAttribName\"; // <a foo\n\nvar S_ATTRIB_NAME_SAW_WHITE = \"sAttribNameSawWhite\"; // <a foo _\n\nvar S_ATTRIB_VALUE = \"sAttribValue\"; // <a foo=\n\nvar S_ATTRIB_VALUE_QUOTED = \"sAttribValueQuoted\"; // <a foo=\"bar\n\nvar S_ATTRIB_VALUE_CLOSED = \"sAttribValueClosed\"; // <a foo=\"bar\"\n\nvar S_ATTRIB_VALUE_UNQUOTED = \"sAttribValueUnquoted\"; // <a foo=bar\n\nvar S_CLOSE_TAG = \"sCloseTag\"; // </a\n\nvar S_CLOSE_TAG_SAW_WHITE = \"sCloseTagSawWhite\"; // </a   >\n// These states are internal to sPIBody\n\nvar S_XML_DECL_NAME_START = 1; // <?xml\n\nvar S_XML_DECL_NAME = 2; // <?xml foo\n\nvar S_XML_DECL_EQ = 3; // <?xml foo=\n\nvar S_XML_DECL_VALUE_START = 4; // <?xml foo=\n\nvar S_XML_DECL_VALUE = 5; // <?xml foo=\"bar\"\n\nvar SPACE_SEPARATOR = \"SPACE_SEPARATOR\";\n/**\n * The list of supported events.\n */\n\nexports.EVENTS = [\"text\", \"processinginstruction\", \"doctype\", \"comment\", \"opentagstart\", \"opentag\", \"closetag\", \"cdata\", \"error\", \"end\", \"ready\"];\nvar NL = 0xA;\nvar CR = 0xD;\nvar SPACE = 0x20;\nvar BANG = 0x21;\nvar DQUOTE = 0x22;\nvar HASH = 0x23;\nvar AMP = 0x26;\nvar SQUOTE = 0x27;\nvar MINUS = 0x2D;\nvar FORWARD_SLASH = 0x2F;\nvar SEMICOLON = 0x3B;\nvar LESS = 0x3C;\nvar EQUAL = 0x3D;\nvar GREATER = 0x3E;\nvar QUESTION = 0x3F;\nvar OPEN_BRACKET = 0x5B;\nvar CLOSE_BRACKET = 0x5D;\n\nfunction isQuote(c) {\n  return c === DQUOTE || c === SQUOTE;\n}\n\nvar QUOTES = [DQUOTE, SQUOTE];\nvar TEXT_TERMINATOR = [LESS, AMP];\nvar DOCTYPE_TERMINATOR = [].concat(QUOTES, [OPEN_BRACKET, GREATER]);\nvar DOCTYPE_DTD_TERMINATOR = [].concat(QUOTES, [CLOSE_BRACKET]);\nvar XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION].concat(_toConsumableArray(S_LIST));\nvar ATTRIB_VALUE_UNQUOTED_TERMINATOR = [].concat(_toConsumableArray(S_LIST), [GREATER, AMP, LESS]);\n\nfunction nsPairCheck(parser, prefix, uri) {\n  switch (prefix) {\n    case \"xml\":\n      if (uri !== XML_NAMESPACE) {\n        parser.fail(\"xml prefix must be bound to \".concat(XML_NAMESPACE, \".\"));\n      }\n\n      break;\n\n    case \"xmlns\":\n      if (uri !== XMLNS_NAMESPACE) {\n        parser.fail(\"xmlns prefix must be bound to \".concat(XMLNS_NAMESPACE, \".\"));\n      }\n\n      break;\n\n    default:\n  }\n\n  switch (uri) {\n    case XMLNS_NAMESPACE:\n      parser.fail(prefix === \"\" ? \"the default namespace may not be set to \".concat(uri, \".\") : \"may not assign a prefix (even \\\"xmlns\\\") to the URI \".concat(XMLNS_NAMESPACE, \".\"));\n      break;\n\n    case XML_NAMESPACE:\n      switch (prefix) {\n        case \"xml\":\n          // Assinging the XML namespace to \"xml\" is fine.\n          break;\n\n        case \"\":\n          parser.fail(\"the default namespace may not be set to \".concat(uri, \".\"));\n          break;\n\n        default:\n          parser.fail(\"may not assign the xml namespace to another prefix.\");\n      }\n\n      break;\n\n    default:\n  }\n}\n\nfunction nsMappingCheck(parser, mapping) {\n  var _arr = Object.keys(mapping);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var local = _arr[_i];\n    nsPairCheck(parser, local, mapping[local]);\n  }\n}\n/**\n * Data structure for an XML tag.\n *\n * @typedef {object} SaxesTag\n *\n * @property {string} name The tag's name. This is the combination of prefix and\n * global name. For instance ``<a:b>`` would have ``\"a:b\"`` for ``name``.\n *\n * @property {string} prefix The tag's prefix. For instance ``<a:b>`` would have\n * ``\"a\"`` for ``prefix``. Undefined if we do not track namespaces.\n *\n * @property {string} local The tag's local name. For instance ``<a:b>`` would\n * have ``\"b\"`` for ``local``. Undefined if we do not track namespaces.\n *\n * @property {string} uri The namespace URI of this tag. Undefined if we do not\n * track namespaces.\n *\n * @property {Object.<string, SaxesAttribute> | Object.<string, string>}\n * attributes A map of attribute name to attributes. If namespaces are tracked,\n * the values in the map are {@link SaxesAttribute SaxesAttribute}\n * objects. Otherwise, they are strings.\n *\n * @property {Object.<string, string>} ns The namespace bindings in effect.\n *\n * @property {boolean} selfClosing Whether the tag is\n * self-closing (e.g. ``<foo/>``).\n *\n */\n\n/**\n * Data structure for an XML attribute\n *\n * @typedef {object} SaxesAttribute\n *\n * @property {string} name The attribute's name. This is the combination of\n * prefix and local name. For instance ``a:b=\"c\"`` would have ``a:b`` for name.\n *\n * @property {string} prefix The attribute's prefix. For instance ``a:b=\"c\"``\n * would have ``\"a\"`` for ``prefix``.\n *\n * @property {string} local The attribute's local name. For instance ``a:b=\"c\"``\n * would have ``\"b\"`` for ``local``.\n *\n * @property {string} uri The namespace URI of this attribute.\n *\n * @property {string} value The attribute's value.\n */\n\n/**\n * @typedef XMLDecl\n *\n * @property {string} [version] The version specified by the XML declaration.\n *\n * @property {string} [encoding] The encoding specified by the XML declaration.\n *\n * @property {string} [standalone] The value of the standalone parameter\n * specified by the XML declaration.\n */\n\n/**\n * @callback ResolvePrefix\n *\n * @param {string} prefix The prefix to check.\n *\n * @returns {string|undefined} The URI corresponding to the prefix, if any.\n */\n\n/**\n * @typedef SaxesOptions\n *\n * @property {boolean} [xmlns] Whether to track namespaces. Unset means\n * ``false``.\n *\n * @property {boolean} [fragment] Whether to accept XML fragments. Unset means\n * ``false``.\n *\n * @property {boolean} [additionalNamespaces] A plain object whose key, value\n * pairs define namespaces known before parsing the XML file. It is not legal\n * to pass bindings for the namespaces ``\"xml\"`` or ``\"xmlns\"``.\n *\n * @property {ResolvePrefix} [resolvePrefix] A function that will be used if the\n * parser cannot resolve a namespace prefix on its own.\n *\n * @property {boolean} [position] Whether to track positions. Unset means\n * ``true``.\n *\n * @property {string} [fileName] A file name to use for error reporting. Leaving\n * this unset will report a file name of \"undefined\". \"File name\" is a loose\n * concept. You could use a URL to some resource, or any descriptive name you\n * like.\n */\n\n\nvar SaxesParser =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {SaxesOptions} opt The parser options.\n   */\n  function SaxesParser(opt) {\n    _classCallCheck(this, SaxesParser);\n\n    this._init(opt);\n  }\n  /**\n   * Reset the parser state.\n   *\n   * @private\n   */\n\n\n  _createClass(SaxesParser, [{\n    key: \"_init\",\n    value: function _init(opt) {\n      this.comment = \"\";\n      this.openWakaBang = \"\";\n      this.text = \"\";\n      this.name = \"\";\n      this.doctype = \"\";\n      this.piTarget = \"\";\n      this.piBody = \"\";\n      this.entity = \"\";\n      this.cdata = \"\";\n      this.xmlDeclName = \"\";\n      this.xmlDeclValue = \"\";\n      /**\n       * The options passed to the constructor of this parser.\n       *\n       * @type {SaxesOptions}\n       */\n\n      this.opt = opt || {};\n      /**\n       * Indicates whether or not the parser is closed. If ``true``, wait for\n       * the ``ready`` event to write again.\n       *\n       * @type {boolean}\n       */\n\n      this.closed = false;\n      /**\n       * The XML declaration for this document.\n       *\n       * @type {XMLDecl}\n       */\n\n      this.xmlDecl = {\n        version: undefined,\n        encoding: undefined,\n        standalone: undefined\n      };\n      this.q = null;\n      this.tags = [];\n      this.initial = true;\n      this.tag = null;\n      this.chunk = \"\";\n      this.chunkPosition = 0;\n      this.i = 0;\n      this.trailingCR = false;\n      /**\n       * A map of entity name to expansion.\n       *\n       * @type {Object.<string, string>}\n       */\n\n      this.ENTITIES = Object.create(XML_ENTITIES);\n      this.attribList = []; // The logic is organized so as to minimize the need to check\n      // this.opt.fragment while parsing.\n\n      var fragmentOpt = this.fragmentOpt = !!this.opt.fragment;\n      this.state = fragmentOpt ? S_TEXT : S_BEGIN_WHITESPACE; // We want these to be all true if we are dealing with a fragment.\n\n      this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt; // An XML declaration is intially possible only when parsing whole\n      // documents.\n\n      this.xmlDeclPossible = !fragmentOpt;\n      this.piIsXMLDecl = false;\n      this.xmlDeclState = S_XML_DECL_NAME_START;\n      this.xmlDeclExpects = [\"version\"];\n      this.requiredSeparator = undefined;\n      this.entityReturnState = undefined;\n      this.badEntityName = false; // This records the index before which we don't have to check for the\n      // presence of ]]]>. The text before that index has been checked already,\n      // and should not be checked twice.\n\n      this.textCheckedBefore = 0;\n      var xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n\n      if (xmlnsOpt) {\n        // This is the function we use to perform name checks on PIs and entities.\n        // When namespaces are used, colons are not allowed in PI target names or\n        // entity names. So the check depends on whether namespaces are used. See:\n        //\n        // https://www.w3.org/XML/xml-names-19990114-errata.html\n        // NE08\n        //\n        this.nameStartCheck = isNCNameStartChar;\n        this.nameCheck = isNCNameChar;\n        this.processAttribs = this.processAttribsNS;\n        this.pushAttrib = this.pushAttribNS;\n        this.ns = Object.assign({\n          __proto__: null\n        }, rootNS);\n        var additional = this.opt.additionalNamespaces;\n\n        if (additional) {\n          nsMappingCheck(this, additional);\n          Object.assign(this.ns, additional);\n        }\n      } else {\n        this.nameStartCheck = isNameStartChar;\n        this.nameCheck = isNameChar;\n        this.processAttribs = this.processAttribsPlain;\n        this.pushAttrib = this.pushAttribPlain;\n      }\n\n      this.trackPosition = this.opt.position !== false;\n      /** The line number the parser is  currently looking at. */\n\n      this.line = 1;\n      /** The column the parser is currently looking at. */\n\n      this.column = 0;\n      this.fileName = this.opt.fileName;\n      this.onready();\n    }\n    /** The stream position the parser is currently looking at. */\n\n  }, {\n    key: \"ontext\",\n\n    /* eslint-disable class-methods-use-this */\n\n    /**\n     * Event handler for text data. The default implementation is a no-op.\n     *\n     * @param {string} text The text data encountered by the parser.\n     *\n     */\n    value: function ontext() {}\n    /**\n     * Event handler for processing instructions. The default implementation is a\n     * no-op.\n     *\n     * @param {{target: string, body: string}} data The target and body of\n     * the processing instruction.\n     */\n\n  }, {\n    key: \"onprocessinginstruction\",\n    value: function onprocessinginstruction() {}\n    /**\n     * Event handler for doctype. The default implementation is a no-op.\n     *\n     * @param {string} doctype The doctype contents.\n     */\n\n  }, {\n    key: \"ondoctype\",\n    value: function ondoctype() {}\n    /**\n     * Event handler for comments. The default implementation is a no-op.\n     *\n     * @param {string} comment The comment contents.\n     */\n\n  }, {\n    key: \"oncomment\",\n    value: function oncomment() {}\n    /**\n     * Event handler for the start of an open tag. This is called as soon as we\n     * have a tag name. The default implementation is a no-op.\n     *\n     * @param {SaxesTag} tag The tag.\n     */\n\n  }, {\n    key: \"onopentagstart\",\n    value: function onopentagstart() {}\n    /**\n     * Event handler for an open tag. This is called when the open tag is\n     * complete. (We've encountered the \">\" that ends the open tag.) The default\n     * implementation is a no-op.\n     *\n     * @param {SaxesTag} tag The tag.\n     */\n\n  }, {\n    key: \"onopentag\",\n    value: function onopentag() {}\n    /**\n     * Event handler for a close tag. Note that for self-closing tags, this is\n     * called right after ``onopentag``. The default implementation is a no-op.\n     *\n     * @param {SaxesTag} tag The tag.\n     */\n\n  }, {\n    key: \"onclosetag\",\n    value: function onclosetag() {}\n    /**\n     * Event handler for a CDATA section. This is called when ending the\n     * CDATA section. The default implementation is a no-op.\n     *\n     * @param {string} cdata The contents of the CDATA section.\n     */\n\n  }, {\n    key: \"oncdata\",\n    value: function oncdata() {}\n    /**\n     * Event handler for the stream end. This is called when the stream has been\n     * closed with ``close`` or by passing ``null`` to ``write``. The default\n     * implementation is a no-op.\n     */\n\n  }, {\n    key: \"onend\",\n    value: function onend() {}\n    /**\n     * Event handler indicating parser readiness . This is called when the parser\n     * is ready to parse a new document.  The default implementation is a no-op.\n     */\n\n  }, {\n    key: \"onready\",\n    value: function onready() {}\n    /**\n     * Event handler indicating an error. The default implementation throws the\n     * error. Override with a no-op handler if you don't want this.\n     *\n     * @param {Error} err The error that occurred.\n     */\n\n  }, {\n    key: \"onerror\",\n    value: function onerror(err) {\n      throw new Error(err);\n    }\n    /* eslint-enable class-methods-use-this */\n\n    /**\n     * Report a parsing error. This method is made public so that client code may\n     * check for issues that are outside the scope of this project and can report\n     * errors.\n     *\n     * @param {Error} er The error to report.\n     *\n     * @returns this\n     */\n\n  }, {\n    key: \"fail\",\n    value: function fail(er) {\n      var message = this.trackPosition ? \"\".concat(this.fileName, \":\").concat(this.line, \":\").concat(this.column, \": \").concat(er) : er;\n      this.onerror(new Error(message));\n      return this;\n    }\n    /**\n     * Write a XML data to the parser.\n     *\n     * @param {string} chunk The XML data to write.\n     *\n     * @returns this\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(chunk) {\n      if (this.closed) {\n        return this.fail(\"cannot write after close; assign an onready handler.\");\n      }\n\n      var end = false;\n\n      if (chunk === null) {\n        end = true;\n        chunk = \"\";\n      }\n\n      if (typeof chunk === \"object\") {\n        chunk = chunk.toString();\n      } // We checked if performing a pre-decomposition of the string into an array\n      // of single complete characters (``Array.from(chunk)``) would be faster\n      // than the current repeated calls to ``codePointAt``. As of August 2018, it\n      // isn't. (There may be Node-specific code that would perform faster than\n      // ``Array.from`` but don't want to be dependent on Node.)\n\n\n      var limit = chunk.length;\n\n      if (this.trailingCR) {\n        // The previous chunk had a trailing cr. We need to handle it now.\n        chunk = \"\\r\".concat(chunk);\n      }\n\n      if (!end && chunk[limit - 1] === CR) {\n        // The chunk ends with a trailing CR. We cannot know how to handle it\n        // until we get the next chunk or the end of the stream. So save it for\n        // later.\n        limit--;\n        this.trailingCR = true;\n      }\n\n      this.limit = limit;\n      this.chunk = chunk;\n      this.i = 0;\n\n      while (this.i < limit) {\n        this[this.state]();\n      }\n\n      this.chunkPosition += limit;\n      return end ? this.end() : this;\n    }\n    /**\n     * Close the current stream. Perform final well-formedness checks and reset\n     * the parser tstate.\n     *\n     * @returns this\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      return this.write(null);\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * @private\n     *\n     * @returns {number} The character read.\n     */\n\n  }, {\n    key: \"getCode\",\n    value: function getCode() {\n      var chunk = this.chunk,\n          i = this.i; // Using charCodeAt and handling the surrogates ourselves is faster\n      // than using codePointAt.\n\n      var code = chunk.charCodeAt(i);\n      var skip = 1;\n\n      switch (code) {\n        case CR:\n          // We may get undefined if we read past the end of the chunk, which is\n          // fine.\n          if (chunk.charCodeAt(i + 1) === NL) {\n            // A \\r\\n sequence is converted to \\n so we have to skip over the next\n            // character. We already know it has a size of 1 so ++ is fine here.\n            skip++;\n          } // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n          // ahead.\n          // In either case, \\r becomes \\n.\n\n\n          code = NL;\n\n        /* yes, fall through */\n\n        case NL:\n          this.line++;\n          this.column = 0;\n          break;\n\n        default:\n          this.column++;\n\n          if (code >= 0xD800 && code <= 0xDBFF) {\n            code = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n            this.column++;\n            skip++;\n          }\n\n          if (!isChar(code)) {\n            this.fail(\"disallowed character.\");\n          }\n\n      }\n\n      this.i += skip;\n      return code;\n    }\n    /**\n     * @callback CharacterTest\n     *\n     * @private\n     *\n     * @param {string} c The character to test.\n     *\n     * @returns {boolean} ``true`` if the method should continue capturing text,\n     * ``false`` otherwise.\n     */\n\n    /**\n     * Capture characters into a buffer until encountering one of a set of\n     * characters.\n     *\n     * @private\n     *\n     * @param {number[]} chars An array of codepoints. Encountering a character in\n     * the array ends the capture.\n     *\n     * @param {string} buffer The name of the buffer to save into.\n     *\n     * @return {string|undefined} The character that made the capture end, or\n     * ``undefined`` if we hit the end of the chunk.\n     */\n\n  }, {\n    key: \"captureTo\",\n    value: function captureTo(chars, buffer) {\n      var chunk = this.chunk,\n          limit = this.limit,\n          start = this.i;\n\n      while (this.i < limit) {\n        var c = this.getCode();\n\n        if (chars.includes(c)) {\n          // This is faster than adding codepoints one by one.\n          this[buffer] += chunk.substring(start, this.i - (c <= 0xFFFF ? 1 : 2));\n          return c;\n        }\n      } // This is faster than adding codepoints one by one.\n\n\n      this[buffer] += chunk.substring(start);\n      return undefined;\n    }\n    /**\n     * Capture characters into a buffer until encountering a character.\n     *\n     * @private\n     *\n     * @param {number} char The codepoint that ends the capture.\n     *\n     * @param {string} buffer The name of the buffer to save into.\n     *\n     * @return {boolean} ``true`` if we ran into the character. Otherwise, we ran\n     * into the end of the current chunk.\n     */\n\n  }, {\n    key: \"captureToChar\",\n    value: function captureToChar(char, buffer) {\n      var chunk = this.chunk,\n          limit = this.limit,\n          start = this.i;\n\n      while (this.i < limit) {\n        var c = this.getCode();\n\n        if (c === char) {\n          // This is faster than adding codepoints one by one.\n          this[buffer] += chunk.substring(start, this.i - (c <= 0xFFFF ? 1 : 2));\n          return true;\n        }\n      } // This is faster than adding codepoints one by one.\n\n\n      this[buffer] += chunk.substring(start);\n      return false;\n    }\n    /**\n     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n     * this parser.\n     *\n     * @private\n     *\n     * @return {string|undefined} The character that made the test fail, or\n     * ``undefined`` if we hit the end of the chunk.\n     */\n\n  }, {\n    key: \"captureNameChars\",\n    value: function captureNameChars() {\n      var chunk = this.chunk,\n          limit = this.limit,\n          start = this.i;\n\n      while (this.i < limit) {\n        var c = this.getCode();\n\n        if (!isNameChar(c)) {\n          // This is faster than adding codepoints one by one.\n          this.name += chunk.substring(start, this.i - (c <= 0xFFFF ? 1 : 2));\n          return c;\n        }\n      } // This is faster than adding codepoints one by one.\n\n\n      this.name += chunk.substring(start);\n      return undefined;\n    }\n    /**\n     * Capture characters into a buffer while ``this.nameCheck`` run on the\n     * character read returns true.\n     *\n     * @private\n     *\n     * @param {string} buffer The name of the buffer to save into.\n     *\n     * @return {string|undefined} The character that made the test fail, or\n     * ``undefined`` if we hit the end of the chunk.\n     */\n\n  }, {\n    key: \"captureWhileNameCheck\",\n    value: function captureWhileNameCheck(buffer) {\n      var chunk = this.chunk,\n          limit = this.limit,\n          start = this.i;\n\n      while (this.i < limit) {\n        var c = this.getCode();\n\n        if (!this.nameCheck(c)) {\n          // This is faster than adding codepoints one by one.\n          this[buffer] += chunk.substring(start, this.i - (c <= 0xFFFF ? 1 : 2));\n          return c;\n        }\n      } // This is faster than adding codepoints one by one.\n\n\n      this[buffer] += chunk.substring(start);\n      return undefined;\n    }\n    /**\n     * Skip characters while a condition is true.\n     *\n     * @private\n     *\n     * @param {CharacterTest} test A test to perform on each character. The skip\n     * ends when the test returns false.\n     *\n     * @return {string|undefined} The character that made the test fail, or\n     * ``undefined`` if we hit the end of the chunk.\n     */\n\n  }, {\n    key: \"skipWhile\",\n    value: function skipWhile(test) {\n      var limit = this.limit;\n\n      while (this.i < limit) {\n        var c = this.getCode();\n\n        if (!test(c)) {\n          return c;\n        }\n      }\n\n      return undefined;\n    } // STATE HANDLERS\n\n    /** @private */\n\n  }, {\n    key: \"sBeginWhitespace\",\n    value: function sBeginWhitespace() {\n      var limit = this.limit;\n      var c = this.getCode();\n\n      if (this.initial && c === 0xFEFF) {\n        this.initial = false;\n\n        if (this.i >= limit) {\n          return;\n        }\n\n        c = this.getCode();\n      } else {\n        this.initial = false;\n      } // We cannot use skipWhile here because we have to use the previously\n      // read character first.\n\n\n      while (this.i < limit && isS(c)) {\n        c = this.getCode();\n        this.xmlDeclPossible = false;\n      }\n\n      if (c === LESS) {\n        this.state = S_OPEN_WAKA;\n      } else {\n        // have to process this as a text node.\n        // weird, but happens.\n        if (!this.reportedTextBeforeRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextBeforeRoot = true;\n        }\n\n        this.text = String.fromCodePoint(c);\n        this.textCheckedBefore = 0;\n        this.state = S_TEXT;\n        this.xmlDeclPossible = false;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sText\",\n    value: function sText() {\n      var c = this.captureTo(TEXT_TERMINATOR, \"text\");\n\n      if ((!this.sawRoot || this.closedRoot) && (/\\S/.test(this.text) || c === AMP)) {\n        // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n        // to avoid reporting errors for every single character that is out of\n        // place.\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextBeforeRoot = true;\n        }\n\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextAfterRoot = true;\n        }\n      }\n\n      if (this.text.includes(\"]]>\", this.textCheckedBefore)) {\n        this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n      } // We have to go back two spaces so that we can catch the case where on a\n      // previous write call, the text buffer ended on ``]]`` and we started\n      // with ``>`` this time around.\n\n\n      this.textCheckedBefore = this.text.length - 2;\n\n      switch (c) {\n        case LESS:\n          this.state = S_OPEN_WAKA;\n          break;\n\n        case AMP:\n          this.state = S_ENTITY_FIRST_CHAR;\n          this.entityReturnState = S_TEXT;\n          break;\n\n        default:\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sOpenWaka\",\n    value: function sOpenWaka() {\n      var c = this.getCode(); // either a /, ?, !, or text is coming next.\n\n      if (isNameStartChar(c)) {\n        this.state = S_OPEN_TAG;\n        this.name = String.fromCodePoint(c);\n        this.xmlDeclPossible = false;\n      } else {\n        switch (c) {\n          case FORWARD_SLASH:\n            this.state = S_CLOSE_TAG;\n            this.xmlDeclPossible = false;\n            break;\n\n          case BANG:\n            this.state = S_OPEN_WAKA_BANG;\n            this.openWakaBang = \"\";\n            this.xmlDeclPossible = false;\n            break;\n\n          case QUESTION:\n            this.state = S_PI_FIRST_CHAR;\n            break;\n\n          default:\n            this.fail(\"disallowed character in tag name.\");\n            this.state = S_TEXT;\n            this.xmlDeclPossible = false;\n        }\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sOpenWakaBang\",\n    value: function sOpenWakaBang() {\n      var c = String.fromCodePoint(this.getCode());\n      this.openWakaBang += c;\n\n      switch (this.openWakaBang) {\n        case \"[CDATA[\":\n          if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextBeforeRoot = true;\n          }\n\n          if (this.closedRoot && !this.reportedTextAfterRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextAfterRoot = true;\n          }\n\n          this.state = S_CDATA;\n          this.openWakaBang = \"\";\n          break;\n\n        case \"--\":\n          this.state = S_COMMENT;\n          this.openWakaBang = \"\";\n          break;\n\n        case \"DOCTYPE\":\n          this.state = S_DOCTYPE;\n\n          if (this.doctype || this.sawRoot) {\n            this.fail(\"inappropriately located doctype declaration.\");\n          }\n\n          this.openWakaBang = \"\";\n          break;\n\n        default:\n          // 7 happens to be the maximum length of the string that can possibly\n          // match one of the cases above.\n          if (this.openWakaBang.length >= 7) {\n            this.fail(\"incorrect syntax.\");\n          }\n\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sDoctype\",\n    value: function sDoctype() {\n      var c = this.captureTo(DOCTYPE_TERMINATOR, \"doctype\");\n\n      if (c === GREATER) {\n        this.state = S_TEXT;\n\n        if (this.text.length !== 0) {\n          this.closeText();\n        }\n\n        this.ondoctype(this.doctype);\n        this.doctype = true; // just remember that we saw it.\n      } else if (c) {\n        this.doctype += String.fromCodePoint(c);\n\n        if (c === OPEN_BRACKET) {\n          this.state = S_DOCTYPE_DTD;\n        } else if (isQuote(c)) {\n          this.state = S_DOCTYPE_QUOTED;\n          this.q = c;\n        }\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sDoctypeQuoted\",\n    value: function sDoctypeQuoted() {\n      var q = this.q;\n\n      if (this.captureToChar(q, \"doctype\")) {\n        this.doctype += String.fromCodePoint(q);\n        this.q = null;\n        this.state = S_DOCTYPE;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sDoctypeDTD\",\n    value: function sDoctypeDTD() {\n      var c = this.captureTo(DOCTYPE_DTD_TERMINATOR, \"doctype\");\n\n      if (!c) {\n        return;\n      }\n\n      this.doctype += String.fromCodePoint(c);\n\n      if (c === CLOSE_BRACKET) {\n        this.state = S_DOCTYPE;\n      } else if (isQuote(c)) {\n        this.state = S_DOCTYPE_DTD_QUOTED;\n        this.q = c;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sDoctypeDTDQuoted\",\n    value: function sDoctypeDTDQuoted() {\n      var q = this.q;\n\n      if (this.captureToChar(q, \"doctype\")) {\n        this.doctype += String.fromCodePoint(q);\n        this.state = S_DOCTYPE_DTD;\n        this.q = null;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sComment\",\n    value: function sComment() {\n      if (this.captureToChar(MINUS, \"comment\")) {\n        this.state = S_COMMENT_ENDING;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sCommentEnding\",\n    value: function sCommentEnding() {\n      var c = this.getCode();\n\n      if (c === MINUS) {\n        this.state = S_COMMENT_ENDED;\n\n        if (this.text.length !== 0) {\n          this.closeText();\n        }\n\n        this.oncomment(this.comment);\n        this.comment = \"\";\n      } else {\n        this.comment += \"-\".concat(String.fromCodePoint(c));\n        this.state = S_COMMENT;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sCommentEnded\",\n    value: function sCommentEnded() {\n      var c = this.getCode();\n\n      if (c !== GREATER) {\n        this.fail(\"malformed comment.\"); // <!-- blah -- bloo --> will be recorded as\n        // a comment of \" blah -- bloo \"\n\n        this.comment += \"--\".concat(String.fromCodePoint(c));\n        this.state = S_COMMENT;\n      } else {\n        this.state = S_TEXT;\n      }\n    }\n  }, {\n    key: \"sCData\",\n    value: function sCData() {\n      if (this.captureToChar(CLOSE_BRACKET, \"cdata\")) {\n        this.state = S_CDATA_ENDING;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sCDataEnding\",\n    value: function sCDataEnding() {\n      var c = this.getCode();\n\n      if (c === CLOSE_BRACKET) {\n        this.state = S_CDATA_ENDING_2;\n      } else {\n        this.cdata += \"]\".concat(String.fromCodePoint(c));\n        this.state = S_CDATA;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sCDataEnding2\",\n    value: function sCDataEnding2() {\n      var c = this.getCode();\n\n      switch (c) {\n        case GREATER:\n          if (this.text.length !== 0) {\n            this.closeText();\n          }\n\n          this.oncdata(this.cdata);\n          this.cdata = \"\";\n          this.state = S_TEXT;\n          break;\n\n        case CLOSE_BRACKET:\n          this.cdata += \"]\";\n          break;\n\n        default:\n          this.cdata += \"]]\".concat(String.fromCodePoint(c));\n          this.state = S_CDATA;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sPIFirstChar\",\n    value: function sPIFirstChar() {\n      var c = this.getCode();\n\n      if (this.nameStartCheck(c)) {\n        this.piTarget += String.fromCodePoint(c);\n        this.state = S_PI_REST;\n      } else if (c === QUESTION || isS(c)) {\n        this.fail(\"processing instruction without a target.\");\n        this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n      } else if (c) {\n        this.fail(\"disallowed character in processing instruction name.\");\n        this.piTarget += String.fromCodePoint(c);\n        this.state = S_PI_REST;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sPIRest\",\n    value: function sPIRest() {\n      var c = this.captureWhileNameCheck(\"piTarget\");\n\n      if (c === QUESTION || isS(c)) {\n        this.piIsXMLDecl = this.piTarget === \"xml\";\n\n        if (this.piIsXMLDecl && !this.xmlDeclPossible) {\n          this.fail(\"an XML declaration must be at the start of the document.\");\n        }\n\n        this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n      } else if (c) {\n        this.fail(\"disallowed character in processing instruction name.\");\n        this.piTarget += String.fromCodePoint(c);\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sPIBody\",\n    value: function sPIBody() {\n      var _this = this;\n\n      var c;\n\n      if (this.piIsXMLDecl) {\n        switch (this.xmlDeclState) {\n          case S_XML_DECL_NAME_START:\n            c = this.skipWhile(function (cx) {\n              if (isS(cx)) {\n                _this.requiredSeparator = undefined;\n                return true;\n              }\n\n              if (cx !== QUESTION && _this.requiredSeparator === SPACE_SEPARATOR) {\n                _this.fail(\"whitespace required.\");\n              }\n\n              _this.requiredSeparator = undefined;\n              return false;\n            }); // The question mark character is not valid inside any of the XML\n            // declaration name/value pairs.\n\n            if (c === QUESTION) {\n              this.state = S_PI_ENDING;\n              return;\n            }\n\n            if (c) {\n              this.xmlDeclState = S_XML_DECL_NAME;\n              this.xmlDeclName = String.fromCodePoint(c);\n            }\n\n            break;\n\n          case S_XML_DECL_NAME:\n            c = this.captureTo(XML_DECL_NAME_TERMINATOR, \"xmlDeclName\"); // The question mark character is not valid inside any of the XML\n            // declaration name/value pairs.\n\n            if (c === QUESTION) {\n              this.state = S_PI_ENDING;\n              return;\n            }\n\n            if (isS(c) || c === EQUAL) {\n              if (!this.xmlDeclExpects.includes(this.xmlDeclName)) {\n                switch (this.xmlDeclName.length) {\n                  case 0:\n                    this.fail(\"did not expect any more name/value pairs.\");\n                    break;\n\n                  case 1:\n                    this.fail(\"expected the name \".concat(this.xmlDeclExpects[0], \".\"));\n                    break;\n\n                  default:\n                    this.fail(\"expected one of \".concat(this.xmlDeclExpects.join(\", \")));\n                }\n              }\n\n              this.xmlDeclState = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n            }\n\n            break;\n\n          case S_XML_DECL_EQ:\n            c = this.getCode(); // The question mark character is not valid inside any of the XML\n            // declaration name/value pairs.\n\n            if (c === QUESTION) {\n              this.state = S_PI_ENDING;\n              return;\n            }\n\n            if (c && !isS(c)) {\n              if (c !== EQUAL) {\n                this.fail(\"value required.\");\n              }\n\n              this.xmlDeclState = S_XML_DECL_VALUE_START;\n            }\n\n            break;\n\n          case S_XML_DECL_VALUE_START:\n            c = this.getCode(); // The question mark character is not valid inside any of the XML\n            // declaration name/value pairs.\n\n            if (c === QUESTION) {\n              this.state = S_PI_ENDING;\n              return;\n            }\n\n            if (c && !isS(c)) {\n              if (!isQuote(c)) {\n                this.fail(\"value must be quoted.\");\n                this.q = SPACE;\n              } else {\n                this.q = c;\n              }\n\n              this.xmlDeclState = S_XML_DECL_VALUE;\n            }\n\n            break;\n\n          case S_XML_DECL_VALUE:\n            c = this.captureTo([this.q, QUESTION], \"xmlDeclValue\"); // The question mark character is not valid inside any of the XML\n            // declaration name/value pairs.\n\n            if (c === QUESTION) {\n              this.state = S_PI_ENDING;\n              return;\n            }\n\n            if (c) {\n              switch (this.xmlDeclName) {\n                case \"version\":\n                  if (!/^1\\.[0-9]+$/.test(this.xmlDeclValue)) {\n                    this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n                  }\n\n                  this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n                  this.xmlDecl.version = this.xmlDeclValue;\n                  break;\n\n                case \"encoding\":\n                  if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(this.xmlDeclValue)) {\n                    this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n                  }\n\n                  this.xmlDeclExpects = [\"standalone\"];\n                  this.xmlDecl.encoding = this.xmlDeclValue;\n                  break;\n\n                case \"standalone\":\n                  if (this.xmlDeclValue !== \"yes\" && this.xmlDeclValue !== \"no\") {\n                    this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n                  }\n\n                  this.xmlDeclExpects = [];\n                  this.xmlDecl.standalone = this.xmlDeclValue;\n                  break;\n\n                default: // We don't need to raise an error here since we've already\n                // raised one when checking what name was expected.\n\n              }\n\n              this.xmlDeclName = this.xmlDeclValue = \"\";\n              this.xmlDeclState = S_XML_DECL_NAME_START;\n              this.requiredSeparator = SPACE_SEPARATOR;\n            }\n\n            break;\n\n          default:\n            throw new Error(this, \"Unknown XML declaration state: \".concat(this.xmlDeclState));\n        }\n      } else if (this.piBody.length === 0) {\n        c = this.getCode();\n\n        if (c === QUESTION) {\n          this.state = S_PI_ENDING;\n        } else if (c && !isS(c)) {\n          this.piBody = String.fromCodePoint(c);\n        }\n      } // The question mark character is not valid inside any of the XML\n      // declaration name/value pairs.\n      else if (this.captureToChar(QUESTION, \"piBody\")) {\n          this.state = S_PI_ENDING;\n        }\n    }\n    /** @private */\n\n  }, {\n    key: \"sPIEnding\",\n    value: function sPIEnding() {\n      var c = this.getCode();\n\n      if (this.piIsXMLDecl) {\n        if (c === GREATER) {\n          if (this.piTarget !== \"xml\") {\n            this.fail(\"processing instructions are not allowed before root.\");\n          } else if (this.xmlDeclState !== S_XML_DECL_NAME_START) {\n            this.fail(\"XML declaration is incomplete.\");\n          } else if (this.xmlDeclExpects.includes(\"version\")) {\n            this.fail(\"XML declaration must contain a version.\");\n          }\n\n          this.xmlDeclName = this.xmlDeclValue = \"\";\n          this.requiredSeparator = undefined;\n          this.piTarget = this.piBody = \"\";\n          this.state = S_TEXT;\n        } else {\n          // We got here because the previous character was a ?, but the\n          // question mark character is not valid inside any of the XML\n          // declaration name/value pairs.\n          this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n        }\n      } else if (c === GREATER) {\n        if (this.piTarget.trim().toLowerCase() === \"xml\") {\n          this.fail(\"the XML declaration must appear at the start of the document.\");\n        }\n\n        if (this.text.length !== 0) {\n          this.closeText();\n        }\n\n        this.onprocessinginstruction({\n          target: this.piTarget,\n          body: this.piBody\n        });\n        this.piTarget = this.piBody = \"\";\n        this.state = S_TEXT;\n      } else if (c === QUESTION) {\n        // We ran into ?? as part of a processing instruction. We initially\n        // took the first ? as a sign that the PI was ending, but it is\n        // not. So we have to add it to the body but we take the new ? as a\n        // sign that the PI is ending.\n        this.piBody += \"?\";\n      } else {\n        this.piBody += \"?\".concat(String.fromCodePoint(c));\n        this.state = S_PI_BODY;\n      }\n\n      this.xmlDeclPossible = false;\n    }\n    /** @private */\n\n  }, {\n    key: \"sOpenTag\",\n    value: function sOpenTag() {\n      var c = this.captureNameChars();\n\n      if (!c) {\n        return;\n      }\n\n      var tag = this.tag = {\n        name: this.name,\n        attributes: Object.create(null)\n      };\n\n      if (this.xmlnsOpt) {\n        tag.ns = Object.create(null);\n      }\n\n      if (this.text.length !== 0) {\n        this.closeText();\n      }\n\n      this.onopentagstart(tag);\n      this.sawRoot = true;\n\n      if (!this.fragmentOpt && this.closedRoot) {\n        this.fail(\"documents may contain only one root.\");\n      }\n\n      switch (c) {\n        case GREATER:\n          this.openTag();\n          break;\n\n        case FORWARD_SLASH:\n          this.state = S_OPEN_TAG_SLASH;\n          break;\n\n        default:\n          if (!isS(c)) {\n            this.fail(\"disallowed character in tag name.\");\n          }\n\n          this.state = S_ATTRIB;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sOpenTagSlash\",\n    value: function sOpenTagSlash() {\n      var c = this.getCode();\n\n      if (c === GREATER) {\n        this.openSelfClosingTag();\n      } else {\n        this.fail(\"forward-slash in opening tag not followed by >.\");\n        this.state = S_ATTRIB;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sAttrib\",\n    value: function sAttrib() {\n      var c = this.getCode();\n\n      if (!c || isS(c)) {\n        return;\n      }\n\n      if (isNameStartChar(c)) {\n        this.name = String.fromCodePoint(c);\n        this.state = S_ATTRIB_NAME;\n      } else if (c === GREATER) {\n        this.openTag();\n      } else if (c === FORWARD_SLASH) {\n        this.state = S_OPEN_TAG_SLASH;\n      } else {\n        this.fail(\"disallowed character in attribute name.\");\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"pushAttribNS\",\n    value: function pushAttribNS(name, value) {\n      var _this$qname = this.qname(name),\n          prefix = _this$qname.prefix,\n          local = _this$qname.local;\n\n      this.attribList.push({\n        name: name,\n        prefix: prefix,\n        local: local,\n        value: value,\n        uri: undefined\n      });\n\n      if (prefix === \"xmlns\") {\n        var trimmed = value.trim();\n        this.tag.ns[local] = trimmed;\n        nsPairCheck(this, local, trimmed);\n      } else if (name === \"xmlns\") {\n        var _trimmed = value.trim();\n\n        this.tag.ns[\"\"] = _trimmed;\n        nsPairCheck(this, \"\", _trimmed);\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"pushAttribPlain\",\n    value: function pushAttribPlain(name, value) {\n      this.attribList.push({\n        name: name,\n        value: value\n      });\n    }\n    /** @private */\n\n  }, {\n    key: \"sAttribName\",\n    value: function sAttribName() {\n      var c = this.captureNameChars();\n\n      if (c === EQUAL) {\n        this.state = S_ATTRIB_VALUE;\n      } else if (isS(c)) {\n        this.state = S_ATTRIB_NAME_SAW_WHITE;\n      } else if (c === GREATER) {\n        this.fail(\"attribute without value.\");\n        this.pushAttrib(this.name, this.name);\n        this.name = this.text = \"\";\n        this.openTag();\n      } else if (c) {\n        this.fail(\"disallowed character in attribute name.\");\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sAttribNameSawWhite\",\n    value: function sAttribNameSawWhite() {\n      var c = this.getCode();\n\n      if (isS(c)) {\n        return;\n      }\n\n      if (c === EQUAL) {\n        this.state = S_ATTRIB_VALUE;\n      } else if (c) {\n        this.fail(\"attribute without value.\");\n        this.tag.attributes[this.name] = \"\";\n        this.text = \"\";\n        this.name = \"\";\n\n        if (c === GREATER) {\n          this.openTag();\n        } else if (isNameStartChar(c)) {\n          this.name = String.fromCodePoint(c);\n          this.state = S_ATTRIB_NAME;\n        } else {\n          this.fail(\"disallowed character in attribute name.\");\n          this.state = S_ATTRIB;\n        }\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sAttribValue\",\n    value: function sAttribValue() {\n      var c = this.getCode();\n\n      if (isQuote(c)) {\n        this.q = c;\n        this.state = S_ATTRIB_VALUE_QUOTED;\n      } else if (c && !isS(c)) {\n        this.fail(\"unquoted attribute value.\");\n        this.state = S_ATTRIB_VALUE_UNQUOTED;\n        this.text = String.fromCodePoint(c);\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sAttribValueQuoted\",\n    value: function sAttribValueQuoted() {\n      var c = this.captureTo([this.q, AMP, LESS], \"text\");\n\n      if (c === AMP) {\n        this.state = S_ENTITY_FIRST_CHAR;\n        this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n      } else if (c === LESS) {\n        this.fail(\"disallowed character.\");\n      } else if (c) {\n        this.pushAttrib(this.name, this.text);\n        this.name = this.text = \"\";\n        this.q = null;\n        this.state = S_ATTRIB_VALUE_CLOSED;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sAttribValueClosed\",\n    value: function sAttribValueClosed() {\n      var c = this.getCode();\n\n      if (isS(c)) {\n        this.state = S_ATTRIB;\n      } else if (isNameStartChar(c)) {\n        this.fail(\"no whitespace between attributes.\");\n        this.name = String.fromCodePoint(c);\n        this.state = S_ATTRIB_NAME;\n      } else if (c === GREATER) {\n        this.openTag();\n      } else if (c === FORWARD_SLASH) {\n        this.state = S_OPEN_TAG_SLASH;\n      } else {\n        this.fail(\"disallowed character in attribute name.\");\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sAttribValueUnquoted\",\n    value: function sAttribValueUnquoted() {\n      var c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR, \"text\");\n\n      if (c === AMP) {\n        this.state = S_ENTITY_FIRST_CHAR;\n        this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n      } else if (c === LESS) {\n        this.fail(\"disallowed character.\");\n      } else if (c) {\n        if (this.text.includes(\"]]>\")) {\n          this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n        }\n\n        this.pushAttrib(this.name, this.text);\n        this.name = this.text = \"\";\n\n        if (c === GREATER) {\n          this.openTag();\n        } else {\n          this.state = S_ATTRIB;\n        }\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sCloseTag\",\n    value: function sCloseTag() {\n      var c = this.captureNameChars();\n\n      if (c === GREATER) {\n        this.closeTag();\n      } else if (isS(c)) {\n        this.state = S_CLOSE_TAG_SAW_WHITE;\n      } else if (c) {\n        this.fail(\"disallowed character in closing tag.\");\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sCloseTagSawWhite\",\n    value: function sCloseTagSawWhite() {\n      var c = this.getCode();\n\n      if (c === GREATER) {\n        this.closeTag();\n      } else if (c && !isS(c)) {\n        this.fail(\"disallowed character in closing tag.\");\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sEntityFirstChar\",\n    value: function sEntityFirstChar() {\n      var c = this.getCode();\n\n      if (this.nameStartCheck(c) || c === HASH) {\n        this.entity = String.fromCodePoint(c);\n        this.state = S_ENTITY_REST;\n      } else if (c === SEMICOLON) {\n        this.fail(\"empty entity name.\");\n        this.text += \"&;\";\n        this.state = this.entityReturnState;\n      } else {\n        this.fail(\"disallowed first character in entity name.\");\n        this.entity = String.fromCodePoint(c);\n        this.badEntityName = true;\n        this.state = S_ENTITY_REST;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"sEntityRest\",\n    value: function sEntityRest() {\n      var c = this.captureWhileNameCheck(\"entity\");\n\n      if (c === SEMICOLON) {\n        // Don't try to convert if the name was bad.\n        if (this.badEntityName) {\n          this.text += \"&\".concat(this.entity).concat(String.fromCodePoint(c));\n        } else {\n          this.text += this.parseEntity(this.entity);\n        }\n\n        this.textCheckedBefore = this.text.length;\n        this.entity = \"\";\n        this.state = this.entityReturnState;\n        this.badEntityName = false;\n      } else if (c) {\n        this.fail(\"disallowed character in entity name.\");\n        this.text += \"&\".concat(this.entity).concat(String.fromCodePoint(c));\n        this.textCheckedBefore = this.text.length;\n        this.entity = \"\";\n        this.state = this.entityReturnState;\n        this.badEntityName = false;\n      }\n    } // END OF STATE HANDLERS\n\n    /**\n     * End parsing. This performs final well-formedness checks and resets the\n     * parser to a clean state.\n     *\n     * @private\n     *\n     * @returns this\n     */\n\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (!this.sawRoot) {\n        this.fail(\"document must contain a root element.\");\n      }\n\n      var tags = this.tags;\n\n      while (tags.length > 0) {\n        var tag = tags.pop();\n        this.fail(\"unclosed tag: \".concat(tag.name));\n      }\n\n      if (this.state !== S_BEGIN_WHITESPACE && this.state !== S_TEXT) {\n        this.fail(\"unexpected end.\");\n      }\n\n      if (this.text.length !== 0) {\n        this.closeText();\n      }\n\n      this.closed = true;\n      this.onend();\n\n      this._init(this.opt);\n\n      return this;\n    }\n    /**\n     * If there's text to emit ``ontext``, emit it.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"closeText\",\n    value: function closeText() {\n      this.ontext(this.text);\n      this.text = \"\";\n      this.textCheckedBefore = 0;\n    }\n    /**\n     * Resolve a namespace prefix.\n     *\n     * @param {string} prefix The prefix to resolve.\n     *\n     * @returns {string|undefined} The namespace URI or ``undefined`` if the\n     * prefix is not defined.\n     */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(prefix) {\n      var uri = this.tag.ns[prefix];\n\n      if (uri !== undefined) {\n        return uri;\n      }\n\n      var tags = this.tags;\n\n      for (var index = tags.length - 1; index >= 0; index--) {\n        uri = tags[index].ns[prefix];\n\n        if (uri !== undefined) {\n          return uri;\n        }\n      }\n\n      uri = this.ns[prefix];\n\n      if (uri) {\n        return uri;\n      }\n\n      var resolvePrefix = this.opt.resolvePrefix;\n      return resolvePrefix ? resolvePrefix(prefix) : undefined;\n    }\n    /**\n     * Parse a qname into its prefix and local name parts.\n     *\n     * @private\n     *\n     * @param {string} name The name to parse\n     *\n     * @returns {{prefix: string, local: string}}\n     */\n\n  }, {\n    key: \"qname\",\n    value: function qname(name) {\n      var colon = name.indexOf(\":\");\n\n      if (colon < 0) {\n        return {\n          prefix: \"\",\n          local: name\n        };\n      }\n\n      var local = name.substring(colon + 1);\n      var prefix = name.substring(0, colon);\n\n      if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n        this.fail(\"malformed name: \".concat(name, \".\"));\n      }\n\n      return {\n        prefix: prefix,\n        local: local\n      };\n    }\n    /** @private */\n\n  }, {\n    key: \"processAttribsNS\",\n    value: function processAttribsNS() {\n      var tag = this.tag,\n          attribList = this.attribList;\n      var tagName = tag.name,\n          attributes = tag.attributes;\n      {\n        // add namespace info to tag\n        var _this$qname2 = this.qname(tagName),\n            prefix = _this$qname2.prefix,\n            local = _this$qname2.local;\n\n        tag.prefix = prefix;\n        tag.local = local;\n        var uri = tag.uri = this.resolve(prefix) || \"\";\n\n        if (prefix) {\n          if (prefix === \"xmlns\") {\n            this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n          }\n\n          if (!uri) {\n            this.fail(\"unbound namespace prefix: \".concat(JSON.stringify(prefix), \".\"));\n            tag.uri = prefix;\n          }\n        }\n      }\n      var seen = new Set(); // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = attribList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var attr = _step.value;\n          var name = attr.name,\n              _prefix = attr.prefix,\n              _local = attr.local;\n\n          var _uri = void 0;\n\n          var eqname = void 0;\n\n          if (_prefix === \"\") {\n            _uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n            eqname = name;\n          } else {\n            _uri = this.resolve(_prefix); // if there's any attributes with an undefined namespace,\n            // then fail on them now.\n\n            if (!_uri) {\n              this.fail(\"unbound namespace prefix: \".concat(JSON.stringify(_prefix), \".\"));\n              _uri = _prefix;\n            }\n\n            eqname = \"{\".concat(_uri, \"}\").concat(_local);\n          }\n\n          if (seen.has(eqname)) {\n            this.fail(\"duplicate attribute: \".concat(eqname, \".\"));\n          }\n\n          seen.add(eqname);\n          attr.uri = _uri;\n          attributes[name] = attr;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.attribList = [];\n    }\n    /** @private */\n\n  }, {\n    key: \"processAttribsPlain\",\n    value: function processAttribsPlain() {\n      var attribList = this.attribList,\n          attributes = this.tag.attributes;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = attribList[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = _step2.value,\n              name = _step2$value.name,\n              value = _step2$value.value;\n\n          if (attributes[name]) {\n            this.fail(\"duplicate attribute: \".concat(name, \".\"));\n          }\n\n          attributes[name] = value;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.attribList = [];\n    }\n    /**\n     * Handle a complete open tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag``.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"openTag\",\n    value: function openTag() {\n      this.processAttribs();\n      var tag = this.tag,\n          tags = this.tags;\n      tag.isSelfClosing = false; // There cannot be any pending text here due to the onopentagstart that was\n      // necessarily emitted before we get here. So we do not check text.\n\n      this.onopentag(tag);\n      tags.push(tag);\n      this.state = S_TEXT;\n      this.name = \"\";\n    }\n    /**\n     * Handle a complete self-closing tag. This parser code calls this once it has\n     * seen the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag`` and ``onclosetag``.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"openSelfClosingTag\",\n    value: function openSelfClosingTag() {\n      this.processAttribs();\n      var tag = this.tag,\n          tags = this.tags;\n      tag.isSelfClosing = true; // There cannot be any pending text here due to the onopentagstart that was\n      // necessarily emitted before we get here. So we do not check text.\n\n      this.onopentag(tag);\n      this.onclosetag(tag);\n      var top = this.tag = tags[tags.length - 1];\n\n      if (!top) {\n        this.closedRoot = true;\n      }\n\n      this.state = S_TEXT;\n      this.name = \"\";\n    }\n    /**\n     * Handle a complete close tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onclosetag``.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"closeTag\",\n    value: function closeTag() {\n      var tags = this.tags,\n          name = this.name; // Our state after this will be S_TEXT, no matter what, and we can clear\n      // tagName now.\n\n      this.state = S_TEXT;\n      this.name = \"\";\n\n      if (!name) {\n        this.fail(\"weird empty close tag.\");\n        this.text += \"</>\";\n        return;\n      }\n\n      var l = tags.length;\n\n      while (l-- > 0) {\n        var tag = this.tag = tags.pop();\n\n        if (this.text.length !== 0) {\n          this.closeText();\n        }\n\n        this.onclosetag(tag);\n\n        if (tag.name === name) {\n          break;\n        }\n\n        this.fail(\"unexpected close tag.\");\n      }\n\n      if (l === 0) {\n        this.closedRoot = true;\n      } else if (l < 0) {\n        this.fail(\"unmatched closing tag: \".concat(name, \".\"));\n        this.text += \"</\".concat(name, \">\");\n      }\n    }\n    /**\n     * Resolves an entity. Makes any necessary well-formedness checks.\n     *\n     * @private\n     *\n     * @param {string} entity The entity to resolve.\n     *\n     * @returns {string} The parsed entity.\n     */\n\n  }, {\n    key: \"parseEntity\",\n    value: function parseEntity(entity) {\n      var defined = this.ENTITIES[entity];\n\n      if (defined) {\n        return defined;\n      }\n\n      var num = NaN;\n\n      if (entity[0] === \"#\") {\n        if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n          num = parseInt(entity.slice(2), 16);\n        } else if (/^#[0-9]+$/.test(entity)) {\n          num = parseInt(entity.slice(1), 10);\n        }\n      } // The character reference is required to match the CHAR production.\n\n\n      if (!isChar(num)) {\n        this.fail(\"malformed character entity.\");\n        return \"&\".concat(entity, \";\");\n      }\n\n      return String.fromCodePoint(num);\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this.chunkPosition + this.i;\n    }\n  }]);\n\n  return SaxesParser;\n}();\n\nexports.SaxesParser = SaxesParser;","map":null,"metadata":{},"sourceType":"script"}