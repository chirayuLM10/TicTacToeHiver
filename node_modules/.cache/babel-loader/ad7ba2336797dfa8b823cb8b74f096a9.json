{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/createClass\");\n\nvar fs = require(\"fs\");\n\nvar _require = require(\"whatwg-url\"),\n    parseURL = _require.parseURL;\n\nvar dataURLFromRecord = require(\"data-urls\").fromURLRecord;\n\nvar request = require(\"request-promise-native\");\n\nvar wrapCookieJarForRequest = require(\"../../living/helpers/wrap-cookie-jar-for-request\");\n\nvar packageVersion = require(\"../../../../package.json\").version;\n\nvar IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function ResourceLoader() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$strictSSL = _ref.strictSSL,\n        strictSSL = _ref$strictSSL === void 0 ? true : _ref$strictSSL,\n        _ref$proxy = _ref.proxy,\n        proxy = _ref$proxy === void 0 ? undefined : _ref$proxy,\n        _ref$userAgent = _ref.userAgent,\n        userAgent = _ref$userAgent === void 0 ? \"Mozilla/5.0 (\".concat(process.platform || \"unknown OS\", \") AppleWebKit/537.36 \") + \"(KHTML, like Gecko) jsdom/\".concat(packageVersion) : _ref$userAgent;\n\n    _classCallCheck(this, ResourceLoader);\n\n    this._strictSSL = strictSSL;\n    this._proxy = proxy;\n    this._userAgent = userAgent;\n  }\n\n  _createClass(ResourceLoader, [{\n    key: \"_readFile\",\n    value: function _readFile(filePath) {\n      var readableStream;\n      var abort; // Native Promises doesn't have an \"abort\" method.\n\n      /*\n       * Creating a promise for two reason:\n       *   1. fetch always return a promise.\n       *   2. We need to add an abort handler.\n      */\n\n      var promise = new Promise(function (resolve, reject) {\n        readableStream = fs.createReadStream(filePath);\n        var data = Buffer.alloc(0);\n        abort = reject;\n        readableStream.on(\"error\", reject);\n        readableStream.on(\"data\", function (chunk) {\n          data = Buffer.concat([data, chunk]);\n        });\n        readableStream.on(\"end\", function () {\n          resolve(data);\n        });\n      });\n\n      promise.abort = function () {\n        readableStream.destroy();\n        var error = new Error(\"request canceled by user\");\n        error.isAbortError = true;\n        abort(error);\n      };\n\n      return promise;\n    }\n  }, {\n    key: \"_getRequestOptions\",\n    value: function _getRequestOptions(_ref2) {\n      var cookieJar = _ref2.cookieJar,\n          referrer = _ref2.referrer,\n          _ref2$accept = _ref2.accept,\n          accept = _ref2$accept === void 0 ? \"*/*\" : _ref2$accept;\n      var requestOptions = {\n        encoding: null,\n        gzip: true,\n        jar: wrapCookieJarForRequest(cookieJar),\n        strictSSL: this._strictSSL,\n        proxy: this._proxy,\n        forever: true,\n        headers: {\n          \"User-Agent\": this._userAgent,\n          \"Accept-Language\": \"en\",\n          Accept: accept\n        }\n      };\n\n      if (referrer && !IS_BROWSER) {\n        requestOptions.headers.referer = referrer;\n      }\n\n      return requestOptions;\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(urlString) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var url = parseURL(urlString);\n\n      if (!url) {\n        return Promise.reject(new Error(\"Tried to fetch invalid URL \".concat(urlString)));\n      }\n\n      switch (url.scheme) {\n        case \"data\":\n          {\n            return Promise.resolve(dataURLFromRecord(url).body);\n          }\n\n        case \"http\":\n        case \"https\":\n          {\n            var requestOptions = this._getRequestOptions(options);\n\n            return request(urlString, requestOptions);\n          }\n\n        case \"file\":\n          {\n            // TODO: Improve the URL => file algorithm. See https://github.com/jsdom/jsdom/pull/2279#discussion_r199977987\n            var filePath = urlString.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n            return this._readFile(filePath);\n          }\n\n        default:\n          {\n            return Promise.reject(new Error(\"Tried to fetch URL \".concat(urlString, \" with invalid scheme \").concat(url.scheme)));\n          }\n      }\n    }\n  }]);\n\n  return ResourceLoader;\n}();","map":null,"metadata":{},"sourceType":"script"}