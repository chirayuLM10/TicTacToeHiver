{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/createClass\");\n\nvar parse5 = require(\"parse5\");\n\nvar saxes = require(\"saxes\");\n\nvar attributes = require(\"../living/attributes\");\n\nvar DocumentType = require(\"../living/generated/DocumentType\");\n\nvar JSDOMParse5Adapter = require(\"./parse5-adapter-parsing\");\n\nvar _require = require(\"../living/helpers/namespaces\"),\n    HTML_NS = _require.HTML_NS; // Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237\n\n\nvar OpenElementStack = require(\"parse5/lib/parser/open-element-stack\");\n\nvar originalPop = OpenElementStack.prototype.pop;\n\nOpenElementStack.prototype.pop = function () {\n  var before = this.items[this.stackTop];\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  originalPop.apply(this, args);\n\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nvar originalPush = OpenElementStack.prototype.push;\n\nOpenElementStack.prototype.push = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  originalPush.apply(this, args);\n  var after = this.items[this.stackTop];\n\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function HTMLToDOM(parsingMode) {\n    _classCallCheck(this, HTMLToDOM);\n\n    this.parser = parsingMode === \"xml\" ? saxes : parse5;\n  }\n\n  _createClass(HTMLToDOM, [{\n    key: \"appendToNode\",\n    value: function appendToNode(html, node) {\n      html = String(html);\n      return this._doParse(html, true, node);\n    }\n  }, {\n    key: \"appendToDocument\",\n    value: function appendToDocument(html, documentImpl) {\n      html = String(html);\n      return this._doParse(html, false, documentImpl, documentImpl._parseOptions);\n    }\n  }, {\n    key: \"_doParse\",\n    value: function _doParse() {\n      return this.parser === parse5 ? this._parseWithParse5.apply(this, arguments) : this._parseWithSaxes.apply(this, arguments);\n    }\n  }, {\n    key: \"_parseWithParse5\",\n    value: function _parseWithParse5(html, isFragment, contextNode) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var adapter = new JSDOMParse5Adapter(contextNode._ownerDocument || contextNode);\n      options.treeAdapter = adapter;\n\n      if (isFragment) {\n        var fragment = this.parser.parseFragment(contextNode, html, options);\n\n        if (contextNode._templateContents) {\n          contextNode._templateContents.appendChild(fragment);\n        } else {\n          contextNode.appendChild(fragment);\n        }\n      } else {\n        this.parser.parse(html, options);\n      }\n\n      return contextNode;\n    }\n  }, {\n    key: \"_parseWithSaxes\",\n    value: function _parseWithSaxes(html, isFragment, contextNode) {\n      var parserOptions = {\n        xmlns: true\n      };\n\n      if (isFragment) {\n        parserOptions.fragment = true;\n\n        parserOptions.resolvePrefix = function (prefix) {\n          // saxes wants undefined as the return value if the prefix is not\n          // defined, not null.\n          return contextNode.lookupNamespaceURI(prefix) || undefined;\n        };\n      }\n\n      var parser = new this.parser.SaxesParser(parserOptions);\n      var openStack = [contextNode];\n      var currentDocument = contextNode._ownerDocument || contextNode;\n      parser.ontext = isFragment ? // In a fragment, all text events produced by saxes must result in a text\n      // node.\n      function (text) {\n        appendChild(openStack[openStack.length - 1], currentDocument.createTextNode(text));\n      } : // When parsing a whole document, we must ignore those text nodes that are\n      // produced outside the root element. Saxes produces events for them,\n      // but DOM trees do not record text outside the root element.\n      function (text) {\n        if (openStack.length > 1) {\n          appendChild(openStack[openStack.length - 1], currentDocument.createTextNode(text));\n        }\n      };\n\n      parser.oncdata = function (cdata) {\n        appendChild(openStack[openStack.length - 1], currentDocument.createCDATASection(cdata));\n      };\n\n      parser.onopentag = function (tag) {\n        var tagLocal = tag.local,\n            tagURI = tag.uri,\n            tagPrefix = tag.prefix,\n            tagAttributes = tag.attributes;\n\n        var elem = currentDocument._createElementWithCorrectElementInterface(tagLocal, tagURI);\n\n        elem._prefix = tagPrefix || null;\n        elem._namespaceURI = tagURI || null; // We mark a script element as \"parser-inserted\", which prevents it from\n        // being immediately executed.\n\n        if (tagLocal === \"script\" && tagURI === HTML_NS) {\n          elem._parserInserted = true;\n        }\n\n        var _arr = Object.keys(tagAttributes);\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var key = _arr[_i];\n          var _tagAttributes$key = tagAttributes[key],\n              prefix = _tagAttributes$key.prefix,\n              local = _tagAttributes$key.local,\n              uri = _tagAttributes$key.uri,\n              value = _tagAttributes$key.value;\n          attributes.setAttributeValue(elem, local, value, prefix === \"\" ? null : prefix, uri === \"\" ? null : uri);\n        }\n\n        appendChild(openStack[openStack.length - 1], elem);\n        openStack.push(elem);\n      };\n\n      parser.onclosetag = function () {\n        var elem = openStack.pop(); // Once a script is populated, we can execute it.\n\n        if (elem.localName === \"script\" && elem.namespaceURI === HTML_NS) {\n          elem._eval();\n        }\n      };\n\n      parser.oncomment = function (comment) {\n        appendChild(openStack[openStack.length - 1], currentDocument.createComment(comment));\n      };\n\n      parser.onprocessinginstruction = function (_ref) {\n        var target = _ref.target,\n            body = _ref.body;\n        appendChild(openStack[openStack.length - 1], currentDocument.createProcessingInstruction(target, body));\n      };\n\n      parser.ondoctype = function (dt) {\n        appendChild(openStack[openStack.length - 1], parseDocType(currentDocument, \"<!doctype \".concat(dt, \">\")));\n        var entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n        var result;\n\n        while (result = entityMatcher.exec(dt)) {\n          var _result = result,\n              _result2 = _slicedToArray(_result, 3),\n              name = _result2[1],\n              value = _result2[2];\n\n          if (!(name in parser.ENTITIES)) {\n            parser.ENTITIES[name] = value;\n          }\n        }\n      };\n\n      parser.onerror = function (err) {\n        throw err;\n      };\n\n      parser.write(html).close();\n    }\n  }]);\n\n  return HTMLToDOM;\n}();\n\nfunction appendChild(parent, child) {\n  if (parent._templateContents) {\n    // Template elements do not have children but instead store their content\n    // in a separate hierarchy.\n    parent._templateContents._insert(child, null);\n  } else {\n    parent._insert(child, null);\n  }\n}\n\nvar HTML5_DOCTYPE = /<!doctype html>/i;\nvar PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nvar SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\nvar CUSTOM_NAME_DOCTYPE = /<!doctype\\s+([^\\s>]+)/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n  }\n\n  var publicPieces = PUBLIC_DOCTYPE.exec(html);\n\n  if (publicPieces) {\n    return createDocumentTypeInternal(doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  var systemPieces = SYSTEM_DOCTYPE.exec(html);\n\n  if (systemPieces) {\n    return createDocumentTypeInternal(doc, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  var namePiece = CUSTOM_NAME_DOCTYPE.exec(html)[1] || \"html\";\n  return createDocumentTypeInternal(doc, namePiece, \"\", \"\");\n}\n\nfunction createDocumentTypeInternal(ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], {\n    ownerDocument: ownerDocument,\n    name: name,\n    publicId: publicId,\n    systemId: systemId\n  });\n}","map":null,"metadata":{},"sourceType":"script"}