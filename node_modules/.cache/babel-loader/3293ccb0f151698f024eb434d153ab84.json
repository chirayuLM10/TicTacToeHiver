{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar _require = require(\"./internal-constants\"),\n    domSymbolTree = _require.domSymbolTree;\n\nvar _require2 = require(\"./namespaces\"),\n    HTML_NS = _require2.HTML_NS;\n\nvar _require3 = require(\"./mutation-observers\"),\n    signalSlotList = _require3.signalSlotList,\n    queueMutationObserverMicrotask = _require3.queueMutationObserverMicrotask; // Valid host element for ShadowRoot.\n// Defined in: https://dom.spec.whatwg.org/#dom-element-attachshadow\n\n\nvar VALID_HOST_ELEMENT_NAME = new Set([\"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\"]);\n\nfunction isValidHostElementName(name) {\n  return VALID_HOST_ELEMENT_NAME.has(name);\n} // Use an approximation by checking the presence of nodeType instead of instead of using the isImpl from\n// \"../generated/Node\" to avoid introduction of circular dependencies.\n\n\nfunction isNode(nodeImpl) {\n  return Boolean(nodeImpl && \"nodeType\" in nodeImpl);\n} // Use an approximation by checking the value of nodeType and presence of nodeType host instead of instead\n// of using the isImpl from \"../generated/ShadowRoot\" to avoid introduction of circular dependencies.\n\n\nfunction isShadowRoot(nodeImpl) {\n  return Boolean(nodeImpl && nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE && \"host\" in nodeImpl);\n} // https://dom.spec.whatwg.org/#concept-slotable\n\n\nfunction isSlotable(nodeImpl) {\n  return nodeImpl && (nodeImpl.nodeType === NODE_TYPE.ELEMENT_NODE || nodeImpl.nodeType === NODE_TYPE.TEXT_NODE);\n}\n\nfunction isSlot(nodeImpl) {\n  return nodeImpl && nodeImpl.localName === \"slot\" && nodeImpl._namespaceURI === HTML_NS;\n} // https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-ancestor\n\n\nfunction isShadowInclusiveAncestor(ancestor, node) {\n  while (isNode(node)) {\n    if (node === ancestor) {\n      return true;\n    }\n\n    if (isShadowRoot(node)) {\n      node = node.host;\n    } else {\n      node = domSymbolTree.parent(node);\n    }\n  }\n\n  return false;\n} // https://dom.spec.whatwg.org/#retarget\n\n\nfunction retarget(a, b) {\n  while (true) {\n    if (!isNode(a)) {\n      return a;\n    }\n\n    var aRoot = getRoot(a);\n\n    if (!isShadowRoot(aRoot) || isNode(b) && isShadowInclusiveAncestor(aRoot, b)) {\n      return a;\n    }\n\n    a = getRoot(a).host;\n  }\n} // https://dom.spec.whatwg.org/#get-the-parent\n\n\nfunction getEventTargetParent(eventTarget, event) {\n  // _getTheParent will be missing for Window, since it doesn't have an impl class and we don't want to pollute the\n  // user-visible global scope with a _getTheParent value. TODO: remove this entire function and use _getTheParent\n  // directly, once Window gets split into impl/wrapper.\n  return eventTarget._getTheParent ? eventTarget._getTheParent(event) : null;\n}\n\nfunction getRoot(node) {\n  var root;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = domSymbolTree.ancestorsIterator(node)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var ancestor = _step.value;\n      root = ancestor;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return root;\n} // https://dom.spec.whatwg.org/#concept-shadow-including-root\n\n\nfunction shadowIncludingRoot(node) {\n  var root = getRoot(node);\n  return isShadowRoot(root) ? shadowIncludingRoot(root.host) : root;\n} // https://dom.spec.whatwg.org/#assign-a-slot\n\n\nfunction assignSlot(slotable) {\n  var slot = findSlot(slotable);\n\n  if (slot) {\n    assignSlotable(slot);\n  }\n} // https://dom.spec.whatwg.org/#assign-slotables\n\n\nfunction assignSlotable(slot) {\n  var slotables = findSlotable(slot);\n  var shouldFireSlotChange = false;\n\n  if (slotables.length !== slot._assignedNodes.length) {\n    shouldFireSlotChange = true;\n  } else {\n    for (var i = 0; i < slotables.length; i++) {\n      if (slotables[i] !== slot._assignedNodes[i]) {\n        shouldFireSlotChange = true;\n        break;\n      }\n    }\n  }\n\n  if (shouldFireSlotChange) {\n    signalSlotChange(slot);\n  }\n\n  slot._assignedNodes = slotables;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = slotables[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var slotable = _step2.value;\n      slotable._assignedSlot = slot;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n} // https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\n\n\nfunction assignSlotableForTree(root) {\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = domSymbolTree.treeIterator(root)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var slot = _step3.value;\n\n      if (isSlot(slot)) {\n        assignSlotable(slot);\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n} // https://dom.spec.whatwg.org/#find-slotables\n\n\nfunction findSlotable(slot) {\n  var result = [];\n  var root = getRoot(slot);\n\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = domSymbolTree.treeIterator(root.host)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var slotable = _step4.value;\n      var foundSlot = findSlot(slotable);\n\n      if (foundSlot === slot) {\n        result.push(slotable);\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return result;\n} // https://dom.spec.whatwg.org/#find-flattened-slotables\n\n\nfunction findFlattenedSlotables(slot) {\n  var result = [];\n  var root = getRoot(slot);\n\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  var slotables = findSlotable(slot);\n\n  if (slotables.length === 0) {\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = domSymbolTree.childrenIterator(slot)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var child = _step5.value;\n\n        if (isSlotable(child)) {\n          slotables.push(child);\n        }\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion6 = true;\n  var _didIteratorError6 = false;\n  var _iteratorError6 = undefined;\n\n  try {\n    for (var _iterator6 = slotables[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n      var node = _step6.value;\n\n      if (isSlot(node) && isShadowRoot(getRoot(node))) {\n        var temporaryResult = findFlattenedSlotables(node);\n        result.push.apply(result, _toConsumableArray(temporaryResult));\n      } else {\n        result.push(node);\n      }\n    }\n  } catch (err) {\n    _didIteratorError6 = true;\n    _iteratorError6 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n        _iterator6.return();\n      }\n    } finally {\n      if (_didIteratorError6) {\n        throw _iteratorError6;\n      }\n    }\n  }\n\n  return result;\n} // https://dom.spec.whatwg.org/#find-a-slot\n\n\nfunction findSlot(slotable, openFlag) {\n  var parent = slotable.parentNode;\n\n  if (!parent) {\n    return null;\n  }\n\n  var shadow = parent._shadowRoot;\n\n  if (!shadow || openFlag && shadow.mode !== \"open\") {\n    return null;\n  }\n\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = domSymbolTree.treeIterator(shadow)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var child = _step7.value;\n\n      if (isSlot(child) && child.name === slotable._slotableName) {\n        return child;\n      }\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n\n  return null;\n} // https://dom.spec.whatwg.org/#signal-a-slot-change\n\n\nfunction signalSlotChange(slot) {\n  if (!signalSlotList.some(function (entry) {\n    return entry === slot;\n  })) {\n    signalSlotList.push(slot);\n  }\n\n  queueMutationObserverMicrotask();\n}\n\nmodule.exports = {\n  isValidHostElementName: isValidHostElementName,\n  isNode: isNode,\n  isSlotable: isSlotable,\n  isSlot: isSlot,\n  isShadowRoot: isShadowRoot,\n  isShadowInclusiveAncestor: isShadowInclusiveAncestor,\n  retarget: retarget,\n  getEventTargetParent: getEventTargetParent,\n  getRoot: getRoot,\n  shadowIncludingRoot: shadowIncludingRoot,\n  assignSlot: assignSlot,\n  assignSlotable: assignSlotable,\n  assignSlotableForTree: assignSlotableForTree,\n  findSlot: findSlot,\n  findFlattenedSlotables: findFlattenedSlotables,\n  signalSlotChange: signalSlotChange\n};","map":null,"metadata":{},"sourceType":"script"}