{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _require = require(\"./internal-constants\"),\n    domSymbolTree = _require.domSymbolTree;\n\nvar reportException = require(\"./runtime-script-errors\");\n\nvar Event = require(\"../generated/Event\");\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar MutationRecord = require(\"../generated/MutationRecord\");\n\nvar MUTATION_TYPE = {\n  ATTRIBUTES: \"attributes\",\n  CHARACTER_DATA: \"characterData\",\n  CHILD_LIST: \"childList\"\n}; // Note:\n// Since jsdom doesn't currently implement the concept of \"unit of related similar-origin browsing contexts\"\n// (https://html.spec.whatwg.org/multipage/browsers.html#unit-of-related-similar-origin-browsing-contexts)\n// we will approximate that the following properties are global for now.\n// https://dom.spec.whatwg.org/#mutation-observer-compound-microtask-queued-flag\n\nvar mutationObserverMicrotaskQueueFlag = false; // Non-spec compliant: List of all the mutation observers with mutation records enqueued. It's a replacement for\n// mutation observer list (https://dom.spec.whatwg.org/#mutation-observer-list) but without leaking since it's empty\n// before notifying the mutation observers.\n\nvar activeMutationObservers = new Set(); // https://dom.spec.whatwg.org/#signal-slot-list\n\nvar signalSlotList = []; // https://dom.spec.whatwg.org/#queue-a-mutation-record\n\nfunction queueMutationRecord(type, target, name, namespace, oldValue, addedNodes, removedNodes, previousSibling, nextSibling) {\n  var interestedObservers = new Map();\n  var nodes = domSymbolTree.ancestorsToArray(target);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var node = _step.value;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = node._registeredObserverList[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var registered = _step3.value;\n          var options = registered.options,\n              mo = registered.observer;\n\n          if (!(node !== target && options.subtree === false) && !(type === MUTATION_TYPE.ATTRIBUTES && options.attributes !== true) && !(type === MUTATION_TYPE.ATTRIBUTES && options.attributeFilter && !options.attributeFilter.some(function (value) {\n            return value === name || value === namespace;\n          })) && !(type === MUTATION_TYPE.CHARACTER_DATA && options.characterData !== true) && !(type === MUTATION_TYPE.CHILD_LIST && options.childList === false)) {\n            if (!interestedObservers.has(mo)) {\n              interestedObservers.set(mo, null);\n            }\n\n            if (type === MUTATION_TYPE.ATTRIBUTES && options.attributeOldValue === true || type === MUTATION_TYPE.CHARACTER_DATA && options.characterDataOldValue === true) {\n              interestedObservers.set(mo, oldValue);\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = interestedObservers.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          observer = _step2$value[0],\n          mappedOldValue = _step2$value[1];\n\n      var record = MutationRecord.createImpl([], {\n        type: type,\n        target: target,\n        attributeName: name,\n        attributeNamespace: namespace,\n        oldValue: mappedOldValue,\n        addedNodes: addedNodes,\n        removedNodes: removedNodes,\n        previousSibling: previousSibling,\n        nextSibling: nextSibling\n      });\n\n      observer._recordQueue.push(record);\n\n      activeMutationObservers.add(observer);\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  queueMutationObserverMicrotask();\n} // https://dom.spec.whatwg.org/#queue-a-tree-mutation-record\n\n\nfunction queueTreeMutationRecord(target, addedNodes, removedNodes, previousSibling, nextSibling) {\n  queueMutationRecord(MUTATION_TYPE.CHILD_LIST, target, null, null, null, addedNodes, removedNodes, previousSibling, nextSibling);\n} // https://dom.spec.whatwg.org/#queue-an-attribute-mutation-record\n\n\nfunction queueAttributeMutationRecord(target, name, namespace, oldValue) {\n  queueMutationRecord(MUTATION_TYPE.ATTRIBUTES, target, name, namespace, oldValue, [], [], null, null);\n} // https://dom.spec.whatwg.org/#queue-a-mutation-observer-compound-microtask\n\n\nfunction queueMutationObserverMicrotask() {\n  if (mutationObserverMicrotaskQueueFlag) {\n    return;\n  }\n\n  mutationObserverMicrotaskQueueFlag = true;\n  Promise.resolve().then(function () {\n    notifyMutationObservers();\n  });\n} // https://dom.spec.whatwg.org/#notify-mutation-observers\n\n\nfunction notifyMutationObservers() {\n  mutationObserverMicrotaskQueueFlag = false;\n\n  var notifyList = _toConsumableArray(activeMutationObservers).sort(function (a, b) {\n    return a._id - b._id;\n  });\n\n  activeMutationObservers.clear();\n  var signalList = [].concat(signalSlotList);\n  signalSlotList.splice(0, signalSlotList.length);\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var mo = _step4.value;\n\n      var records = _toConsumableArray(mo._recordQueue);\n\n      mo._recordQueue = [];\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = mo._nodeList[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var node = _step6.value;\n          node._registeredObserverList = node._registeredObserverList.filter(function (registeredObserver) {\n            return registeredObserver.source !== mo;\n          });\n\n          if (records.length) {\n            try {\n              mo._callback(records.map(idlUtils.wrapperForImpl), idlUtils.wrapperForImpl(mo));\n            } catch (e) {\n              var target = records[0].target;\n              var window = target._ownerDocument._defaultView;\n              reportException(window, e);\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    };\n\n    for (var _iterator4 = notifyList[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      _loop();\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = signalList[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var slot = _step5.value;\n      var slotChangeEvent = Event.createImpl([\"slotchange\", {\n        bubbles: true\n      }], {\n        isTrusted: true\n      });\n\n      slot._dispatch(slotChangeEvent);\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  MUTATION_TYPE: MUTATION_TYPE,\n  queueMutationRecord: queueMutationRecord,\n  queueTreeMutationRecord: queueTreeMutationRecord,\n  queueAttributeMutationRecord: queueAttributeMutationRecord,\n  queueMutationObserverMicrotask: queueMutationObserverMicrotask,\n  signalSlotList: signalSlotList\n};","map":null,"metadata":{},"sourceType":"script"}