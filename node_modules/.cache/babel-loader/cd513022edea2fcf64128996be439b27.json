{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/admin/Downloads/tictactoe-master/node_modules/@babel/runtime/helpers/createClass\");\n\nvar DOMException = require(\"domexception\");\n\nvar reportException = require(\"../helpers/runtime-script-errors\");\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar _require = require(\"../helpers/shadow-dom\"),\n    isNode = _require.isNode,\n    isShadowRoot = _require.isShadowRoot,\n    isSlotable = _require.isSlotable,\n    getRoot = _require.getRoot,\n    getEventTargetParent = _require.getEventTargetParent,\n    isShadowInclusiveAncestor = _require.isShadowInclusiveAncestor,\n    retarget = _require.retarget;\n\nvar Event = require(\"../generated/Event\").interface;\n\nvar MouseEvent = require(\"../generated/MouseEvent\");\n\nvar EventTargetImpl =\n/*#__PURE__*/\nfunction () {\n  function EventTargetImpl() {\n    _classCallCheck(this, EventTargetImpl);\n\n    this._eventListeners = Object.create(null);\n  }\n\n  _createClass(EventTargetImpl, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, callback, options) {\n      // webidl2js currently can't handle neither optional arguments nor callback interfaces\n      if (callback === undefined || callback === null) {\n        callback = null;\n      } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n        throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n      }\n\n      options = normalizeEventHandlerOptions(options, [\"capture\", \"once\", \"passive\"]);\n\n      if (callback === null) {\n        return;\n      }\n\n      if (!this._eventListeners[type]) {\n        this._eventListeners[type] = [];\n      }\n\n      for (var i = 0; i < this._eventListeners[type].length; ++i) {\n        var listener = this._eventListeners[type][i];\n\n        if (listener.options.capture === options.capture && listener.callback === callback) {\n          return;\n        }\n      }\n\n      this._eventListeners[type].push({\n        callback: callback,\n        options: options\n      });\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, callback, options) {\n      if (callback === undefined || callback === null) {\n        callback = null;\n      } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n        throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n      }\n\n      options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n      if (callback === null) {\n        // Optimization, not in the spec.\n        return;\n      }\n\n      if (!this._eventListeners[type]) {\n        return;\n      }\n\n      for (var i = 0; i < this._eventListeners[type].length; ++i) {\n        var listener = this._eventListeners[type][i];\n\n        if (listener.callback === callback && listener.options.capture === options.capture) {\n          this._eventListeners[type].splice(i, 1);\n\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(eventImpl) {\n      if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n        throw new DOMException(\"Tried to dispatch an uninitialized event\", \"InvalidStateError\");\n      }\n\n      if (eventImpl.eventPhase !== Event.NONE) {\n        throw new DOMException(\"Tried to dispatch a dispatching event\", \"InvalidStateError\");\n      }\n\n      eventImpl.isTrusted = false;\n      return this._dispatch(eventImpl);\n    } // https://dom.spec.whatwg.org/#get-the-parent\n\n  }, {\n    key: \"_getTheParent\",\n    value: function _getTheParent() {\n      return null;\n    } // https://dom.spec.whatwg.org/#concept-event-dispatch\n    // legacyOutputDidListenersThrowFlag optional parameter is not necessary here since it is only used by indexDB.\n\n  }, {\n    key: \"_dispatch\",\n    value: function _dispatch(eventImpl, targetOverride\n    /* , legacyOutputDidListenersThrowFlag */\n    ) {\n      var targetImpl = this;\n      var clearTargets = false;\n      var activationTarget = null;\n      eventImpl._dispatchFlag = true;\n      targetOverride = targetOverride || targetImpl;\n      var relatedTarget = retarget(eventImpl.relatedTarget, targetImpl);\n\n      if (targetImpl !== relatedTarget || targetImpl === eventImpl.relatedTarget) {\n        var touchTargets = [];\n        appendToEventPath(eventImpl, targetImpl, targetOverride, relatedTarget, touchTargets, false);\n        var isActivationEvent = MouseEvent.isImpl(eventImpl) && eventImpl.type === \"click\";\n\n        if (isActivationEvent && targetImpl._hasActivationBehavior) {\n          activationTarget = targetImpl;\n        }\n\n        var slotInClosedTree = false;\n        var slotable = isSlotable(targetImpl) && targetImpl._assignedSlot ? targetImpl : null;\n        var parent = getEventTargetParent(targetImpl, eventImpl); // Populate event path\n        // https://dom.spec.whatwg.org/#event-path\n\n        while (parent !== null) {\n          if (slotable !== null) {\n            if (parent.localName !== \"slot\") {\n              throw new Error(\"JSDOM Internal Error: Expected parent to be a Slot\");\n            }\n\n            slotable = null;\n            var parentRoot = getRoot(parent);\n\n            if (isShadowRoot(parentRoot) && parentRoot.mode === \"closed\") {\n              slotInClosedTree = true;\n            }\n          }\n\n          if (isSlotable(parent) && parent._assignedSlot) {\n            slotable = parent;\n          }\n\n          relatedTarget = retarget(eventImpl.relatedTarget, parent);\n\n          if (isNode(parent) && isShadowInclusiveAncestor(getRoot(targetImpl), parent) || idlUtils.wrapperForImpl(parent).constructor.name === \"Window\") {\n            if (isActivationEvent && eventImpl.bubbles && activationTarget === null && parent._hasActivationBehavior) {\n              activationTarget = parent;\n            }\n\n            appendToEventPath(eventImpl, parent, null, relatedTarget, touchTargets, slotInClosedTree);\n          } else if (parent === relatedTarget) {\n            parent = null;\n          } else {\n            targetImpl = parent;\n\n            if (isActivationEvent && activationTarget === null && targetImpl._hasActivationBehavior) {\n              activationTarget = targetImpl;\n            }\n\n            appendToEventPath(eventImpl, parent, targetImpl, relatedTarget, touchTargets, slotInClosedTree);\n          }\n\n          if (parent !== null) {\n            parent = getEventTargetParent(parent, eventImpl);\n          }\n\n          slotInClosedTree = false;\n        }\n\n        var clearTargetsTupleIndex = -1;\n\n        for (var i = eventImpl._path.length - 1; i >= 0 && clearTargetsTupleIndex === -1; i--) {\n          if (eventImpl._path[i].target !== null) {\n            clearTargetsTupleIndex = i;\n          }\n        }\n\n        var clearTargetsTuple = eventImpl._path[clearTargetsTupleIndex];\n        clearTargets = isNode(clearTargetsTuple.target) && isShadowRoot(getRoot(clearTargetsTuple.target)) || isNode(clearTargetsTuple.relatedTarget) && isShadowRoot(getRoot(clearTargetsTuple.relatedTarget));\n        eventImpl.eventPhase = Event.CAPTURING_PHASE;\n\n        if (activationTarget !== null && activationTarget._legacyPreActivationBehavior) {\n          activationTarget._legacyPreActivationBehavior();\n        }\n\n        for (var _i = eventImpl._path.length - 1; _i >= 0; --_i) {\n          var tuple = eventImpl._path[_i];\n\n          if (tuple.target === null) {\n            invokeEventListeners(tuple, eventImpl);\n          }\n        }\n\n        for (var _i2 = 0; _i2 < eventImpl._path.length; _i2++) {\n          var _tuple = eventImpl._path[_i2];\n\n          if (_tuple.target !== null) {\n            eventImpl.eventPhase = Event.AT_TARGET;\n          } else {\n            eventImpl.eventPhase = Event.BUBBLING_PHASE;\n          }\n\n          if (eventImpl.eventPhase === Event.BUBBLING_PHASE && eventImpl.bubbles || eventImpl.eventPhase === Event.AT_TARGET) {\n            invokeEventListeners(_tuple, eventImpl);\n          }\n        }\n      }\n\n      eventImpl.eventPhase = Event.NONE;\n      eventImpl.currentTarget = null;\n      eventImpl._path = [];\n      eventImpl._dispatchFlag = false;\n      eventImpl._stopPropagationFlag = false;\n      eventImpl._stopImmediatePropagationFlag = false;\n\n      if (clearTargets) {\n        eventImpl.target = null;\n        eventImpl.relatedTarget = null;\n      }\n\n      if (activationTarget !== null) {\n        if (!eventImpl._canceledFlag) {\n          activationTarget._activationBehavior();\n        } else if (activationTarget._legacyCanceledActivationBehavior) {\n          activationTarget._legacyCanceledActivationBehavior();\n        }\n      }\n\n      return !eventImpl._canceledFlag;\n    }\n  }]);\n\n  return EventTargetImpl;\n}();\n\nmodule.exports = {\n  implementation: EventTargetImpl\n}; // https://dom.spec.whatwg.org/#concept-event-listener-invoke\n\nfunction invokeEventListeners(tuple, eventImpl) {\n  var tupleIndex = eventImpl._path.indexOf(tuple);\n\n  for (var i = tupleIndex; i >= 0; i--) {\n    var t = eventImpl._path[i];\n\n    if (t.target) {\n      eventImpl.target = t.target;\n      break;\n    }\n  }\n\n  eventImpl.relatedTarget = idlUtils.wrapperForImpl(tuple.relatedTarget);\n\n  if (eventImpl._stopPropagationFlag) {\n    return;\n  }\n\n  eventImpl.currentTarget = idlUtils.wrapperForImpl(tuple.item);\n  var listeners = tuple.item._eventListeners;\n  innerInvokeEventListeners(eventImpl, listeners);\n} // https://dom.spec.whatwg.org/#concept-event-listener-inner-invoke\n\n\nfunction innerInvokeEventListeners(eventImpl, listeners) {\n  var found = false;\n  var type = eventImpl.type,\n      target = eventImpl.target;\n  var wrapper = idlUtils.wrapperForImpl(target);\n\n  if (!listeners || !listeners[type]) {\n    return found;\n  } // Copy event listeners before iterating since the list can be modified during the iteration.\n\n\n  var handlers = listeners[type].slice();\n\n  for (var i = 0; i < handlers.length; i++) {\n    var listener = handlers[i];\n    var _listener$options = listener.options,\n        capture = _listener$options.capture,\n        once = _listener$options.once,\n        passive = _listener$options.passive; // Check if the event listener has been removed since the listeners has been cloned.\n\n    if (!listeners[type].includes(listener)) {\n      continue;\n    }\n\n    found = true;\n\n    if (eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture || eventImpl.eventPhase === Event.BUBBLING_PHASE && capture) {\n      continue;\n    }\n\n    if (once) {\n      listeners[type].splice(listeners[type].indexOf(listener), 1);\n    }\n\n    if (passive) {\n      eventImpl._inPassiveListenerFlag = true;\n    }\n\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(eventImpl.currentTarget, idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      var window = null;\n\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      } // Errors in window-less documents just get swallowed... can you think of anything better?\n\n    }\n\n    eventImpl._inPassiveListenerFlag = false;\n\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return found;\n    }\n  }\n\n  return found;\n}\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\n\n\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  var returnValue = {}; // no need to go further here\n\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  } // non objects options so we typecast its value as \"capture\" value\n\n\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options); // at this point we don't need to loop the \"capture\" key anymore\n\n    defaultBoolKeys = defaultBoolKeys.filter(function (k) {\n      return k !== \"capture\";\n    });\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = defaultBoolKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n      returnValue[key] = Boolean(options[key]);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return returnValue;\n} // https://dom.spec.whatwg.org/#concept-event-path-append\n\n\nfunction appendToEventPath(eventImpl, target, targetOverride, relatedTarget, touchTargets, slotInClosedTree) {\n  var itemInShadowTree = isNode(target) && isShadowRoot(getRoot(target));\n  var rootOfClosedTree = isShadowRoot(target) && target.mode === \"closed\";\n\n  eventImpl._path.push({\n    item: target,\n    itemInShadowTree: itemInShadowTree,\n    target: targetOverride,\n    relatedTarget: relatedTarget,\n    touchTargets: touchTargets,\n    rootOfClosedTree: rootOfClosedTree,\n    slotInClosedTree: slotInClosedTree\n  });\n}","map":null,"metadata":{},"sourceType":"script"}