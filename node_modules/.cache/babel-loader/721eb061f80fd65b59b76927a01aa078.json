{"ast":null,"code":"(function () {\n  function create(window) {\n    if (window == null) {\n      window = require('jsdom').jsdom().createWindow(); // assume window is a jsdom instance...\n      // jsdom includes an incomplete version of XMLHttpRequest\n\n      window.XMLHttpRequest = require(\"xmlhttprequest\").XMLHttpRequest; // trick jQuery into thinking CORS is supported (should be in node-XMLHttpRequest)\n\n      window.XMLHttpRequest.prototype.withCredentials = false;\n\n      if (window.location == null) {\n        window.location = require('location');\n      }\n\n      if (window.navigator == null) {\n        window.navigator = require('navigator');\n      }\n    }\n\n    var location = window.location,\n        navigator = window.navigator,\n        XMLHttpRequest = window.XMLHttpRequest;\n    /*!\n    * jQuery JavaScript Library v1.7.2\n    * http://jquery.com/\n    *\n    * Copyright 2011, John Resig\n    * Dual licensed under the MIT or GPL Version 2 licenses.\n    * http://jquery.org/license\n    *\n    * Includes Sizzle.js\n    * http://sizzlejs.com/\n    * Copyright 2011, The Dojo Foundation\n    * Released under the MIT, BSD, and GPL Licenses.\n    *\n    * Date: Wed Mar 21 12:46:34 2012 -0700\n    */\n\n    (function (window, undefined) {\n      // Use the correct document accordingly with window argument (sandbox)\n      var document = window.document,\n          navigator = window.navigator,\n          location = window.location;\n\n      var jQuery = function () {\n        // Define a local copy of jQuery\n        var jQuery = function jQuery(selector, context) {\n          // The jQuery object is actually just the init constructor 'enhanced'\n          return new jQuery.fn.init(selector, context, rootjQuery);\n        },\n            // Map over jQuery in case of overwrite\n        _jQuery = window.jQuery,\n            // Map over the $ in case of overwrite\n        _$ = window.$,\n            // A central reference to the root jQuery(document)\n        rootjQuery,\n            // A simple way to check for HTML strings or ID strings\n        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n        quickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,\n            // Check if a string has a non-whitespace character in it\n        rnotwhite = /\\S/,\n            // Used for trimming whitespace\n        trimLeft = /^\\s+/,\n            trimRight = /\\s+$/,\n            // Match a standalone tag\n        rsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/,\n            // JSON RegExp\n        rvalidchars = /^[\\],:{}\\s]*$/,\n            rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\n            rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\n            rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n            // Useragent RegExp\n        rwebkit = /(webkit)[ \\/]([\\w.]+)/,\n            ropera = /(opera)(?:.*version)?[ \\/]([\\w.]+)/,\n            rmsie = /(msie) ([\\w.]+)/,\n            rmozilla = /(mozilla)(?:.*? rv:([\\w.]+))?/,\n            // Matches dashed string for camelizing\n        rdashAlpha = /-([a-z]|[0-9])/ig,\n            rmsPrefix = /^-ms-/,\n            // Used by jQuery.camelCase as callback to replace()\n        fcamelCase = function fcamelCase(all, letter) {\n          return (letter + \"\").toUpperCase();\n        },\n            // Keep a UserAgent string for use with jQuery.browser\n        userAgent = navigator.userAgent,\n            // For matching the engine and version of the browser\n        browserMatch,\n            // The deferred used on DOM ready\n        readyList,\n            // The ready event handler\n        _DOMContentLoaded2,\n            // Save a reference to some core methods\n        toString = Object.prototype.toString,\n            hasOwn = Object.prototype.hasOwnProperty,\n            push = Array.prototype.push,\n            _slice = Array.prototype.slice,\n            trim = String.prototype.trim,\n            indexOf = Array.prototype.indexOf,\n            // [[Class]] -> type pairs\n        class2type = {};\n\n        jQuery.fn = jQuery.prototype = {\n          constructor: jQuery,\n          init: function init(selector, context, rootjQuery) {\n            var match, elem, ret, doc; // Handle $(\"\"), $(null), or $(undefined)\n\n            if (!selector) {\n              return this;\n            } // Handle $(DOMElement)\n\n\n            if (selector.nodeType) {\n              this.context = this[0] = selector;\n              this.length = 1;\n              return this;\n            } // The body element only exists once, optimize finding it\n\n\n            if (selector === \"body\" && !context && document.body) {\n              this.context = document;\n              this[0] = document.body;\n              this.selector = selector;\n              this.length = 1;\n              return this;\n            } // Handle HTML strings\n\n\n            if (typeof selector === \"string\") {\n              // Are we dealing with HTML string or an ID?\n              if (selector.charAt(0) === \"<\" && selector.charAt(selector.length - 1) === \">\" && selector.length >= 3) {\n                // Assume that strings that start and end with <> are HTML and skip the regex check\n                match = [null, selector, null];\n              } else {\n                match = quickExpr.exec(selector);\n              } // Verify a match, and that no context was specified for #id\n\n\n              if (match && (match[1] || !context)) {\n                // HANDLE: $(html) -> $(array)\n                if (match[1]) {\n                  context = context instanceof jQuery ? context[0] : context;\n                  doc = context ? context.ownerDocument || context : document; // If a single string is passed in and it's a single tag\n                  // just do a createElement and skip the rest\n\n                  ret = rsingleTag.exec(selector);\n\n                  if (ret) {\n                    if (jQuery.isPlainObject(context)) {\n                      selector = [document.createElement(ret[1])];\n                      jQuery.fn.attr.call(selector, context, true);\n                    } else {\n                      selector = [doc.createElement(ret[1])];\n                    }\n                  } else {\n                    ret = jQuery.buildFragment([match[1]], [doc]);\n                    selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;\n                  }\n\n                  return jQuery.merge(this, selector); // HANDLE: $(\"#id\")\n                } else {\n                  elem = document.getElementById(match[2]); // Check parentNode to catch when Blackberry 4.6 returns\n                  // nodes that are no longer in the document #6963\n\n                  if (elem && elem.parentNode) {\n                    // Handle the case where IE and Opera return items\n                    // by name instead of ID\n                    if (elem.id !== match[2]) {\n                      return rootjQuery.find(selector);\n                    } // Otherwise, we inject the element directly into the jQuery object\n\n\n                    this.length = 1;\n                    this[0] = elem;\n                  }\n\n                  this.context = document;\n                  this.selector = selector;\n                  return this;\n                } // HANDLE: $(expr, $(...))\n\n              } else if (!context || context.jquery) {\n                return (context || rootjQuery).find(selector); // HANDLE: $(expr, context)\n                // (which is just equivalent to: $(context).find(expr)\n              } else {\n                return this.constructor(context).find(selector);\n              } // HANDLE: $(function)\n              // Shortcut for document ready\n\n            } else if (jQuery.isFunction(selector)) {\n              return rootjQuery.ready(selector);\n            }\n\n            if (selector.selector !== undefined) {\n              this.selector = selector.selector;\n              this.context = selector.context;\n            }\n\n            return jQuery.makeArray(selector, this);\n          },\n          // Start with an empty selector\n          selector: \"\",\n          // The current version of jQuery being used\n          jquery: \"1.7.2\",\n          // The default length of a jQuery object is 0\n          length: 0,\n          // The number of elements contained in the matched element set\n          size: function size() {\n            return this.length;\n          },\n          toArray: function toArray() {\n            return _slice.call(this, 0);\n          },\n          // Get the Nth element in the matched element set OR\n          // Get the whole matched element set as a clean array\n          get: function get(num) {\n            return num == null ? // Return a 'clean' array\n            this.toArray() : // Return just the object\n            num < 0 ? this[this.length + num] : this[num];\n          },\n          // Take an array of elements and push it onto the stack\n          // (returning the new matched element set)\n          pushStack: function pushStack(elems, name, selector) {\n            // Build a new jQuery matched element set\n            var ret = this.constructor();\n\n            if (jQuery.isArray(elems)) {\n              push.apply(ret, elems);\n            } else {\n              jQuery.merge(ret, elems);\n            } // Add the old object onto the stack (as a reference)\n\n\n            ret.prevObject = this;\n            ret.context = this.context;\n\n            if (name === \"find\") {\n              ret.selector = this.selector + (this.selector ? \" \" : \"\") + selector;\n            } else if (name) {\n              ret.selector = this.selector + \".\" + name + \"(\" + selector + \")\";\n            } // Return the newly-formed element set\n\n\n            return ret;\n          },\n          // Execute a callback for every element in the matched set.\n          // (You can seed the arguments with an array of args, but this is\n          // only used internally.)\n          each: function each(callback, args) {\n            return jQuery.each(this, callback, args);\n          },\n          ready: function ready(fn) {\n            // Attach the listeners\n            jQuery.bindReady(); // Add the callback\n\n            readyList.add(fn);\n            return this;\n          },\n          eq: function eq(i) {\n            i = +i;\n            return i === -1 ? this.slice(i) : this.slice(i, i + 1);\n          },\n          first: function first() {\n            return this.eq(0);\n          },\n          last: function last() {\n            return this.eq(-1);\n          },\n          slice: function slice() {\n            return this.pushStack(_slice.apply(this, arguments), \"slice\", _slice.call(arguments).join(\",\"));\n          },\n          map: function map(callback) {\n            return this.pushStack(jQuery.map(this, function (elem, i) {\n              return callback.call(elem, i, elem);\n            }));\n          },\n          end: function end() {\n            return this.prevObject || this.constructor(null);\n          },\n          // For internal use only.\n          // Behaves like an Array's method, not like a jQuery method.\n          push: push,\n          sort: [].sort,\n          splice: [].splice\n        }; // Give the init function the jQuery prototype for later instantiation\n\n        jQuery.fn.init.prototype = jQuery.fn;\n\n        jQuery.extend = jQuery.fn.extend = function () {\n          var options,\n              name,\n              src,\n              copy,\n              copyIsArray,\n              clone,\n              target = arguments[0] || {},\n              i = 1,\n              length = arguments.length,\n              deep = false; // Handle a deep copy situation\n\n          if (typeof target === \"boolean\") {\n            deep = target;\n            target = arguments[1] || {}; // skip the boolean and the target\n\n            i = 2;\n          } // Handle case when target is a string or something (possible in deep copy)\n\n\n          if (typeof target !== \"object\" && !jQuery.isFunction(target)) {\n            target = {};\n          } // extend jQuery itself if only one argument is passed\n\n\n          if (length === i) {\n            target = this;\n            --i;\n          }\n\n          for (; i < length; i++) {\n            // Only deal with non-null/undefined values\n            if ((options = arguments[i]) != null) {\n              // Extend the base object\n              for (name in options) {\n                src = target[name];\n                copy = options[name]; // Prevent never-ending loop\n\n                if (target === copy) {\n                  continue;\n                } // Recurse if we're merging plain objects or arrays\n\n\n                if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n                  if (copyIsArray) {\n                    copyIsArray = false;\n                    clone = src && jQuery.isArray(src) ? src : [];\n                  } else {\n                    clone = src && jQuery.isPlainObject(src) ? src : {};\n                  } // Never move original objects, clone them\n\n\n                  target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values\n                } else if (copy !== undefined) {\n                  target[name] = copy;\n                }\n              }\n            }\n          } // Return the modified object\n\n\n          return target;\n        };\n\n        jQuery.extend({\n          noConflict: function noConflict(deep) {\n            if (window.$ === jQuery) {\n              window.$ = _$;\n            }\n\n            if (deep && window.jQuery === jQuery) {\n              window.jQuery = _jQuery;\n            }\n\n            return jQuery;\n          },\n          // Is the DOM ready to be used? Set to true once it occurs.\n          isReady: false,\n          // A counter to track how many items to wait for before\n          // the ready event fires. See #6781\n          readyWait: 1,\n          // Hold (or release) the ready event\n          holdReady: function holdReady(hold) {\n            if (hold) {\n              jQuery.readyWait++;\n            } else {\n              jQuery.ready(true);\n            }\n          },\n          // Handle when the DOM is ready\n          ready: function ready(wait) {\n            // Either a released hold or an DOMready/load event and not yet ready\n            if (wait === true && ! --jQuery.readyWait || wait !== true && !jQuery.isReady) {\n              // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n              if (!document.body) {\n                return setTimeout(jQuery.ready, 1);\n              } // Remember that the DOM is ready\n\n\n              jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be\n\n              if (wait !== true && --jQuery.readyWait > 0) {\n                return;\n              } // If there are functions bound, to execute\n\n\n              readyList.fireWith(document, [jQuery]); // Trigger any bound ready events\n\n              if (jQuery.fn.trigger) {\n                jQuery(document).trigger(\"ready\").off(\"ready\");\n              }\n            }\n          },\n          bindReady: function bindReady() {\n            if (readyList) {\n              return;\n            }\n\n            readyList = jQuery.Callbacks(\"once memory\"); // Catch cases where $(document).ready() is called after the\n            // browser event has already occurred.\n\n            if (document.readyState === \"complete\") {\n              // Handle it asynchronously to allow scripts the opportunity to delay ready\n              return setTimeout(jQuery.ready, 1);\n            } // Mozilla, Opera and webkit nightlies currently support this event\n\n\n            if (document.addEventListener) {\n              // Use the handy event callback\n              document.addEventListener(\"DOMContentLoaded\", _DOMContentLoaded2, false); // A fallback to window.onload, that will always work\n\n              window.addEventListener(\"load\", jQuery.ready, false); // If IE event model is used\n            } else if (document.attachEvent) {\n              // ensure firing before onload,\n              // maybe late but safe also for iframes\n              document.attachEvent(\"onreadystatechange\", _DOMContentLoaded2); // A fallback to window.onload, that will always work\n\n              window.attachEvent(\"onload\", jQuery.ready); // If IE and not a frame\n              // continually check to see if the document is ready\n\n              var toplevel = false;\n\n              try {\n                toplevel = window.frameElement == null;\n              } catch (e) {}\n\n              if (document.documentElement.doScroll && toplevel) {\n                doScrollCheck();\n              }\n            }\n          },\n          // See test/unit/core.js for details concerning isFunction.\n          // Since version 1.3, DOM methods and functions like alert\n          // aren't supported. They return false on IE (#2968).\n          isFunction: function isFunction(obj) {\n            return jQuery.type(obj) === \"function\";\n          },\n          isArray: Array.isArray || function (obj) {\n            return jQuery.type(obj) === \"array\";\n          },\n          isWindow: function isWindow(obj) {\n            return obj != null && obj == obj.window;\n          },\n          isNumeric: function isNumeric(obj) {\n            return !isNaN(parseFloat(obj)) && isFinite(obj);\n          },\n          type: function type(obj) {\n            return obj == null ? String(obj) : class2type[toString.call(obj)] || \"object\";\n          },\n          isPlainObject: function isPlainObject(obj) {\n            // Must be an Object.\n            // Because of IE, we also have to check the presence of the constructor property.\n            // Make sure that DOM nodes and window objects don't pass through, as well\n            if (!obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow(obj)) {\n              return false;\n            }\n\n            try {\n              // Not own constructor property must be Object\n              if (obj.constructor && !hasOwn.call(obj, \"constructor\") && !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n                return false;\n              }\n            } catch (e) {\n              // IE8,9 Will throw exceptions on certain host objects #9897\n              return false;\n            } // Own properties are enumerated firstly, so to speed up,\n            // if last one is own, then all properties are own.\n\n\n            var key;\n\n            for (key in obj) {}\n\n            return key === undefined || hasOwn.call(obj, key);\n          },\n          isEmptyObject: function isEmptyObject(obj) {\n            for (var name in obj) {\n              return false;\n            }\n\n            return true;\n          },\n          error: function error(msg) {\n            throw new Error(msg);\n          },\n          parseJSON: function parseJSON(data) {\n            if (typeof data !== \"string\" || !data) {\n              return null;\n            } // Make sure leading/trailing whitespace is removed (IE can't handle it)\n\n\n            data = jQuery.trim(data); // Attempt to parse using the native JSON parser first\n\n            if (window.JSON && window.JSON.parse) {\n              return window.JSON.parse(data);\n            } // Make sure the incoming data is actual JSON\n            // Logic borrowed from http://json.org/json2.js\n\n\n            if (rvalidchars.test(data.replace(rvalidescape, \"@\").replace(rvalidtokens, \"]\").replace(rvalidbraces, \"\"))) {\n              return new Function(\"return \" + data)();\n            }\n\n            jQuery.error(\"Invalid JSON: \" + data);\n          },\n          // Cross-browser xml parsing\n          parseXML: function parseXML(data) {\n            if (typeof data !== \"string\" || !data) {\n              return null;\n            }\n\n            var xml, tmp;\n\n            try {\n              if (window.DOMParser) {\n                // Standard\n                tmp = new DOMParser();\n                xml = tmp.parseFromString(data, \"text/xml\");\n              } else {\n                // IE\n                xml = new ActiveXObject(\"Microsoft.XMLDOM\");\n                xml.async = \"false\";\n                xml.loadXML(data);\n              }\n            } catch (e) {\n              xml = undefined;\n            }\n\n            if (!xml || !xml.documentElement || xml.getElementsByTagName(\"parsererror\").length) {\n              jQuery.error(\"Invalid XML: \" + data);\n            }\n\n            return xml;\n          },\n          noop: function noop() {},\n          // Evaluates a script in a global context\n          // Workarounds based on findings by Jim Driscoll\n          // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n          globalEval: function globalEval(data) {\n            if (data && rnotwhite.test(data)) {\n              // We use execScript on Internet Explorer\n              // We use an anonymous function so that context is window\n              // rather than jQuery in Firefox\n              (window.execScript || function (data) {\n                window[\"eval\"].call(window, data);\n              })(data);\n            }\n          },\n          // Convert dashed to camelCase; used by the css and data modules\n          // Microsoft forgot to hump their vendor prefix (#9572)\n          camelCase: function camelCase(string) {\n            return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n          },\n          nodeName: function nodeName(elem, name) {\n            return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();\n          },\n          // args is for internal usage only\n          each: function each(object, callback, args) {\n            var name,\n                i = 0,\n                length = object.length,\n                isObj = length === undefined || jQuery.isFunction(object);\n\n            if (args) {\n              if (isObj) {\n                for (name in object) {\n                  if (callback.apply(object[name], args) === false) {\n                    break;\n                  }\n                }\n              } else {\n                for (; i < length;) {\n                  if (callback.apply(object[i++], args) === false) {\n                    break;\n                  }\n                }\n              } // A special, fast, case for the most common use of each\n\n            } else {\n              if (isObj) {\n                for (name in object) {\n                  if (callback.call(object[name], name, object[name]) === false) {\n                    break;\n                  }\n                }\n              } else {\n                for (; i < length;) {\n                  if (callback.call(object[i], i, object[i++]) === false) {\n                    break;\n                  }\n                }\n              }\n            }\n\n            return object;\n          },\n          // Use native String.trim function wherever possible\n          trim: trim ? function (text) {\n            return text == null ? \"\" : trim.call(text);\n          } : // Otherwise use our own trimming functionality\n          function (text) {\n            return text == null ? \"\" : text.toString().replace(trimLeft, \"\").replace(trimRight, \"\");\n          },\n          // results is for internal usage only\n          makeArray: function makeArray(array, results) {\n            var ret = results || [];\n\n            if (array != null) {\n              // The window, strings (and functions) also have 'length'\n              // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930\n              var type = jQuery.type(array);\n\n              if (array.length == null || type === \"string\" || type === \"function\" || type === \"regexp\" || jQuery.isWindow(array)) {\n                push.call(ret, array);\n              } else {\n                jQuery.merge(ret, array);\n              }\n            }\n\n            return ret;\n          },\n          inArray: function inArray(elem, array, i) {\n            var len;\n\n            if (array) {\n              if (indexOf) {\n                return indexOf.call(array, elem, i);\n              }\n\n              len = array.length;\n              i = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n\n              for (; i < len; i++) {\n                // Skip accessing in sparse arrays\n                if (i in array && array[i] === elem) {\n                  return i;\n                }\n              }\n            }\n\n            return -1;\n          },\n          merge: function merge(first, second) {\n            var i = first.length,\n                j = 0;\n\n            if (typeof second.length === \"number\") {\n              for (var l = second.length; j < l; j++) {\n                first[i++] = second[j];\n              }\n            } else {\n              while (second[j] !== undefined) {\n                first[i++] = second[j++];\n              }\n            }\n\n            first.length = i;\n            return first;\n          },\n          grep: function grep(elems, callback, inv) {\n            var ret = [],\n                retVal;\n            inv = !!inv; // Go through the array, only saving the items\n            // that pass the validator function\n\n            for (var i = 0, length = elems.length; i < length; i++) {\n              retVal = !!callback(elems[i], i);\n\n              if (inv !== retVal) {\n                ret.push(elems[i]);\n              }\n            }\n\n            return ret;\n          },\n          // arg is for internal usage only\n          map: function map(elems, callback, arg) {\n            var value,\n                key,\n                ret = [],\n                i = 0,\n                length = elems.length,\n                // jquery objects are treated as arrays\n            isArray = elems instanceof jQuery || length !== undefined && typeof length === \"number\" && (length > 0 && elems[0] && elems[length - 1] || length === 0 || jQuery.isArray(elems)); // Go through the array, translating each of the items to their\n\n            if (isArray) {\n              for (; i < length; i++) {\n                value = callback(elems[i], i, arg);\n\n                if (value != null) {\n                  ret[ret.length] = value;\n                }\n              } // Go through every key on the object,\n\n            } else {\n              for (key in elems) {\n                value = callback(elems[key], key, arg);\n\n                if (value != null) {\n                  ret[ret.length] = value;\n                }\n              }\n            } // Flatten any nested arrays\n\n\n            return ret.concat.apply([], ret);\n          },\n          // A global GUID counter for objects\n          guid: 1,\n          // Bind a function to a context, optionally partially applying any\n          // arguments.\n          proxy: function proxy(fn, context) {\n            if (typeof context === \"string\") {\n              var tmp = fn[context];\n              context = fn;\n              fn = tmp;\n            } // Quick check to determine if target is callable, in the spec\n            // this throws a TypeError, but we will just return undefined.\n\n\n            if (!jQuery.isFunction(fn)) {\n              return undefined;\n            } // Simulated bind\n\n\n            var args = _slice.call(arguments, 2),\n                proxy = function proxy() {\n              return fn.apply(context, args.concat(_slice.call(arguments)));\n            }; // Set the guid of unique handler to the same of original handler, so it can be removed\n\n\n            proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;\n            return proxy;\n          },\n          // Mutifunctional method to get and set values to a collection\n          // The value/s can optionally be executed if it's a function\n          access: function access(elems, fn, key, value, chainable, emptyGet, pass) {\n            var exec,\n                bulk = key == null,\n                i = 0,\n                length = elems.length; // Sets many values\n\n            if (key && typeof key === \"object\") {\n              for (i in key) {\n                jQuery.access(elems, fn, i, key[i], 1, emptyGet, value);\n              }\n\n              chainable = 1; // Sets one value\n            } else if (value !== undefined) {\n              // Optionally, function values get executed if exec is true\n              exec = pass === undefined && jQuery.isFunction(value);\n\n              if (bulk) {\n                // Bulk operations only iterate when executing function values\n                if (exec) {\n                  exec = fn;\n\n                  fn = function fn(elem, key, value) {\n                    return exec.call(jQuery(elem), value);\n                  }; // Otherwise they run against the entire set\n\n                } else {\n                  fn.call(elems, value);\n                  fn = null;\n                }\n              }\n\n              if (fn) {\n                for (; i < length; i++) {\n                  fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);\n                }\n              }\n\n              chainable = 1;\n            }\n\n            return chainable ? elems : // Gets\n            bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;\n          },\n          now: function now() {\n            return new Date().getTime();\n          },\n          // Use of jQuery.browser is frowned upon.\n          // More details: http://docs.jquery.com/Utilities/jQuery.browser\n          uaMatch: function uaMatch(ua) {\n            ua = ua.toLowerCase();\n            var match = rwebkit.exec(ua) || ropera.exec(ua) || rmsie.exec(ua) || ua.indexOf(\"compatible\") < 0 && rmozilla.exec(ua) || [];\n            return {\n              browser: match[1] || \"\",\n              version: match[2] || \"0\"\n            };\n          },\n          sub: function sub() {\n            function jQuerySub(selector, context) {\n              return new jQuerySub.fn.init(selector, context);\n            }\n\n            jQuery.extend(true, jQuerySub, this);\n            jQuerySub.superclass = this;\n            jQuerySub.fn = jQuerySub.prototype = this();\n            jQuerySub.fn.constructor = jQuerySub;\n            jQuerySub.sub = this.sub;\n\n            jQuerySub.fn.init = function init(selector, context) {\n              if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {\n                context = jQuerySub(context);\n              }\n\n              return jQuery.fn.init.call(this, selector, context, rootjQuerySub);\n            };\n\n            jQuerySub.fn.init.prototype = jQuerySub.fn;\n            var rootjQuerySub = jQuerySub(document);\n            return jQuerySub;\n          },\n          browser: {}\n        }); // Populate the class2type map\n\n        jQuery.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function (i, name) {\n          class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n        });\n        browserMatch = jQuery.uaMatch(userAgent);\n\n        if (browserMatch.browser) {\n          jQuery.browser[browserMatch.browser] = true;\n          jQuery.browser.version = browserMatch.version;\n        } // Deprecated, use jQuery.browser.webkit instead\n\n\n        if (jQuery.browser.webkit) {\n          jQuery.browser.safari = true;\n        } // IE doesn't match non-breaking spaces with \\s\n\n\n        if (rnotwhite.test(\"\\xA0\")) {\n          trimLeft = /^[\\s\\xA0]+/;\n          trimRight = /[\\s\\xA0]+$/;\n        } // All jQuery objects should point back to these\n\n\n        rootjQuery = jQuery(document); // Cleanup functions for the document ready method\n\n        if (document.addEventListener) {\n          _DOMContentLoaded2 = function DOMContentLoaded() {\n            document.removeEventListener(\"DOMContentLoaded\", _DOMContentLoaded2, false);\n            jQuery.ready();\n          };\n        } else if (document.attachEvent) {\n          _DOMContentLoaded2 = function _DOMContentLoaded() {\n            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n            if (document.readyState === \"complete\") {\n              document.detachEvent(\"onreadystatechange\", _DOMContentLoaded2);\n              jQuery.ready();\n            }\n          };\n        } // The DOM ready check for Internet Explorer\n\n\n        function doScrollCheck() {\n          if (jQuery.isReady) {\n            return;\n          }\n\n          try {\n            // If IE is used, use the trick by Diego Perini\n            // http://javascript.nwbox.com/IEContentLoaded/\n            document.documentElement.doScroll(\"left\");\n          } catch (e) {\n            setTimeout(doScrollCheck, 1);\n            return;\n          } // and execute any waiting functions\n\n\n          jQuery.ready();\n        }\n\n        return jQuery;\n      }(); // String to Object flags format cache\n\n\n      var flagsCache = {}; // Convert String-formatted flags into Object-formatted ones and store in cache\n\n      function createFlags(flags) {\n        var object = flagsCache[flags] = {},\n            i,\n            length;\n        flags = flags.split(/\\s+/);\n\n        for (i = 0, length = flags.length; i < length; i++) {\n          object[flags[i]] = true;\n        }\n\n        return object;\n      }\n      /*\n       * Create a callback list using the following parameters:\n       *\n       *\tflags:\tan optional list of space-separated flags that will change how\n       *\t\t\tthe callback list behaves\n       *\n       * By default a callback list will act like an event callback list and can be\n       * \"fired\" multiple times.\n       *\n       * Possible flags:\n       *\n       *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n       *\n       *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n       *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n       *\t\t\t\t\tvalues (like a Deferred)\n       *\n       *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n       *\n       *\tstopOnFalse:\tinterrupt callings when a callback returns false\n       *\n       */\n\n\n      jQuery.Callbacks = function (flags) {\n        // Convert flags from String-formatted to Object-formatted\n        // (we check in cache first)\n        flags = flags ? flagsCache[flags] || createFlags(flags) : {};\n\n        var // Actual callback list\n        list = [],\n            // Stack of fire calls for repeatable lists\n        stack = [],\n            // Last fire value (for non-forgettable lists)\n        memory,\n            // Flag to know if list was already fired\n        _fired,\n            // Flag to know if list is currently firing\n        firing,\n            // First callback to fire (used internally by add and fireWith)\n        firingStart,\n            // End of the loop when firing\n        firingLength,\n            // Index of currently firing callback (modified by remove if needed)\n        firingIndex,\n            // Add one or several callbacks to the list\n        _add = function add(args) {\n          var i, length, elem, type, actual;\n\n          for (i = 0, length = args.length; i < length; i++) {\n            elem = args[i];\n            type = jQuery.type(elem);\n\n            if (type === \"array\") {\n              // Inspect recursively\n              _add(elem);\n            } else if (type === \"function\") {\n              // Add if not in unique mode and callback is not in\n              if (!flags.unique || !self.has(elem)) {\n                list.push(elem);\n              }\n            }\n          }\n        },\n            // Fire callbacks\n        fire = function fire(context, args) {\n          args = args || [];\n          memory = !flags.memory || [context, args];\n          _fired = true;\n          firing = true;\n          firingIndex = firingStart || 0;\n          firingStart = 0;\n          firingLength = list.length;\n\n          for (; list && firingIndex < firingLength; firingIndex++) {\n            if (list[firingIndex].apply(context, args) === false && flags.stopOnFalse) {\n              memory = true; // Mark as halted\n\n              break;\n            }\n          }\n\n          firing = false;\n\n          if (list) {\n            if (!flags.once) {\n              if (stack && stack.length) {\n                memory = stack.shift();\n                self.fireWith(memory[0], memory[1]);\n              }\n            } else if (memory === true) {\n              self.disable();\n            } else {\n              list = [];\n            }\n          }\n        },\n            // Actual Callbacks object\n        self = {\n          // Add a callback or a collection of callbacks to the list\n          add: function add() {\n            if (list) {\n              var length = list.length;\n\n              _add(arguments); // Do we need to add the callbacks to the\n              // current firing batch?\n\n\n              if (firing) {\n                firingLength = list.length; // With memory, if we're not firing then\n                // we should call right away, unless previous\n                // firing was halted (stopOnFalse)\n              } else if (memory && memory !== true) {\n                firingStart = length;\n                fire(memory[0], memory[1]);\n              }\n            }\n\n            return this;\n          },\n          // Remove a callback from the list\n          remove: function remove() {\n            if (list) {\n              var args = arguments,\n                  argIndex = 0,\n                  argLength = args.length;\n\n              for (; argIndex < argLength; argIndex++) {\n                for (var i = 0; i < list.length; i++) {\n                  if (args[argIndex] === list[i]) {\n                    // Handle firingIndex and firingLength\n                    if (firing) {\n                      if (i <= firingLength) {\n                        firingLength--;\n\n                        if (i <= firingIndex) {\n                          firingIndex--;\n                        }\n                      }\n                    } // Remove the element\n\n\n                    list.splice(i--, 1); // If we have some unicity property then\n                    // we only need to do this once\n\n                    if (flags.unique) {\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n\n            return this;\n          },\n          // Control if a given callback is in the list\n          has: function has(fn) {\n            if (list) {\n              var i = 0,\n                  length = list.length;\n\n              for (; i < length; i++) {\n                if (fn === list[i]) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          },\n          // Remove all callbacks from the list\n          empty: function empty() {\n            list = [];\n            return this;\n          },\n          // Have the list do nothing anymore\n          disable: function disable() {\n            list = stack = memory = undefined;\n            return this;\n          },\n          // Is it disabled?\n          disabled: function disabled() {\n            return !list;\n          },\n          // Lock the list in its current state\n          lock: function lock() {\n            stack = undefined;\n\n            if (!memory || memory === true) {\n              self.disable();\n            }\n\n            return this;\n          },\n          // Is it locked?\n          locked: function locked() {\n            return !stack;\n          },\n          // Call all callbacks with the given context and arguments\n          fireWith: function fireWith(context, args) {\n            if (stack) {\n              if (firing) {\n                if (!flags.once) {\n                  stack.push([context, args]);\n                }\n              } else if (!(flags.once && memory)) {\n                fire(context, args);\n              }\n            }\n\n            return this;\n          },\n          // Call all the callbacks with the given arguments\n          fire: function fire() {\n            self.fireWith(this, arguments);\n            return this;\n          },\n          // To know if the callbacks have already been called at least once\n          fired: function fired() {\n            return !!_fired;\n          }\n        };\n\n        return self;\n      };\n\n      var // Static reference to slice\n      sliceDeferred = [].slice;\n      jQuery.extend({\n        Deferred: function Deferred(func) {\n          var doneList = jQuery.Callbacks(\"once memory\"),\n              failList = jQuery.Callbacks(\"once memory\"),\n              progressList = jQuery.Callbacks(\"memory\"),\n              _state = \"pending\",\n              lists = {\n            resolve: doneList,\n            reject: failList,\n            notify: progressList\n          },\n              _promise = {\n            done: doneList.add,\n            fail: failList.add,\n            progress: progressList.add,\n            state: function state() {\n              return _state;\n            },\n            // Deprecated\n            isResolved: doneList.fired,\n            isRejected: failList.fired,\n            then: function then(doneCallbacks, failCallbacks, progressCallbacks) {\n              deferred.done(doneCallbacks).fail(failCallbacks).progress(progressCallbacks);\n              return this;\n            },\n            always: function always() {\n              deferred.done.apply(deferred, arguments).fail.apply(deferred, arguments);\n              return this;\n            },\n            pipe: function pipe(fnDone, fnFail, fnProgress) {\n              return jQuery.Deferred(function (newDefer) {\n                jQuery.each({\n                  done: [fnDone, \"resolve\"],\n                  fail: [fnFail, \"reject\"],\n                  progress: [fnProgress, \"notify\"]\n                }, function (handler, data) {\n                  var fn = data[0],\n                      action = data[1],\n                      returned;\n\n                  if (jQuery.isFunction(fn)) {\n                    deferred[handler](function () {\n                      returned = fn.apply(this, arguments);\n\n                      if (returned && jQuery.isFunction(returned.promise)) {\n                        returned.promise().then(newDefer.resolve, newDefer.reject, newDefer.notify);\n                      } else {\n                        newDefer[action + \"With\"](this === deferred ? newDefer : this, [returned]);\n                      }\n                    });\n                  } else {\n                    deferred[handler](newDefer[action]);\n                  }\n                });\n              }).promise();\n            },\n            // Get a promise for this deferred\n            // If obj is provided, the promise aspect is added to the object\n            promise: function promise(obj) {\n              if (obj == null) {\n                obj = _promise;\n              } else {\n                for (var key in _promise) {\n                  obj[key] = _promise[key];\n                }\n              }\n\n              return obj;\n            }\n          },\n              deferred = _promise.promise({}),\n              key;\n\n          for (key in lists) {\n            deferred[key] = lists[key].fire;\n            deferred[key + \"With\"] = lists[key].fireWith;\n          } // Handle state\n\n\n          deferred.done(function () {\n            _state = \"resolved\";\n          }, failList.disable, progressList.lock).fail(function () {\n            _state = \"rejected\";\n          }, doneList.disable, progressList.lock); // Call given func if any\n\n          if (func) {\n            func.call(deferred, deferred);\n          } // All done!\n\n\n          return deferred;\n        },\n        // Deferred helper\n        when: function when(firstParam) {\n          var args = sliceDeferred.call(arguments, 0),\n              i = 0,\n              length = args.length,\n              pValues = new Array(length),\n              count = length,\n              pCount = length,\n              deferred = length <= 1 && firstParam && jQuery.isFunction(firstParam.promise) ? firstParam : jQuery.Deferred(),\n              promise = deferred.promise();\n\n          function resolveFunc(i) {\n            return function (value) {\n              args[i] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;\n\n              if (! --count) {\n                deferred.resolveWith(deferred, args);\n              }\n            };\n          }\n\n          function progressFunc(i) {\n            return function (value) {\n              pValues[i] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;\n              deferred.notifyWith(promise, pValues);\n            };\n          }\n\n          if (length > 1) {\n            for (; i < length; i++) {\n              if (args[i] && args[i].promise && jQuery.isFunction(args[i].promise)) {\n                args[i].promise().then(resolveFunc(i), deferred.reject, progressFunc(i));\n              } else {\n                --count;\n              }\n            }\n\n            if (!count) {\n              deferred.resolveWith(deferred, args);\n            }\n          } else if (deferred !== firstParam) {\n            deferred.resolveWith(deferred, length ? [firstParam] : []);\n          }\n\n          return promise;\n        }\n      });\n\n      jQuery.support = function () {\n        var support,\n            all,\n            a,\n            select,\n            opt,\n            input,\n            fragment,\n            tds,\n            events,\n            eventName,\n            i,\n            isSupported,\n            div = document.createElement(\"div\"),\n            documentElement = document.documentElement; // Preliminary tests\n\n        div.setAttribute(\"className\", \"t\");\n        div.innerHTML = \"   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>\";\n        all = div.getElementsByTagName(\"*\");\n        a = div.getElementsByTagName(\"a\")[0]; // Can't get basic test support\n\n        if (!all || !all.length || !a) {\n          return {};\n        } // First batch of supports tests\n\n\n        select = document.createElement(\"select\");\n        opt = select.appendChild(document.createElement(\"option\"));\n        input = div.getElementsByTagName(\"input\")[0];\n        support = {\n          // IE strips leading whitespace when .innerHTML is used\n          leadingWhitespace: div.firstChild.nodeType === 3,\n          // Make sure that tbody elements aren't automatically inserted\n          // IE will insert them into empty tables\n          tbody: !div.getElementsByTagName(\"tbody\").length,\n          // Make sure that link elements get serialized correctly by innerHTML\n          // This requires a wrapper element in IE\n          htmlSerialize: !!div.getElementsByTagName(\"link\").length,\n          // Get the style information from getAttribute\n          // (IE uses .cssText instead)\n          style: /top/.test(a.getAttribute(\"style\")),\n          // Make sure that URLs aren't manipulated\n          // (IE normalizes it by default)\n          hrefNormalized: a.getAttribute(\"href\") === \"/a\",\n          // Make sure that element opacity exists\n          // (IE uses filter instead)\n          // Use a regex to work around a WebKit issue. See #5145\n          opacity: /^0.55/.test(a.style.opacity),\n          // Verify style float existence\n          // (IE uses styleFloat instead of cssFloat)\n          cssFloat: !!a.style.cssFloat,\n          // Make sure that if no value is specified for a checkbox\n          // that it defaults to \"on\".\n          // (WebKit defaults to \"\" instead)\n          checkOn: input.value === \"on\",\n          // Make sure that a selected-by-default option has a working selected property.\n          // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n          optSelected: opt.selected,\n          // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n          getSetAttribute: div.className !== \"t\",\n          // Tests for enctype support on a form(#6743)\n          enctype: !!document.createElement(\"form\").enctype,\n          // Makes sure cloning an html5 element does not cause problems\n          // Where outerHTML is undefined, this still works\n          html5Clone: document.createElement(\"nav\").cloneNode(true).outerHTML !== \"<:nav></:nav>\",\n          // Will be defined later\n          submitBubbles: true,\n          changeBubbles: true,\n          focusinBubbles: false,\n          deleteExpando: true,\n          noCloneEvent: true,\n          inlineBlockNeedsLayout: false,\n          shrinkWrapBlocks: false,\n          reliableMarginRight: true,\n          pixelMargin: true\n        }; // jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead\n\n        jQuery.boxModel = support.boxModel = document.compatMode === \"CSS1Compat\"; // Make sure checked status is properly cloned\n\n        input.checked = true;\n        support.noCloneChecked = input.cloneNode(true).checked; // Make sure that the options inside disabled selects aren't marked as disabled\n        // (WebKit marks them as disabled)\n\n        select.disabled = true;\n        support.optDisabled = !opt.disabled; // Test to see if it's possible to delete an expando from an element\n        // Fails in Internet Explorer\n\n        try {\n          delete div.test;\n        } catch (e) {\n          support.deleteExpando = false;\n        }\n\n        if (!div.addEventListener && div.attachEvent && div.fireEvent) {\n          div.attachEvent(\"onclick\", function () {\n            // Cloning a node shouldn't copy over any\n            // bound event handlers (IE does this)\n            support.noCloneEvent = false;\n          });\n          div.cloneNode(true).fireEvent(\"onclick\");\n        } // Check if a radio maintains its value\n        // after being appended to the DOM\n\n\n        input = document.createElement(\"input\");\n        input.value = \"t\";\n        input.setAttribute(\"type\", \"radio\");\n        support.radioValue = input.value === \"t\";\n        input.setAttribute(\"checked\", \"checked\"); // #11217 - WebKit loses check when the name is after the checked attribute\n\n        input.setAttribute(\"name\", \"t\");\n        div.appendChild(input);\n        fragment = document.createDocumentFragment();\n        fragment.appendChild(div.lastChild); // WebKit doesn't clone checked state correctly in fragments\n\n        support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked; // Check if a disconnected checkbox will retain its checked\n        // value of true after appended to the DOM (IE6/7)\n\n        support.appendChecked = input.checked;\n        fragment.removeChild(input);\n        fragment.appendChild(div); // Technique from Juriy Zaytsev\n        // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/\n        // We only care about the case where non-standard event systems\n        // are used, namely in IE. Short-circuiting here helps us to\n        // avoid an eval call (in setAttribute) which can cause CSP\n        // to go haywire. See: https://developer.mozilla.org/en/Security/CSP\n\n        if (div.attachEvent) {\n          for (i in {\n            submit: 1,\n            change: 1,\n            focusin: 1\n          }) {\n            eventName = \"on\" + i;\n            isSupported = eventName in div;\n\n            if (!isSupported) {\n              div.setAttribute(eventName, \"return;\");\n              isSupported = typeof div[eventName] === \"function\";\n            }\n\n            support[i + \"Bubbles\"] = isSupported;\n          }\n        }\n\n        fragment.removeChild(div); // Null elements to avoid leaks in IE\n\n        fragment = select = opt = div = input = null; // Run tests that need a body at doc ready\n\n        jQuery(function () {\n          var container,\n              outer,\n              inner,\n              table,\n              td,\n              offsetSupport,\n              marginDiv,\n              conMarginTop,\n              style,\n              html,\n              positionTopLeftWidthHeight,\n              paddingMarginBorderVisibility,\n              paddingMarginBorder,\n              body = document.getElementsByTagName(\"body\")[0];\n\n          if (!body) {\n            // Return for frameset docs that don't have a body\n            return;\n          }\n\n          conMarginTop = 1;\n          paddingMarginBorder = \"padding:0;margin:0;border:\";\n          positionTopLeftWidthHeight = \"position:absolute;top:0;left:0;width:1px;height:1px;\";\n          paddingMarginBorderVisibility = paddingMarginBorder + \"0;visibility:hidden;\";\n          style = \"style='\" + positionTopLeftWidthHeight + paddingMarginBorder + \"5px solid #000;\";\n          html = \"<div \" + style + \"display:block;'><div style='\" + paddingMarginBorder + \"0;display:block;overflow:hidden;'></div></div>\" + \"<table \" + style + \"' cellpadding='0' cellspacing='0'>\" + \"<tr><td></td></tr></table>\";\n          container = document.createElement(\"div\");\n          container.style.cssText = paddingMarginBorderVisibility + \"width:0;height:0;position:static;top:0;margin-top:\" + conMarginTop + \"px\";\n          body.insertBefore(container, body.firstChild); // Construct the test element\n\n          div = document.createElement(\"div\");\n          container.appendChild(div); // Check if table cells still have offsetWidth/Height when they are set\n          // to display:none and there are still other visible table cells in a\n          // table row; if so, offsetWidth/Height are not reliable for use when\n          // determining if an element has been hidden directly using\n          // display:none (it is still safe to use offsets if a parent element is\n          // hidden; don safety goggles and see bug #4512 for more information).\n          // (only IE 8 fails this test)\n\n          div.innerHTML = \"<table><tr><td style='\" + paddingMarginBorder + \"0;display:none'></td><td>t</td></tr></table>\";\n          tds = div.getElementsByTagName(\"td\");\n          isSupported = tds[0].offsetHeight === 0;\n          tds[0].style.display = \"\";\n          tds[1].style.display = \"none\"; // Check if empty table cells still have offsetWidth/Height\n          // (IE <= 8 fail this test)\n\n          support.reliableHiddenOffsets = isSupported && tds[0].offsetHeight === 0; // Check if div with explicit width and no margin-right incorrectly\n          // gets computed margin-right based on width of container. For more\n          // info see bug #3333\n          // Fails in WebKit before Feb 2011 nightlies\n          // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\n          if (window.getComputedStyle) {\n            div.innerHTML = \"\";\n            marginDiv = document.createElement(\"div\");\n            marginDiv.style.width = \"0\";\n            marginDiv.style.marginRight = \"0\";\n            div.style.width = \"2px\";\n            div.appendChild(marginDiv);\n            support.reliableMarginRight = (parseInt((window.getComputedStyle(marginDiv, null) || {\n              marginRight: 0\n            }).marginRight, 10) || 0) === 0;\n          }\n\n          if (typeof div.style.zoom !== \"undefined\") {\n            // Check if natively block-level elements act like inline-block\n            // elements when setting their display to 'inline' and giving\n            // them layout\n            // (IE < 8 does this)\n            div.innerHTML = \"\";\n            div.style.width = div.style.padding = \"1px\";\n            div.style.border = 0;\n            div.style.overflow = \"hidden\";\n            div.style.display = \"inline\";\n            div.style.zoom = 1;\n            support.inlineBlockNeedsLayout = div.offsetWidth === 3; // Check if elements with layout shrink-wrap their children\n            // (IE 6 does this)\n\n            div.style.display = \"block\";\n            div.style.overflow = \"visible\";\n            div.innerHTML = \"<div style='width:5px;'></div>\";\n            support.shrinkWrapBlocks = div.offsetWidth !== 3;\n          }\n\n          div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;\n          div.innerHTML = html;\n          outer = div.firstChild;\n          inner = outer.firstChild;\n          td = outer.nextSibling.firstChild.firstChild;\n          offsetSupport = {\n            doesNotAddBorder: inner.offsetTop !== 5,\n            doesAddBorderForTableAndCells: td.offsetTop === 5\n          };\n          inner.style.position = \"fixed\";\n          inner.style.top = \"20px\"; // safari subtracts parent border width here which is 5px\n\n          offsetSupport.fixedPosition = inner.offsetTop === 20 || inner.offsetTop === 15;\n          inner.style.position = inner.style.top = \"\";\n          outer.style.overflow = \"hidden\";\n          outer.style.position = \"relative\";\n          offsetSupport.subtractsBorderForOverflowNotVisible = inner.offsetTop === -5;\n          offsetSupport.doesNotIncludeMarginInBodyOffset = body.offsetTop !== conMarginTop;\n\n          if (window.getComputedStyle) {\n            div.style.marginTop = \"1%\";\n            support.pixelMargin = (window.getComputedStyle(div, null) || {\n              marginTop: 0\n            }).marginTop !== \"1%\";\n          }\n\n          if (typeof container.style.zoom !== \"undefined\") {\n            container.style.zoom = 1;\n          }\n\n          body.removeChild(container);\n          marginDiv = div = container = null;\n          jQuery.extend(support, offsetSupport);\n        });\n        return support;\n      }();\n\n      var rbrace = /^(?:\\{.*\\}|\\[.*\\])$/,\n          rmultiDash = /([A-Z])/g;\n      jQuery.extend({\n        cache: {},\n        // Please use with caution\n        uuid: 0,\n        // Unique for each copy of jQuery on the page\n        // Non-digits removed to match rinlinejQuery\n        expando: \"jQuery\" + (jQuery.fn.jquery + Math.random()).replace(/\\D/g, \"\"),\n        // The following elements throw uncatchable exceptions if you\n        // attempt to add expando properties to them.\n        noData: {\n          \"embed\": true,\n          // Ban all objects except for Flash (which handle expandos)\n          \"object\": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",\n          \"applet\": true\n        },\n        hasData: function hasData(elem) {\n          elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];\n          return !!elem && !isEmptyDataObject(elem);\n        },\n        data: function data(elem, name, _data, pvt\n        /* Internal Use Only */\n        ) {\n          if (!jQuery.acceptData(elem)) {\n            return;\n          }\n\n          var privateCache,\n              thisCache,\n              ret,\n              internalKey = jQuery.expando,\n              getByName = typeof name === \"string\",\n              // We have to handle DOM nodes and JS objects differently because IE6-7\n          // can't GC object references properly across the DOM-JS boundary\n          isNode = elem.nodeType,\n              // Only DOM nodes need the global jQuery cache; JS object data is\n          // attached directly to the object so GC can occur automatically\n          cache = isNode ? jQuery.cache : elem,\n              // Only defining an ID for JS objects if its cache already exists allows\n          // the code to shortcut on the same path as a DOM node with no cache\n          id = isNode ? elem[internalKey] : elem[internalKey] && internalKey,\n              isEvents = name === \"events\"; // Avoid doing any more work than we need to when trying to get data on an\n          // object that has no data at all\n\n          if ((!id || !cache[id] || !isEvents && !pvt && !cache[id].data) && getByName && _data === undefined) {\n            return;\n          }\n\n          if (!id) {\n            // Only DOM nodes need a new unique ID for each element since their data\n            // ends up in the global cache\n            if (isNode) {\n              elem[internalKey] = id = ++jQuery.uuid;\n            } else {\n              id = internalKey;\n            }\n          }\n\n          if (!cache[id]) {\n            cache[id] = {}; // Avoids exposing jQuery metadata on plain JS objects when the object\n            // is serialized using JSON.stringify\n\n            if (!isNode) {\n              cache[id].toJSON = jQuery.noop;\n            }\n          } // An object can be passed to jQuery.data instead of a key/value pair; this gets\n          // shallow copied over onto the existing cache\n\n\n          if (typeof name === \"object\" || typeof name === \"function\") {\n            if (pvt) {\n              cache[id] = jQuery.extend(cache[id], name);\n            } else {\n              cache[id].data = jQuery.extend(cache[id].data, name);\n            }\n          }\n\n          privateCache = thisCache = cache[id]; // jQuery data() is stored in a separate object inside the object's internal data\n          // cache in order to avoid key collisions between internal data and user-defined\n          // data.\n\n          if (!pvt) {\n            if (!thisCache.data) {\n              thisCache.data = {};\n            }\n\n            thisCache = thisCache.data;\n          }\n\n          if (_data !== undefined) {\n            thisCache[jQuery.camelCase(name)] = _data;\n          } // Users should not attempt to inspect the internal events object using jQuery.data,\n          // it is undocumented and subject to change. But does anyone listen? No.\n\n\n          if (isEvents && !thisCache[name]) {\n            return privateCache.events;\n          } // Check for both converted-to-camel and non-converted data property names\n          // If a data property was specified\n\n\n          if (getByName) {\n            // First Try to find as-is property data\n            ret = thisCache[name]; // Test for null|undefined property data\n\n            if (ret == null) {\n              // Try to find the camelCased property\n              ret = thisCache[jQuery.camelCase(name)];\n            }\n          } else {\n            ret = thisCache;\n          }\n\n          return ret;\n        },\n        removeData: function removeData(elem, name, pvt\n        /* Internal Use Only */\n        ) {\n          if (!jQuery.acceptData(elem)) {\n            return;\n          }\n\n          var thisCache,\n              i,\n              l,\n              // Reference to internal data cache key\n          internalKey = jQuery.expando,\n              isNode = elem.nodeType,\n              // See jQuery.data for more information\n          cache = isNode ? jQuery.cache : elem,\n              // See jQuery.data for more information\n          id = isNode ? elem[internalKey] : internalKey; // If there is already no cache entry for this object, there is no\n          // purpose in continuing\n\n          if (!cache[id]) {\n            return;\n          }\n\n          if (name) {\n            thisCache = pvt ? cache[id] : cache[id].data;\n\n            if (thisCache) {\n              // Support array or space separated string names for data keys\n              if (!jQuery.isArray(name)) {\n                // try the string as a key before any manipulation\n                if (name in thisCache) {\n                  name = [name];\n                } else {\n                  // split the camel cased version by spaces unless a key with the spaces exists\n                  name = jQuery.camelCase(name);\n\n                  if (name in thisCache) {\n                    name = [name];\n                  } else {\n                    name = name.split(\" \");\n                  }\n                }\n              }\n\n              for (i = 0, l = name.length; i < l; i++) {\n                delete thisCache[name[i]];\n              } // If there is no data left in the cache, we want to continue\n              // and let the cache object itself get destroyed\n\n\n              if (!(pvt ? isEmptyDataObject : jQuery.isEmptyObject)(thisCache)) {\n                return;\n              }\n            }\n          } // See jQuery.data for more information\n\n\n          if (!pvt) {\n            delete cache[id].data; // Don't destroy the parent cache unless the internal data object\n            // had been the only thing left in it\n\n            if (!isEmptyDataObject(cache[id])) {\n              return;\n            }\n          } // Browsers that fail expando deletion also refuse to delete expandos on\n          // the window, but it will allow it on all other JS objects; other browsers\n          // don't care\n          // Ensure that `cache` is not a window object #10080\n\n\n          if (jQuery.support.deleteExpando || !cache.setInterval) {\n            delete cache[id];\n          } else {\n            cache[id] = null;\n          } // We destroyed the cache and need to eliminate the expando on the node to avoid\n          // false lookups in the cache for entries that no longer exist\n\n\n          if (isNode) {\n            // IE does not allow us to delete expando properties from nodes,\n            // nor does it have a removeAttribute function on Document nodes;\n            // we must handle all of these cases\n            if (jQuery.support.deleteExpando) {\n              delete elem[internalKey];\n            } else if (elem.removeAttribute) {\n              elem.removeAttribute(internalKey);\n            } else {\n              elem[internalKey] = null;\n            }\n          }\n        },\n        // For internal use only.\n        _data: function _data(elem, name, data) {\n          return jQuery.data(elem, name, data, true);\n        },\n        // A method for determining if a DOM node can handle the data expando\n        acceptData: function acceptData(elem) {\n          if (elem.nodeName) {\n            var match = jQuery.noData[elem.nodeName.toLowerCase()];\n\n            if (match) {\n              return !(match === true || elem.getAttribute(\"classid\") !== match);\n            }\n          }\n\n          return true;\n        }\n      });\n      jQuery.fn.extend({\n        data: function data(key, value) {\n          var parts,\n              part,\n              attr,\n              name,\n              l,\n              elem = this[0],\n              i = 0,\n              data = null; // Gets all values\n\n          if (key === undefined) {\n            if (this.length) {\n              data = jQuery.data(elem);\n\n              if (elem.nodeType === 1 && !jQuery._data(elem, \"parsedAttrs\")) {\n                attr = elem.attributes;\n\n                for (l = attr.length; i < l; i++) {\n                  name = attr[i].name;\n\n                  if (name.indexOf(\"data-\") === 0) {\n                    name = jQuery.camelCase(name.substring(5));\n                    dataAttr(elem, name, data[name]);\n                  }\n                }\n\n                jQuery._data(elem, \"parsedAttrs\", true);\n              }\n            }\n\n            return data;\n          } // Sets multiple values\n\n\n          if (typeof key === \"object\") {\n            return this.each(function () {\n              jQuery.data(this, key);\n            });\n          }\n\n          parts = key.split(\".\", 2);\n          parts[1] = parts[1] ? \".\" + parts[1] : \"\";\n          part = parts[1] + \"!\";\n          return jQuery.access(this, function (value) {\n            if (value === undefined) {\n              data = this.triggerHandler(\"getData\" + part, [parts[0]]); // Try to fetch any internally stored data first\n\n              if (data === undefined && elem) {\n                data = jQuery.data(elem, key);\n                data = dataAttr(elem, key, data);\n              }\n\n              return data === undefined && parts[1] ? this.data(parts[0]) : data;\n            }\n\n            parts[1] = value;\n            this.each(function () {\n              var self = jQuery(this);\n              self.triggerHandler(\"setData\" + part, parts);\n              jQuery.data(this, key, value);\n              self.triggerHandler(\"changeData\" + part, parts);\n            });\n          }, null, value, arguments.length > 1, null, false);\n        },\n        removeData: function removeData(key) {\n          return this.each(function () {\n            jQuery.removeData(this, key);\n          });\n        }\n      });\n\n      function dataAttr(elem, key, data) {\n        // If nothing was found internally, try to fetch any\n        // data from the HTML5 data-* attribute\n        if (data === undefined && elem.nodeType === 1) {\n          var name = \"data-\" + key.replace(rmultiDash, \"-$1\").toLowerCase();\n          data = elem.getAttribute(name);\n\n          if (typeof data === \"string\") {\n            try {\n              data = data === \"true\" ? true : data === \"false\" ? false : data === \"null\" ? null : jQuery.isNumeric(data) ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;\n            } catch (e) {} // Make sure we set the data so it isn't changed later\n\n\n            jQuery.data(elem, key, data);\n          } else {\n            data = undefined;\n          }\n        }\n\n        return data;\n      } // checks a cache object for emptiness\n\n\n      function isEmptyDataObject(obj) {\n        for (var name in obj) {\n          // if the public data object is empty, the private is still empty\n          if (name === \"data\" && jQuery.isEmptyObject(obj[name])) {\n            continue;\n          }\n\n          if (name !== \"toJSON\") {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      function handleQueueMarkDefer(elem, type, src) {\n        var deferDataKey = type + \"defer\",\n            queueDataKey = type + \"queue\",\n            markDataKey = type + \"mark\",\n            defer = jQuery._data(elem, deferDataKey);\n\n        if (defer && (src === \"queue\" || !jQuery._data(elem, queueDataKey)) && (src === \"mark\" || !jQuery._data(elem, markDataKey))) {\n          // Give room for hard-coded callbacks to fire first\n          // and eventually mark/queue something else on the element\n          setTimeout(function () {\n            if (!jQuery._data(elem, queueDataKey) && !jQuery._data(elem, markDataKey)) {\n              jQuery.removeData(elem, deferDataKey, true);\n              defer.fire();\n            }\n          }, 0);\n        }\n      }\n\n      jQuery.extend({\n        _mark: function _mark(elem, type) {\n          if (elem) {\n            type = (type || \"fx\") + \"mark\";\n\n            jQuery._data(elem, type, (jQuery._data(elem, type) || 0) + 1);\n          }\n        },\n        _unmark: function _unmark(force, elem, type) {\n          if (force !== true) {\n            type = elem;\n            elem = force;\n            force = false;\n          }\n\n          if (elem) {\n            type = type || \"fx\";\n            var key = type + \"mark\",\n                count = force ? 0 : (jQuery._data(elem, key) || 1) - 1;\n\n            if (count) {\n              jQuery._data(elem, key, count);\n            } else {\n              jQuery.removeData(elem, key, true);\n              handleQueueMarkDefer(elem, type, \"mark\");\n            }\n          }\n        },\n        queue: function queue(elem, type, data) {\n          var q;\n\n          if (elem) {\n            type = (type || \"fx\") + \"queue\";\n            q = jQuery._data(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup\n\n            if (data) {\n              if (!q || jQuery.isArray(data)) {\n                q = jQuery._data(elem, type, jQuery.makeArray(data));\n              } else {\n                q.push(data);\n              }\n            }\n\n            return q || [];\n          }\n        },\n        dequeue: function dequeue(elem, type) {\n          type = type || \"fx\";\n          var queue = jQuery.queue(elem, type),\n              fn = queue.shift(),\n              hooks = {}; // If the fx queue is dequeued, always remove the progress sentinel\n\n          if (fn === \"inprogress\") {\n            fn = queue.shift();\n          }\n\n          if (fn) {\n            // Add a progress sentinel to prevent the fx queue from being\n            // automatically dequeued\n            if (type === \"fx\") {\n              queue.unshift(\"inprogress\");\n            }\n\n            jQuery._data(elem, type + \".run\", hooks);\n\n            fn.call(elem, function () {\n              jQuery.dequeue(elem, type);\n            }, hooks);\n          }\n\n          if (!queue.length) {\n            jQuery.removeData(elem, type + \"queue \" + type + \".run\", true);\n            handleQueueMarkDefer(elem, type, \"queue\");\n          }\n        }\n      });\n      jQuery.fn.extend({\n        queue: function queue(type, data) {\n          var setter = 2;\n\n          if (typeof type !== \"string\") {\n            data = type;\n            type = \"fx\";\n            setter--;\n          }\n\n          if (arguments.length < setter) {\n            return jQuery.queue(this[0], type);\n          }\n\n          return data === undefined ? this : this.each(function () {\n            var queue = jQuery.queue(this, type, data);\n\n            if (type === \"fx\" && queue[0] !== \"inprogress\") {\n              jQuery.dequeue(this, type);\n            }\n          });\n        },\n        dequeue: function dequeue(type) {\n          return this.each(function () {\n            jQuery.dequeue(this, type);\n          });\n        },\n        // Based off of the plugin by Clint Helfers, with permission.\n        // http://blindsignals.com/index.php/2009/07/jquery-delay/\n        delay: function delay(time, type) {\n          time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n          type = type || \"fx\";\n          return this.queue(type, function (next, hooks) {\n            var timeout = setTimeout(next, time);\n\n            hooks.stop = function () {\n              clearTimeout(timeout);\n            };\n          });\n        },\n        clearQueue: function clearQueue(type) {\n          return this.queue(type || \"fx\", []);\n        },\n        // Get a promise resolved when queues of a certain type\n        // are emptied (fx is the type by default)\n        promise: function promise(type, object) {\n          if (typeof type !== \"string\") {\n            object = type;\n            type = undefined;\n          }\n\n          type = type || \"fx\";\n          var defer = jQuery.Deferred(),\n              elements = this,\n              i = elements.length,\n              count = 1,\n              deferDataKey = type + \"defer\",\n              queueDataKey = type + \"queue\",\n              markDataKey = type + \"mark\",\n              tmp;\n\n          function resolve() {\n            if (! --count) {\n              defer.resolveWith(elements, [elements]);\n            }\n          }\n\n          while (i--) {\n            if (tmp = jQuery.data(elements[i], deferDataKey, undefined, true) || (jQuery.data(elements[i], queueDataKey, undefined, true) || jQuery.data(elements[i], markDataKey, undefined, true)) && jQuery.data(elements[i], deferDataKey, jQuery.Callbacks(\"once memory\"), true)) {\n              count++;\n              tmp.add(resolve);\n            }\n          }\n\n          resolve();\n          return defer.promise(object);\n        }\n      });\n      var rclass = /[\\n\\t\\r]/g,\n          rspace = /\\s+/,\n          rreturn = /\\r/g,\n          rtype = /^(?:button|input)$/i,\n          rfocusable = /^(?:button|input|object|select|textarea)$/i,\n          rclickable = /^a(?:rea)?$/i,\n          rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,\n          getSetAttribute = jQuery.support.getSetAttribute,\n          nodeHook,\n          boolHook,\n          fixSpecified;\n      jQuery.fn.extend({\n        attr: function attr(name, value) {\n          return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);\n        },\n        removeAttr: function removeAttr(name) {\n          return this.each(function () {\n            jQuery.removeAttr(this, name);\n          });\n        },\n        prop: function prop(name, value) {\n          return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);\n        },\n        removeProp: function removeProp(name) {\n          name = jQuery.propFix[name] || name;\n          return this.each(function () {\n            // try/catch handles cases where IE balks (such as removing a property on window)\n            try {\n              this[name] = undefined;\n              delete this[name];\n            } catch (e) {}\n          });\n        },\n        addClass: function addClass(value) {\n          var classNames, i, l, elem, setClass, c, cl;\n\n          if (jQuery.isFunction(value)) {\n            return this.each(function (j) {\n              jQuery(this).addClass(value.call(this, j, this.className));\n            });\n          }\n\n          if (value && typeof value === \"string\") {\n            classNames = value.split(rspace);\n\n            for (i = 0, l = this.length; i < l; i++) {\n              elem = this[i];\n\n              if (elem.nodeType === 1) {\n                if (!elem.className && classNames.length === 1) {\n                  elem.className = value;\n                } else {\n                  setClass = \" \" + elem.className + \" \";\n\n                  for (c = 0, cl = classNames.length; c < cl; c++) {\n                    if (!~setClass.indexOf(\" \" + classNames[c] + \" \")) {\n                      setClass += classNames[c] + \" \";\n                    }\n                  }\n\n                  elem.className = jQuery.trim(setClass);\n                }\n              }\n            }\n          }\n\n          return this;\n        },\n        removeClass: function removeClass(value) {\n          var classNames, i, l, elem, className, c, cl;\n\n          if (jQuery.isFunction(value)) {\n            return this.each(function (j) {\n              jQuery(this).removeClass(value.call(this, j, this.className));\n            });\n          }\n\n          if (value && typeof value === \"string\" || value === undefined) {\n            classNames = (value || \"\").split(rspace);\n\n            for (i = 0, l = this.length; i < l; i++) {\n              elem = this[i];\n\n              if (elem.nodeType === 1 && elem.className) {\n                if (value) {\n                  className = (\" \" + elem.className + \" \").replace(rclass, \" \");\n\n                  for (c = 0, cl = classNames.length; c < cl; c++) {\n                    className = className.replace(\" \" + classNames[c] + \" \", \" \");\n                  }\n\n                  elem.className = jQuery.trim(className);\n                } else {\n                  elem.className = \"\";\n                }\n              }\n            }\n          }\n\n          return this;\n        },\n        toggleClass: function toggleClass(value, stateVal) {\n          var type = typeof value,\n              isBool = typeof stateVal === \"boolean\";\n\n          if (jQuery.isFunction(value)) {\n            return this.each(function (i) {\n              jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);\n            });\n          }\n\n          return this.each(function () {\n            if (type === \"string\") {\n              // toggle individual class names\n              var className,\n                  i = 0,\n                  self = jQuery(this),\n                  state = stateVal,\n                  classNames = value.split(rspace);\n\n              while (className = classNames[i++]) {\n                // check each className given, space seperated list\n                state = isBool ? state : !self.hasClass(className);\n                self[state ? \"addClass\" : \"removeClass\"](className);\n              }\n            } else if (type === \"undefined\" || type === \"boolean\") {\n              if (this.className) {\n                // store className if set\n                jQuery._data(this, \"__className__\", this.className);\n              } // toggle whole className\n\n\n              this.className = this.className || value === false ? \"\" : jQuery._data(this, \"__className__\") || \"\";\n            }\n          });\n        },\n        hasClass: function hasClass(selector) {\n          var className = \" \" + selector + \" \",\n              i = 0,\n              l = this.length;\n\n          for (; i < l; i++) {\n            if (this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf(className) > -1) {\n              return true;\n            }\n          }\n\n          return false;\n        },\n        val: function val(value) {\n          var hooks,\n              ret,\n              isFunction,\n              elem = this[0];\n\n          if (!arguments.length) {\n            if (elem) {\n              hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n              if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n                return ret;\n              }\n\n              ret = elem.value;\n              return typeof ret === \"string\" ? // handle most common string cases\n              ret.replace(rreturn, \"\") : // handle cases where value is null/undef or number\n              ret == null ? \"\" : ret;\n            }\n\n            return;\n          }\n\n          isFunction = jQuery.isFunction(value);\n          return this.each(function (i) {\n            var self = jQuery(this),\n                val;\n\n            if (this.nodeType !== 1) {\n              return;\n            }\n\n            if (isFunction) {\n              val = value.call(this, i, self.val());\n            } else {\n              val = value;\n            } // Treat null/undefined as \"\"; convert numbers to string\n\n\n            if (val == null) {\n              val = \"\";\n            } else if (typeof val === \"number\") {\n              val += \"\";\n            } else if (jQuery.isArray(val)) {\n              val = jQuery.map(val, function (value) {\n                return value == null ? \"\" : value + \"\";\n              });\n            }\n\n            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting\n\n            if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n              this.value = val;\n            }\n          });\n        }\n      });\n      jQuery.extend({\n        valHooks: {\n          option: {\n            get: function get(elem) {\n              // attributes.value is undefined in Blackberry 4.7 but\n              // uses .value. See #6932\n              var val = elem.attributes.value;\n              return !val || val.specified ? elem.value : elem.text;\n            }\n          },\n          select: {\n            get: function get(elem) {\n              var value,\n                  i,\n                  max,\n                  option,\n                  index = elem.selectedIndex,\n                  values = [],\n                  options = elem.options,\n                  one = elem.type === \"select-one\"; // Nothing was selected\n\n              if (index < 0) {\n                return null;\n              } // Loop through all the selected options\n\n\n              i = one ? index : 0;\n              max = one ? index + 1 : options.length;\n\n              for (; i < max; i++) {\n                option = options[i]; // Don't return options that are disabled or in a disabled optgroup\n\n                if (option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, \"optgroup\"))) {\n                  // Get the specific value for the option\n                  value = jQuery(option).val(); // We don't need an array for one selects\n\n                  if (one) {\n                    return value;\n                  } // Multi-Selects return an array\n\n\n                  values.push(value);\n                }\n              } // Fixes Bug #2551 -- select.val() broken in IE after form.reset()\n\n\n              if (one && !values.length && options.length) {\n                return jQuery(options[index]).val();\n              }\n\n              return values;\n            },\n            set: function set(elem, value) {\n              var values = jQuery.makeArray(value);\n              jQuery(elem).find(\"option\").each(function () {\n                this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;\n              });\n\n              if (!values.length) {\n                elem.selectedIndex = -1;\n              }\n\n              return values;\n            }\n          }\n        },\n        attrFn: {\n          val: true,\n          css: true,\n          html: true,\n          text: true,\n          data: true,\n          width: true,\n          height: true,\n          offset: true\n        },\n        attr: function attr(elem, name, value, pass) {\n          var ret,\n              hooks,\n              notxml,\n              nType = elem.nodeType; // don't get/set attributes on text, comment and attribute nodes\n\n          if (!elem || nType === 3 || nType === 8 || nType === 2) {\n            return;\n          }\n\n          if (pass && name in jQuery.attrFn) {\n            return jQuery(elem)[name](value);\n          } // Fallback to prop when attributes are not supported\n\n\n          if (typeof elem.getAttribute === \"undefined\") {\n            return jQuery.prop(elem, name, value);\n          }\n\n          notxml = nType !== 1 || !jQuery.isXMLDoc(elem); // All attributes are lowercase\n          // Grab necessary hook if one is defined\n\n          if (notxml) {\n            name = name.toLowerCase();\n            hooks = jQuery.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook);\n          }\n\n          if (value !== undefined) {\n            if (value === null) {\n              jQuery.removeAttr(elem, name);\n              return;\n            } else if (hooks && \"set\" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {\n              return ret;\n            } else {\n              elem.setAttribute(name, \"\" + value);\n              return value;\n            }\n          } else if (hooks && \"get\" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {\n            return ret;\n          } else {\n            ret = elem.getAttribute(name); // Non-existent attributes return null, we normalize to undefined\n\n            return ret === null ? undefined : ret;\n          }\n        },\n        removeAttr: function removeAttr(elem, value) {\n          var propName,\n              attrNames,\n              name,\n              l,\n              isBool,\n              i = 0;\n\n          if (value && elem.nodeType === 1) {\n            attrNames = value.toLowerCase().split(rspace);\n            l = attrNames.length;\n\n            for (; i < l; i++) {\n              name = attrNames[i];\n\n              if (name) {\n                propName = jQuery.propFix[name] || name;\n                isBool = rboolean.test(name); // See #9699 for explanation of this approach (setting first, then removal)\n                // Do not do this for boolean attributes (see #10870)\n\n                if (!isBool) {\n                  jQuery.attr(elem, name, \"\");\n                }\n\n                elem.removeAttribute(getSetAttribute ? name : propName); // Set corresponding property to false for boolean attributes\n\n                if (isBool && propName in elem) {\n                  elem[propName] = false;\n                }\n              }\n            }\n          }\n        },\n        attrHooks: {\n          type: {\n            set: function set(elem, value) {\n              // We can't allow the type property to be changed (since it causes problems in IE)\n              if (rtype.test(elem.nodeName) && elem.parentNode) {\n                jQuery.error(\"type property can't be changed\");\n              } else if (!jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\")) {\n                // Setting the type on a radio button after the value resets the value in IE6-9\n                // Reset value to it's default in case type is set after value\n                // This is for element creation\n                var val = elem.value;\n                elem.setAttribute(\"type\", value);\n\n                if (val) {\n                  elem.value = val;\n                }\n\n                return value;\n              }\n            }\n          },\n          // Use the value property for back compat\n          // Use the nodeHook for button elements in IE6/7 (#1954)\n          value: {\n            get: function get(elem, name) {\n              if (nodeHook && jQuery.nodeName(elem, \"button\")) {\n                return nodeHook.get(elem, name);\n              }\n\n              return name in elem ? elem.value : null;\n            },\n            set: function set(elem, value, name) {\n              if (nodeHook && jQuery.nodeName(elem, \"button\")) {\n                return nodeHook.set(elem, value, name);\n              } // Does not return so that setAttribute is also used\n\n\n              elem.value = value;\n            }\n          }\n        },\n        propFix: {\n          tabindex: \"tabIndex\",\n          readonly: \"readOnly\",\n          \"for\": \"htmlFor\",\n          \"class\": \"className\",\n          maxlength: \"maxLength\",\n          cellspacing: \"cellSpacing\",\n          cellpadding: \"cellPadding\",\n          rowspan: \"rowSpan\",\n          colspan: \"colSpan\",\n          usemap: \"useMap\",\n          frameborder: \"frameBorder\",\n          contenteditable: \"contentEditable\"\n        },\n        prop: function prop(elem, name, value) {\n          var ret,\n              hooks,\n              notxml,\n              nType = elem.nodeType; // don't get/set properties on text, comment and attribute nodes\n\n          if (!elem || nType === 3 || nType === 8 || nType === 2) {\n            return;\n          }\n\n          notxml = nType !== 1 || !jQuery.isXMLDoc(elem);\n\n          if (notxml) {\n            // Fix name and attach hooks\n            name = jQuery.propFix[name] || name;\n            hooks = jQuery.propHooks[name];\n          }\n\n          if (value !== undefined) {\n            if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n              return ret;\n            } else {\n              return elem[name] = value;\n            }\n          } else {\n            if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n              return ret;\n            } else {\n              return elem[name];\n            }\n          }\n        },\n        propHooks: {\n          tabIndex: {\n            get: function get(elem) {\n              // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n              // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n              var attributeNode = elem.getAttributeNode(\"tabindex\");\n              return attributeNode && attributeNode.specified ? parseInt(attributeNode.value, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : undefined;\n            }\n          }\n        }\n      }); // Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)\n\n      jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex; // Hook for boolean attributes\n\n      boolHook = {\n        get: function get(elem, name) {\n          // Align boolean attributes with corresponding properties\n          // Fall back to attribute presence where some booleans are not supported\n          var attrNode,\n              property = jQuery.prop(elem, name);\n          return property === true || typeof property !== \"boolean\" && (attrNode = elem.getAttributeNode(name)) && attrNode.nodeValue !== false ? name.toLowerCase() : undefined;\n        },\n        set: function set(elem, value, name) {\n          var propName;\n\n          if (value === false) {\n            // Remove boolean attributes when set to false\n            jQuery.removeAttr(elem, name);\n          } else {\n            // value is true since we know at this point it's type boolean and not false\n            // Set boolean attributes to the same name and set the DOM property\n            propName = jQuery.propFix[name] || name;\n\n            if (propName in elem) {\n              // Only set the IDL specifically if it already exists on the element\n              elem[propName] = true;\n            }\n\n            elem.setAttribute(name, name.toLowerCase());\n          }\n\n          return name;\n        }\n      }; // IE6/7 do not support getting/setting some attributes with get/setAttribute\n\n      if (!getSetAttribute) {\n        fixSpecified = {\n          name: true,\n          id: true,\n          coords: true\n        }; // Use this for any attribute in IE6/7\n        // This fixes almost every IE6/7 issue\n\n        nodeHook = jQuery.valHooks.button = {\n          get: function get(elem, name) {\n            var ret;\n            ret = elem.getAttributeNode(name);\n            return ret && (fixSpecified[name] ? ret.nodeValue !== \"\" : ret.specified) ? ret.nodeValue : undefined;\n          },\n          set: function set(elem, value, name) {\n            // Set the existing or create a new attribute node\n            var ret = elem.getAttributeNode(name);\n\n            if (!ret) {\n              ret = document.createAttribute(name);\n              elem.setAttributeNode(ret);\n            }\n\n            return ret.nodeValue = value + \"\";\n          }\n        }; // Apply the nodeHook to tabindex\n\n        jQuery.attrHooks.tabindex.set = nodeHook.set; // Set width and height to auto instead of 0 on empty string( Bug #8150 )\n        // This is for removals\n\n        jQuery.each([\"width\", \"height\"], function (i, name) {\n          jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {\n            set: function set(elem, value) {\n              if (value === \"\") {\n                elem.setAttribute(name, \"auto\");\n                return value;\n              }\n            }\n          });\n        }); // Set contenteditable to false on removals(#10429)\n        // Setting to empty string throws an error as an invalid value\n\n        jQuery.attrHooks.contenteditable = {\n          get: nodeHook.get,\n          set: function set(elem, value, name) {\n            if (value === \"\") {\n              value = \"false\";\n            }\n\n            nodeHook.set(elem, value, name);\n          }\n        };\n      } // Some attributes require a special call on IE\n\n\n      if (!jQuery.support.hrefNormalized) {\n        jQuery.each([\"href\", \"src\", \"width\", \"height\"], function (i, name) {\n          jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {\n            get: function get(elem) {\n              var ret = elem.getAttribute(name, 2);\n              return ret === null ? undefined : ret;\n            }\n          });\n        });\n      }\n\n      if (!jQuery.support.style) {\n        jQuery.attrHooks.style = {\n          get: function get(elem) {\n            // Return undefined in the case of empty string\n            // Normalize to lowercase since IE uppercases css property names\n            return elem.style.cssText.toLowerCase() || undefined;\n          },\n          set: function set(elem, value) {\n            return elem.style.cssText = \"\" + value;\n          }\n        };\n      } // Safari mis-reports the default selected property of an option\n      // Accessing the parent's selectedIndex property fixes it\n\n\n      if (!jQuery.support.optSelected) {\n        jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {\n          get: function get(elem) {\n            var parent = elem.parentNode;\n\n            if (parent) {\n              parent.selectedIndex; // Make sure that it also works with optgroups, see #5701\n\n              if (parent.parentNode) {\n                parent.parentNode.selectedIndex;\n              }\n            }\n\n            return null;\n          }\n        });\n      } // IE6/7 call enctype encoding\n\n\n      if (!jQuery.support.enctype) {\n        jQuery.propFix.enctype = \"encoding\";\n      } // Radios and checkboxes getter/setter\n\n\n      if (!jQuery.support.checkOn) {\n        jQuery.each([\"radio\", \"checkbox\"], function () {\n          jQuery.valHooks[this] = {\n            get: function get(elem) {\n              // Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified\n              return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n            }\n          };\n        });\n      }\n\n      jQuery.each([\"radio\", \"checkbox\"], function () {\n        jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {\n          set: function set(elem, value) {\n            if (jQuery.isArray(value)) {\n              return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;\n            }\n          }\n        });\n      });\n\n      var rformElems = /^(?:textarea|input|select)$/i,\n          rtypenamespace = /^([^\\.]*)?(?:\\.(.+))?$/,\n          rhoverHack = /(?:^|\\s)hover(\\.\\S+)?\\b/,\n          rkeyEvent = /^key/,\n          rmouseEvent = /^(?:mouse|contextmenu)|click/,\n          rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n          rquickIs = /^(\\w*)(?:#([\\w\\-]+))?(?:\\.([\\w\\-]+))?$/,\n          quickParse = function quickParse(selector) {\n        var quick = rquickIs.exec(selector);\n\n        if (quick) {\n          //   0  1    2   3\n          // [ _, tag, id, class ]\n          quick[1] = (quick[1] || \"\").toLowerCase();\n          quick[3] = quick[3] && new RegExp(\"(?:^|\\\\s)\" + quick[3] + \"(?:\\\\s|$)\");\n        }\n\n        return quick;\n      },\n          quickIs = function quickIs(elem, m) {\n        var attrs = elem.attributes || {};\n        return (!m[1] || elem.nodeName.toLowerCase() === m[1]) && (!m[2] || (attrs.id || {}).value === m[2]) && (!m[3] || m[3].test((attrs[\"class\"] || {}).value));\n      },\n          hoverHack = function hoverHack(events) {\n        return jQuery.event.special.hover ? events : events.replace(rhoverHack, \"mouseenter$1 mouseleave$1\");\n      };\n      /*\n       * Helper functions for managing events -- not part of the public interface.\n       * Props to Dean Edwards' addEvent library for many of the ideas.\n       */\n\n\n      jQuery.event = {\n        add: function add(elem, types, handler, data, selector) {\n          var elemData, _eventHandle, events, t, tns, type, namespaces, handleObj, handleObjIn, quick, handlers, special; // Don't attach events to noData or text/comment nodes (allow plain objects tho)\n\n\n          if (elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data(elem))) {\n            return;\n          } // Caller can pass in an object of custom data in lieu of the handler\n\n\n          if (handler.handler) {\n            handleObjIn = handler;\n            handler = handleObjIn.handler;\n            selector = handleObjIn.selector;\n          } // Make sure that the handler has a unique ID, used to find/remove it later\n\n\n          if (!handler.guid) {\n            handler.guid = jQuery.guid++;\n          } // Init the element's event structure and main handler, if this is the first\n\n\n          events = elemData.events;\n\n          if (!events) {\n            elemData.events = events = {};\n          }\n\n          _eventHandle = elemData.handle;\n\n          if (!_eventHandle) {\n            elemData.handle = _eventHandle = function eventHandle(e) {\n              // Discard the second event of a jQuery.event.trigger() and\n              // when an event is called after a page has unloaded\n              return typeof jQuery !== \"undefined\" && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(_eventHandle.elem, arguments) : undefined;\n            }; // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\n\n            _eventHandle.elem = elem;\n          } // Handle multiple events separated by a space\n          // jQuery(...).bind(\"mouseover mouseout\", fn);\n\n\n          types = jQuery.trim(hoverHack(types)).split(\" \");\n\n          for (t = 0; t < types.length; t++) {\n            tns = rtypenamespace.exec(types[t]) || [];\n            type = tns[1];\n            namespaces = (tns[2] || \"\").split(\".\").sort(); // If event changes its type, use the special event handlers for the changed type\n\n            special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type\n\n            type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type\n\n            special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers\n\n            handleObj = jQuery.extend({\n              type: type,\n              origType: tns[1],\n              data: data,\n              handler: handler,\n              guid: handler.guid,\n              selector: selector,\n              quick: selector && quickParse(selector),\n              namespace: namespaces.join(\".\")\n            }, handleObjIn); // Init the event handler queue if we're the first\n\n            handlers = events[type];\n\n            if (!handlers) {\n              handlers = events[type] = [];\n              handlers.delegateCount = 0; // Only use addEventListener/attachEvent if the special events handler returns false\n\n              if (!special.setup || special.setup.call(elem, data, namespaces, _eventHandle) === false) {\n                // Bind the global event handler to the element\n                if (elem.addEventListener) {\n                  elem.addEventListener(type, _eventHandle, false);\n                } else if (elem.attachEvent) {\n                  elem.attachEvent(\"on\" + type, _eventHandle);\n                }\n              }\n            }\n\n            if (special.add) {\n              special.add.call(elem, handleObj);\n\n              if (!handleObj.handler.guid) {\n                handleObj.handler.guid = handler.guid;\n              }\n            } // Add to the element's handler list, delegates in front\n\n\n            if (selector) {\n              handlers.splice(handlers.delegateCount++, 0, handleObj);\n            } else {\n              handlers.push(handleObj);\n            } // Keep track of which events have ever been used, for event optimization\n\n\n            jQuery.event.global[type] = true;\n          } // Nullify elem to prevent memory leaks in IE\n\n\n          elem = null;\n        },\n        global: {},\n        // Detach an event or set of events from an element\n        remove: function remove(elem, types, handler, selector, mappedTypes) {\n          var elemData = jQuery.hasData(elem) && jQuery._data(elem),\n              t,\n              tns,\n              type,\n              origType,\n              namespaces,\n              origCount,\n              j,\n              events,\n              special,\n              handle,\n              eventType,\n              handleObj;\n\n          if (!elemData || !(events = elemData.events)) {\n            return;\n          } // Once for each type.namespace in types; type may be omitted\n\n\n          types = jQuery.trim(hoverHack(types || \"\")).split(\" \");\n\n          for (t = 0; t < types.length; t++) {\n            tns = rtypenamespace.exec(types[t]) || [];\n            type = origType = tns[1];\n            namespaces = tns[2]; // Unbind all events (on this namespace, if provided) for the element\n\n            if (!type) {\n              for (type in events) {\n                jQuery.event.remove(elem, type + types[t], handler, selector, true);\n              }\n\n              continue;\n            }\n\n            special = jQuery.event.special[type] || {};\n            type = (selector ? special.delegateType : special.bindType) || type;\n            eventType = events[type] || [];\n            origCount = eventType.length;\n            namespaces = namespaces ? new RegExp(\"(^|\\\\.)\" + namespaces.split(\".\").sort().join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\") : null; // Remove matching events\n\n            for (j = 0; j < eventType.length; j++) {\n              handleObj = eventType[j];\n\n              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!namespaces || namespaces.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n                eventType.splice(j--, 1);\n\n                if (handleObj.selector) {\n                  eventType.delegateCount--;\n                }\n\n                if (special.remove) {\n                  special.remove.call(elem, handleObj);\n                }\n              }\n            } // Remove generic event handler if we removed something and no more handlers exist\n            // (avoids potential for endless recursion during removal of special event handlers)\n\n\n            if (eventType.length === 0 && origCount !== eventType.length) {\n              if (!special.teardown || special.teardown.call(elem, namespaces) === false) {\n                jQuery.removeEvent(elem, type, elemData.handle);\n              }\n\n              delete events[type];\n            }\n          } // Remove the expando if it's no longer used\n\n\n          if (jQuery.isEmptyObject(events)) {\n            handle = elemData.handle;\n\n            if (handle) {\n              handle.elem = null;\n            } // removeData also checks for emptiness and clears the expando if empty\n            // so use it instead of delete\n\n\n            jQuery.removeData(elem, [\"events\", \"handle\"], true);\n          }\n        },\n        // Events that are safe to short-circuit if no handlers are attached.\n        // Native DOM events should not be added, they may have inline handlers.\n        customEvent: {\n          \"getData\": true,\n          \"setData\": true,\n          \"changeData\": true\n        },\n        trigger: function trigger(event, data, elem, onlyHandlers) {\n          // Don't do events on text and comment nodes\n          if (elem && (elem.nodeType === 3 || elem.nodeType === 8)) {\n            return;\n          } // Event object or event type\n\n\n          var type = event.type || event,\n              namespaces = [],\n              cache,\n              exclusive,\n              i,\n              cur,\n              old,\n              ontype,\n              special,\n              handle,\n              eventPath,\n              bubbleType; // focus/blur morphs to focusin/out; ensure we're not firing them right now\n\n          if (rfocusMorph.test(type + jQuery.event.triggered)) {\n            return;\n          }\n\n          if (type.indexOf(\"!\") >= 0) {\n            // Exclusive events trigger only for the exact event (no namespaces)\n            type = type.slice(0, -1);\n            exclusive = true;\n          }\n\n          if (type.indexOf(\".\") >= 0) {\n            // Namespaced trigger; create a regexp to match event type in handle()\n            namespaces = type.split(\".\");\n            type = namespaces.shift();\n            namespaces.sort();\n          }\n\n          if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) {\n            // No jQuery handlers for this event type, and it can't have inline handlers\n            return;\n          } // Caller can pass in an Event, Object, or just an event type string\n\n\n          event = typeof event === \"object\" ? // jQuery.Event object\n          event[jQuery.expando] ? event : // Object literal\n          new jQuery.Event(type, event) : // Just the event type (string)\n          new jQuery.Event(type);\n          event.type = type;\n          event.isTrigger = true;\n          event.exclusive = exclusive;\n          event.namespace = namespaces.join(\".\");\n          event.namespace_re = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\") : null;\n          ontype = type.indexOf(\":\") < 0 ? \"on\" + type : \"\"; // Handle a global trigger\n\n          if (!elem) {\n            // TODO: Stop taunting the data cache; remove global events and always attach to document\n            cache = jQuery.cache;\n\n            for (i in cache) {\n              if (cache[i].events && cache[i].events[type]) {\n                jQuery.event.trigger(event, data, cache[i].handle.elem, true);\n              }\n            }\n\n            return;\n          } // Clean up the event in case it is being reused\n\n\n          event.result = undefined;\n\n          if (!event.target) {\n            event.target = elem;\n          } // Clone any incoming data and prepend the event, creating the handler arg list\n\n\n          data = data != null ? jQuery.makeArray(data) : [];\n          data.unshift(event); // Allow special events to draw outside the lines\n\n          special = jQuery.event.special[type] || {};\n\n          if (special.trigger && special.trigger.apply(elem, data) === false) {\n            return;\n          } // Determine event propagation path in advance, per W3C events spec (#9951)\n          // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\n\n          eventPath = [[elem, special.bindType || type]];\n\n          if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\n            bubbleType = special.delegateType || type;\n            cur = rfocusMorph.test(bubbleType + type) ? elem : elem.parentNode;\n            old = null;\n\n            for (; cur; cur = cur.parentNode) {\n              eventPath.push([cur, bubbleType]);\n              old = cur;\n            } // Only add window if we got to document (e.g., not plain obj or detached DOM)\n\n\n            if (old && old === elem.ownerDocument) {\n              eventPath.push([old.defaultView || old.parentWindow || window, bubbleType]);\n            }\n          } // Fire handlers on the event path\n\n\n          for (i = 0; i < eventPath.length && !event.isPropagationStopped(); i++) {\n            cur = eventPath[i][0];\n            event.type = eventPath[i][1];\n            handle = (jQuery._data(cur, \"events\") || {})[event.type] && jQuery._data(cur, \"handle\");\n\n            if (handle) {\n              handle.apply(cur, data);\n            } // Note that this is a bare JS function and not a jQuery handler\n\n\n            handle = ontype && cur[ontype];\n\n            if (handle && jQuery.acceptData(cur) && handle.apply(cur, data) === false) {\n              event.preventDefault();\n            }\n          }\n\n          event.type = type; // If nobody prevented the default action, do it now\n\n          if (!onlyHandlers && !event.isDefaultPrevented()) {\n            if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) && !(type === \"click\" && jQuery.nodeName(elem, \"a\")) && jQuery.acceptData(elem)) {\n              // Call a native DOM method on the target with the same name name as the event.\n              // Can't use an .isFunction() check here because IE6/7 fails that test.\n              // Don't do default actions on window, that's where global variables be (#6170)\n              // IE<9 dies on focus/blur to hidden element (#1486)\n              if (ontype && elem[type] && (type !== \"focus\" && type !== \"blur\" || event.target.offsetWidth !== 0) && !jQuery.isWindow(elem)) {\n                // Don't re-trigger an onFOO event when we call its FOO() method\n                old = elem[ontype];\n\n                if (old) {\n                  elem[ontype] = null;\n                } // Prevent re-triggering of the same event, since we already bubbled it above\n\n\n                jQuery.event.triggered = type;\n                elem[type]();\n                jQuery.event.triggered = undefined;\n\n                if (old) {\n                  elem[ontype] = old;\n                }\n              }\n            }\n          }\n\n          return event.result;\n        },\n        dispatch: function dispatch(event) {\n          // Make a writable jQuery.Event from the native event object\n          event = jQuery.event.fix(event || window.event);\n          var handlers = (jQuery._data(this, \"events\") || {})[event.type] || [],\n              delegateCount = handlers.delegateCount,\n              args = [].slice.call(arguments, 0),\n              run_all = !event.exclusive && !event.namespace,\n              special = jQuery.event.special[event.type] || {},\n              handlerQueue = [],\n              i,\n              j,\n              cur,\n              jqcur,\n              ret,\n              selMatch,\n              matched,\n              matches,\n              handleObj,\n              sel,\n              related; // Use the fix-ed jQuery.Event rather than the (read-only) native event\n\n          args[0] = event;\n          event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired\n\n          if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n            return;\n          } // Determine handlers that should run if there are delegated events\n          // Avoid non-left-click bubbling in Firefox (#3861)\n\n\n          if (delegateCount && !(event.button && event.type === \"click\")) {\n            // Pregenerate a single jQuery object for reuse with .is()\n            jqcur = jQuery(this);\n            jqcur.context = this.ownerDocument || this;\n\n            for (cur = event.target; cur != this; cur = cur.parentNode || this) {\n              // Don't process events on disabled elements (#6911, #8165)\n              if (cur.disabled !== true) {\n                selMatch = {};\n                matches = [];\n                jqcur[0] = cur;\n\n                for (i = 0; i < delegateCount; i++) {\n                  handleObj = handlers[i];\n                  sel = handleObj.selector;\n\n                  if (selMatch[sel] === undefined) {\n                    selMatch[sel] = handleObj.quick ? quickIs(cur, handleObj.quick) : jqcur.is(sel);\n                  }\n\n                  if (selMatch[sel]) {\n                    matches.push(handleObj);\n                  }\n                }\n\n                if (matches.length) {\n                  handlerQueue.push({\n                    elem: cur,\n                    matches: matches\n                  });\n                }\n              }\n            }\n          } // Add the remaining (directly-bound) handlers\n\n\n          if (handlers.length > delegateCount) {\n            handlerQueue.push({\n              elem: this,\n              matches: handlers.slice(delegateCount)\n            });\n          } // Run delegates first; they may want to stop propagation beneath us\n\n\n          for (i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++) {\n            matched = handlerQueue[i];\n            event.currentTarget = matched.elem;\n\n            for (j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++) {\n              handleObj = matched.matches[j]; // Triggered event must either 1) be non-exclusive and have no namespace, or\n              // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\n              if (run_all || !event.namespace && !handleObj.namespace || event.namespace_re && event.namespace_re.test(handleObj.namespace)) {\n                event.data = handleObj.data;\n                event.handleObj = handleObj;\n                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n                if (ret !== undefined) {\n                  event.result = ret;\n\n                  if (ret === false) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                  }\n                }\n              }\n            }\n          } // Call the postDispatch hook for the mapped type\n\n\n          if (special.postDispatch) {\n            special.postDispatch.call(this, event);\n          }\n\n          return event.result;\n        },\n        // Includes some event props shared by KeyEvent and MouseEvent\n        // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***\n        props: \"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n        fixHooks: {},\n        keyHooks: {\n          props: \"char charCode key keyCode\".split(\" \"),\n          filter: function filter(event, original) {\n            // Add which for key events\n            if (event.which == null) {\n              event.which = original.charCode != null ? original.charCode : original.keyCode;\n            }\n\n            return event;\n          }\n        },\n        mouseHooks: {\n          props: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n          filter: function filter(event, original) {\n            var eventDoc,\n                doc,\n                body,\n                button = original.button,\n                fromElement = original.fromElement; // Calculate pageX/Y if missing and clientX/Y available\n\n            if (event.pageX == null && original.clientX != null) {\n              eventDoc = event.target.ownerDocument || document;\n              doc = eventDoc.documentElement;\n              body = eventDoc.body;\n              event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n              event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n            } // Add relatedTarget, if necessary\n\n\n            if (!event.relatedTarget && fromElement) {\n              event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n            } // Add which for click: 1 === left; 2 === middle; 3 === right\n            // Note: button is not normalized, so don't use it\n\n\n            if (!event.which && button !== undefined) {\n              event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n            }\n\n            return event;\n          }\n        },\n        fix: function fix(event) {\n          if (event[jQuery.expando]) {\n            return event;\n          } // Create a writable copy of the event object and normalize some properties\n\n\n          var i,\n              prop,\n              originalEvent = event,\n              fixHook = jQuery.event.fixHooks[event.type] || {},\n              copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;\n          event = jQuery.Event(originalEvent);\n\n          for (i = copy.length; i;) {\n            prop = copy[--i];\n            event[prop] = originalEvent[prop];\n          } // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)\n\n\n          if (!event.target) {\n            event.target = originalEvent.srcElement || document;\n          } // Target should not be a text node (#504, Safari)\n\n\n          if (event.target.nodeType === 3) {\n            event.target = event.target.parentNode;\n          } // For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)\n\n\n          if (event.metaKey === undefined) {\n            event.metaKey = event.ctrlKey;\n          }\n\n          return fixHook.filter ? fixHook.filter(event, originalEvent) : event;\n        },\n        special: {\n          ready: {\n            // Make sure the ready event is setup\n            setup: jQuery.bindReady\n          },\n          load: {\n            // Prevent triggered image.load events from bubbling to window.load\n            noBubble: true\n          },\n          focus: {\n            delegateType: \"focusin\"\n          },\n          blur: {\n            delegateType: \"focusout\"\n          },\n          beforeunload: {\n            setup: function setup(data, namespaces, eventHandle) {\n              // We only want to do this special case on windows\n              if (jQuery.isWindow(this)) {\n                this.onbeforeunload = eventHandle;\n              }\n            },\n            teardown: function teardown(namespaces, eventHandle) {\n              if (this.onbeforeunload === eventHandle) {\n                this.onbeforeunload = null;\n              }\n            }\n          }\n        },\n        simulate: function simulate(type, elem, event, bubble) {\n          // Piggyback on a donor event to simulate a different one.\n          // Fake originalEvent to avoid donor's stopPropagation, but if the\n          // simulated event prevents default then we do the same on the donor.\n          var e = jQuery.extend(new jQuery.Event(), event, {\n            type: type,\n            isSimulated: true,\n            originalEvent: {}\n          });\n\n          if (bubble) {\n            jQuery.event.trigger(e, null, elem);\n          } else {\n            jQuery.event.dispatch.call(elem, e);\n          }\n\n          if (e.isDefaultPrevented()) {\n            event.preventDefault();\n          }\n        }\n      }; // Some plugins are using, but it's undocumented/deprecated and will be removed.\n      // The 1.7 special event interface should provide all the hooks needed now.\n\n      jQuery.event.handle = jQuery.event.dispatch;\n      jQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {\n        if (elem.removeEventListener) {\n          elem.removeEventListener(type, handle, false);\n        }\n      } : function (elem, type, handle) {\n        if (elem.detachEvent) {\n          elem.detachEvent(\"on\" + type, handle);\n        }\n      };\n\n      jQuery.Event = function (src, props) {\n        // Allow instantiation without the 'new' keyword\n        if (!(this instanceof jQuery.Event)) {\n          return new jQuery.Event(src, props);\n        } // Event object\n\n\n        if (src && src.type) {\n          this.originalEvent = src;\n          this.type = src.type; // Events bubbling up the document may have been marked as prevented\n          // by a handler lower down the tree; reflect the correct value.\n\n          this.isDefaultPrevented = src.defaultPrevented || src.returnValue === false || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse; // Event type\n        } else {\n          this.type = src;\n        } // Put explicitly provided properties onto the event object\n\n\n        if (props) {\n          jQuery.extend(this, props);\n        } // Create a timestamp if incoming event doesn't have one\n\n\n        this.timeStamp = src && src.timeStamp || jQuery.now(); // Mark it as fixed\n\n        this[jQuery.expando] = true;\n      };\n\n      function returnFalse() {\n        return false;\n      }\n\n      function returnTrue() {\n        return true;\n      } // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n      // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n      jQuery.Event.prototype = {\n        preventDefault: function preventDefault() {\n          this.isDefaultPrevented = returnTrue;\n          var e = this.originalEvent;\n\n          if (!e) {\n            return;\n          } // if preventDefault exists run it on the original event\n\n\n          if (e.preventDefault) {\n            e.preventDefault(); // otherwise set the returnValue property of the original event to false (IE)\n          } else {\n            e.returnValue = false;\n          }\n        },\n        stopPropagation: function stopPropagation() {\n          this.isPropagationStopped = returnTrue;\n          var e = this.originalEvent;\n\n          if (!e) {\n            return;\n          } // if stopPropagation exists run it on the original event\n\n\n          if (e.stopPropagation) {\n            e.stopPropagation();\n          } // otherwise set the cancelBubble property of the original event to true (IE)\n\n\n          e.cancelBubble = true;\n        },\n        stopImmediatePropagation: function stopImmediatePropagation() {\n          this.isImmediatePropagationStopped = returnTrue;\n          this.stopPropagation();\n        },\n        isDefaultPrevented: returnFalse,\n        isPropagationStopped: returnFalse,\n        isImmediatePropagationStopped: returnFalse\n      }; // Create mouseenter/leave events using mouseover/out and event-time checks\n\n      jQuery.each({\n        mouseenter: \"mouseover\",\n        mouseleave: \"mouseout\"\n      }, function (orig, fix) {\n        jQuery.event.special[orig] = {\n          delegateType: fix,\n          bindType: fix,\n          handle: function handle(event) {\n            var target = this,\n                related = event.relatedTarget,\n                handleObj = event.handleObj,\n                selector = handleObj.selector,\n                ret; // For mousenter/leave call the handler if related is outside the target.\n            // NB: No relatedTarget if the mouse left/entered the browser window\n\n            if (!related || related !== target && !jQuery.contains(target, related)) {\n              event.type = handleObj.origType;\n              ret = handleObj.handler.apply(this, arguments);\n              event.type = fix;\n            }\n\n            return ret;\n          }\n        };\n      }); // IE submit delegation\n\n      if (!jQuery.support.submitBubbles) {\n        jQuery.event.special.submit = {\n          setup: function setup() {\n            // Only need this for delegated form submit events\n            if (jQuery.nodeName(this, \"form\")) {\n              return false;\n            } // Lazy-add a submit handler when a descendant form may potentially be submitted\n\n\n            jQuery.event.add(this, \"click._submit keypress._submit\", function (e) {\n              // Node name check avoids a VML-related crash in IE (#9807)\n              var elem = e.target,\n                  form = jQuery.nodeName(elem, \"input\") || jQuery.nodeName(elem, \"button\") ? elem.form : undefined;\n\n              if (form && !form._submit_attached) {\n                jQuery.event.add(form, \"submit._submit\", function (event) {\n                  event._submit_bubble = true;\n                });\n                form._submit_attached = true;\n              }\n            }); // return undefined since we don't need an event listener\n          },\n          postDispatch: function postDispatch(event) {\n            // If form was submitted by the user, bubble the event up the tree\n            if (event._submit_bubble) {\n              delete event._submit_bubble;\n\n              if (this.parentNode && !event.isTrigger) {\n                jQuery.event.simulate(\"submit\", this.parentNode, event, true);\n              }\n            }\n          },\n          teardown: function teardown() {\n            // Only need this for delegated form submit events\n            if (jQuery.nodeName(this, \"form\")) {\n              return false;\n            } // Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\n\n            jQuery.event.remove(this, \"._submit\");\n          }\n        };\n      } // IE change delegation and checkbox/radio fix\n\n\n      if (!jQuery.support.changeBubbles) {\n        jQuery.event.special.change = {\n          setup: function setup() {\n            if (rformElems.test(this.nodeName)) {\n              // IE doesn't fire change on a check/radio until blur; trigger it on click\n              // after a propertychange. Eat the blur-change in special.change.handle.\n              // This still fires onchange a second time for check/radio after blur.\n              if (this.type === \"checkbox\" || this.type === \"radio\") {\n                jQuery.event.add(this, \"propertychange._change\", function (event) {\n                  if (event.originalEvent.propertyName === \"checked\") {\n                    this._just_changed = true;\n                  }\n                });\n                jQuery.event.add(this, \"click._change\", function (event) {\n                  if (this._just_changed && !event.isTrigger) {\n                    this._just_changed = false;\n                    jQuery.event.simulate(\"change\", this, event, true);\n                  }\n                });\n              }\n\n              return false;\n            } // Delegated event; lazy-add a change handler on descendant inputs\n\n\n            jQuery.event.add(this, \"beforeactivate._change\", function (e) {\n              var elem = e.target;\n\n              if (rformElems.test(elem.nodeName) && !elem._change_attached) {\n                jQuery.event.add(elem, \"change._change\", function (event) {\n                  if (this.parentNode && !event.isSimulated && !event.isTrigger) {\n                    jQuery.event.simulate(\"change\", this.parentNode, event, true);\n                  }\n                });\n                elem._change_attached = true;\n              }\n            });\n          },\n          handle: function handle(event) {\n            var elem = event.target; // Swallow native change events from checkbox/radio, we already triggered them above\n\n            if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== \"radio\" && elem.type !== \"checkbox\") {\n              return event.handleObj.handler.apply(this, arguments);\n            }\n          },\n          teardown: function teardown() {\n            jQuery.event.remove(this, \"._change\");\n            return rformElems.test(this.nodeName);\n          }\n        };\n      } // Create \"bubbling\" focus and blur events\n\n\n      if (!jQuery.support.focusinBubbles) {\n        jQuery.each({\n          focus: \"focusin\",\n          blur: \"focusout\"\n        }, function (orig, fix) {\n          // Attach a single capturing handler while someone wants focusin/focusout\n          var attaches = 0,\n              handler = function handler(event) {\n            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);\n          };\n\n          jQuery.event.special[fix] = {\n            setup: function setup() {\n              if (attaches++ === 0) {\n                document.addEventListener(orig, handler, true);\n              }\n            },\n            teardown: function teardown() {\n              if (--attaches === 0) {\n                document.removeEventListener(orig, handler, true);\n              }\n            }\n          };\n        });\n      }\n\n      jQuery.fn.extend({\n        on: function on(types, selector, data, fn,\n        /*INTERNAL*/\n        one) {\n          var origFn, type; // Types can be a map of types/handlers\n\n          if (typeof types === \"object\") {\n            // ( types-Object, selector, data )\n            if (typeof selector !== \"string\") {\n              // && selector != null\n              // ( types-Object, data )\n              data = data || selector;\n              selector = undefined;\n            }\n\n            for (type in types) {\n              this.on(type, selector, data, types[type], one);\n            }\n\n            return this;\n          }\n\n          if (data == null && fn == null) {\n            // ( types, fn )\n            fn = selector;\n            data = selector = undefined;\n          } else if (fn == null) {\n            if (typeof selector === \"string\") {\n              // ( types, selector, fn )\n              fn = data;\n              data = undefined;\n            } else {\n              // ( types, data, fn )\n              fn = data;\n              data = selector;\n              selector = undefined;\n            }\n          }\n\n          if (fn === false) {\n            fn = returnFalse;\n          } else if (!fn) {\n            return this;\n          }\n\n          if (one === 1) {\n            origFn = fn;\n\n            fn = function fn(event) {\n              // Can use an empty set, since event contains the info\n              jQuery().off(event);\n              return origFn.apply(this, arguments);\n            }; // Use same guid so caller can remove using origFn\n\n\n            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n          }\n\n          return this.each(function () {\n            jQuery.event.add(this, types, fn, data, selector);\n          });\n        },\n        one: function one(types, selector, data, fn) {\n          return this.on(types, selector, data, fn, 1);\n        },\n        off: function off(types, selector, fn) {\n          if (types && types.preventDefault && types.handleObj) {\n            // ( event )  dispatched jQuery.Event\n            var handleObj = types.handleObj;\n            jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n            return this;\n          }\n\n          if (typeof types === \"object\") {\n            // ( types-object [, selector] )\n            for (var type in types) {\n              this.off(type, selector, types[type]);\n            }\n\n            return this;\n          }\n\n          if (selector === false || typeof selector === \"function\") {\n            // ( types [, fn] )\n            fn = selector;\n            selector = undefined;\n          }\n\n          if (fn === false) {\n            fn = returnFalse;\n          }\n\n          return this.each(function () {\n            jQuery.event.remove(this, types, fn, selector);\n          });\n        },\n        bind: function bind(types, data, fn) {\n          return this.on(types, null, data, fn);\n        },\n        unbind: function unbind(types, fn) {\n          return this.off(types, null, fn);\n        },\n        live: function live(types, data, fn) {\n          jQuery(this.context).on(types, this.selector, data, fn);\n          return this;\n        },\n        die: function die(types, fn) {\n          jQuery(this.context).off(types, this.selector || \"**\", fn);\n          return this;\n        },\n        delegate: function delegate(selector, types, data, fn) {\n          return this.on(types, selector, data, fn);\n        },\n        undelegate: function undelegate(selector, types, fn) {\n          // ( namespace ) or ( selector, types [, fn] )\n          return arguments.length == 1 ? this.off(selector, \"**\") : this.off(types, selector, fn);\n        },\n        trigger: function trigger(type, data) {\n          return this.each(function () {\n            jQuery.event.trigger(type, data, this);\n          });\n        },\n        triggerHandler: function triggerHandler(type, data) {\n          if (this[0]) {\n            return jQuery.event.trigger(type, data, this[0], true);\n          }\n        },\n        toggle: function toggle(fn) {\n          // Save reference to arguments for access in closure\n          var args = arguments,\n              guid = fn.guid || jQuery.guid++,\n              i = 0,\n              toggler = function toggler(event) {\n            // Figure out which function to execute\n            var lastToggle = (jQuery._data(this, \"lastToggle\" + fn.guid) || 0) % i;\n\n            jQuery._data(this, \"lastToggle\" + fn.guid, lastToggle + 1); // Make sure that clicks stop\n\n\n            event.preventDefault(); // and execute the function\n\n            return args[lastToggle].apply(this, arguments) || false;\n          }; // link all the functions, so any of them can unbind this click handler\n\n\n          toggler.guid = guid;\n\n          while (i < args.length) {\n            args[i++].guid = guid;\n          }\n\n          return this.click(toggler);\n        },\n        hover: function hover(fnOver, fnOut) {\n          return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n        }\n      });\n      jQuery.each((\"blur focus focusin focusout load resize scroll unload click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function (i, name) {\n        // Handle event binding\n        jQuery.fn[name] = function (data, fn) {\n          if (fn == null) {\n            fn = data;\n            data = null;\n          }\n\n          return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n        };\n\n        if (jQuery.attrFn) {\n          jQuery.attrFn[name] = true;\n        }\n\n        if (rkeyEvent.test(name)) {\n          jQuery.event.fixHooks[name] = jQuery.event.keyHooks;\n        }\n\n        if (rmouseEvent.test(name)) {\n          jQuery.event.fixHooks[name] = jQuery.event.mouseHooks;\n        }\n      });\n      /*!\n       * Sizzle CSS Selector Engine\n       *  Copyright 2011, The Dojo Foundation\n       *  Released under the MIT, BSD, and GPL Licenses.\n       *  More information: http://sizzlejs.com/\n       */\n\n      (function () {\n        var chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,\n            expando = \"sizcache\" + (Math.random() + '').replace('.', ''),\n            done = 0,\n            toString = Object.prototype.toString,\n            hasDuplicate = false,\n            baseHasDuplicate = true,\n            rBackslash = /\\\\/g,\n            rReturn = /\\r\\n/g,\n            rNonWord = /\\W/; // Here we check if the JavaScript engine is using some sort of\n        // optimization where it does not always call our comparision\n        // function. If that is the case, discard the hasDuplicate value.\n        //   Thus far that includes Google Chrome.\n\n        [0, 0].sort(function () {\n          baseHasDuplicate = false;\n          return 0;\n        });\n\n        var _Sizzle2 = function Sizzle(selector, context, results, seed) {\n          results = results || [];\n          context = context || document;\n          var origContext = context;\n\n          if (context.nodeType !== 1 && context.nodeType !== 9) {\n            return [];\n          }\n\n          if (!selector || typeof selector !== \"string\") {\n            return results;\n          }\n\n          var m,\n              set,\n              checkSet,\n              extra,\n              ret,\n              cur,\n              pop,\n              i,\n              prune = true,\n              contextXML = _Sizzle2.isXML(context),\n              parts = [],\n              soFar = selector; // Reset the position of the chunker regexp (start from head)\n\n\n          do {\n            chunker.exec(\"\");\n            m = chunker.exec(soFar);\n\n            if (m) {\n              soFar = m[3];\n              parts.push(m[1]);\n\n              if (m[2]) {\n                extra = m[3];\n                break;\n              }\n            }\n          } while (m);\n\n          if (parts.length > 1 && origPOS.exec(selector)) {\n            if (parts.length === 2 && Expr.relative[parts[0]]) {\n              set = posProcess(parts[0] + parts[1], context, seed);\n            } else {\n              set = Expr.relative[parts[0]] ? [context] : _Sizzle2(parts.shift(), context);\n\n              while (parts.length) {\n                selector = parts.shift();\n\n                if (Expr.relative[selector]) {\n                  selector += parts.shift();\n                }\n\n                set = posProcess(selector, set, seed);\n              }\n            }\n          } else {\n            // Take a shortcut and set the context if the root selector is an ID\n            // (but not if it'll be faster if the inner selector is an ID)\n            if (!seed && parts.length > 1 && context.nodeType === 9 && !contextXML && Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1])) {\n              ret = _Sizzle2.find(parts.shift(), context, contextXML);\n              context = ret.expr ? _Sizzle2.filter(ret.expr, ret.set)[0] : ret.set[0];\n            }\n\n            if (context) {\n              ret = seed ? {\n                expr: parts.pop(),\n                set: makeArray(seed)\n              } : _Sizzle2.find(parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML);\n              set = ret.expr ? _Sizzle2.filter(ret.expr, ret.set) : ret.set;\n\n              if (parts.length > 0) {\n                checkSet = makeArray(set);\n              } else {\n                prune = false;\n              }\n\n              while (parts.length) {\n                cur = parts.pop();\n                pop = cur;\n\n                if (!Expr.relative[cur]) {\n                  cur = \"\";\n                } else {\n                  pop = parts.pop();\n                }\n\n                if (pop == null) {\n                  pop = context;\n                }\n\n                Expr.relative[cur](checkSet, pop, contextXML);\n              }\n            } else {\n              checkSet = parts = [];\n            }\n          }\n\n          if (!checkSet) {\n            checkSet = set;\n          }\n\n          if (!checkSet) {\n            _Sizzle2.error(cur || selector);\n          }\n\n          if (toString.call(checkSet) === \"[object Array]\") {\n            if (!prune) {\n              results.push.apply(results, checkSet);\n            } else if (context && context.nodeType === 1) {\n              for (i = 0; checkSet[i] != null; i++) {\n                if (checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && _Sizzle2.contains(context, checkSet[i]))) {\n                  results.push(set[i]);\n                }\n              }\n            } else {\n              for (i = 0; checkSet[i] != null; i++) {\n                if (checkSet[i] && checkSet[i].nodeType === 1) {\n                  results.push(set[i]);\n                }\n              }\n            }\n          } else {\n            makeArray(checkSet, results);\n          }\n\n          if (extra) {\n            _Sizzle2(extra, origContext, results, seed);\n\n            _Sizzle2.uniqueSort(results);\n          }\n\n          return results;\n        };\n\n        _Sizzle2.uniqueSort = function (results) {\n          if (sortOrder) {\n            hasDuplicate = baseHasDuplicate;\n            results.sort(sortOrder);\n\n            if (hasDuplicate) {\n              for (var i = 1; i < results.length; i++) {\n                if (results[i] === results[i - 1]) {\n                  results.splice(i--, 1);\n                }\n              }\n            }\n          }\n\n          return results;\n        };\n\n        _Sizzle2.matches = function (expr, set) {\n          return _Sizzle2(expr, null, null, set);\n        };\n\n        _Sizzle2.matchesSelector = function (node, expr) {\n          return _Sizzle2(expr, null, null, [node]).length > 0;\n        };\n\n        _Sizzle2.find = function (expr, context, isXML) {\n          var set, i, len, match, type, left;\n\n          if (!expr) {\n            return [];\n          }\n\n          for (i = 0, len = Expr.order.length; i < len; i++) {\n            type = Expr.order[i];\n\n            if (match = Expr.leftMatch[type].exec(expr)) {\n              left = match[1];\n              match.splice(1, 1);\n\n              if (left.substr(left.length - 1) !== \"\\\\\") {\n                match[1] = (match[1] || \"\").replace(rBackslash, \"\");\n                set = Expr.find[type](match, context, isXML);\n\n                if (set != null) {\n                  expr = expr.replace(Expr.match[type], \"\");\n                  break;\n                }\n              }\n            }\n          }\n\n          if (!set) {\n            set = typeof context.getElementsByTagName !== \"undefined\" ? context.getElementsByTagName(\"*\") : [];\n          }\n\n          return {\n            set: set,\n            expr: expr\n          };\n        };\n\n        _Sizzle2.filter = function (expr, set, inplace, not) {\n          var match,\n              anyFound,\n              type,\n              found,\n              item,\n              filter,\n              left,\n              i,\n              pass,\n              old = expr,\n              result = [],\n              curLoop = set,\n              isXMLFilter = set && set[0] && _Sizzle2.isXML(set[0]);\n\n          while (expr && set.length) {\n            for (type in Expr.filter) {\n              if ((match = Expr.leftMatch[type].exec(expr)) != null && match[2]) {\n                filter = Expr.filter[type];\n                left = match[1];\n                anyFound = false;\n                match.splice(1, 1);\n\n                if (left.substr(left.length - 1) === \"\\\\\") {\n                  continue;\n                }\n\n                if (curLoop === result) {\n                  result = [];\n                }\n\n                if (Expr.preFilter[type]) {\n                  match = Expr.preFilter[type](match, curLoop, inplace, result, not, isXMLFilter);\n\n                  if (!match) {\n                    anyFound = found = true;\n                  } else if (match === true) {\n                    continue;\n                  }\n                }\n\n                if (match) {\n                  for (i = 0; (item = curLoop[i]) != null; i++) {\n                    if (item) {\n                      found = filter(item, match, i, curLoop);\n                      pass = not ^ found;\n\n                      if (inplace && found != null) {\n                        if (pass) {\n                          anyFound = true;\n                        } else {\n                          curLoop[i] = false;\n                        }\n                      } else if (pass) {\n                        result.push(item);\n                        anyFound = true;\n                      }\n                    }\n                  }\n                }\n\n                if (found !== undefined) {\n                  if (!inplace) {\n                    curLoop = result;\n                  }\n\n                  expr = expr.replace(Expr.match[type], \"\");\n\n                  if (!anyFound) {\n                    return [];\n                  }\n\n                  break;\n                }\n              }\n            } // Improper expression\n\n\n            if (expr === old) {\n              if (anyFound == null) {\n                _Sizzle2.error(expr);\n              } else {\n                break;\n              }\n            }\n\n            old = expr;\n          }\n\n          return curLoop;\n        };\n\n        _Sizzle2.error = function (msg) {\n          throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n        };\n        /**\n         * Utility function for retreiving the text value of an array of DOM nodes\n         * @param {Array|Element} elem\n         */\n\n\n        var getText = _Sizzle2.getText = function (elem) {\n          var i,\n              node,\n              nodeType = elem.nodeType,\n              ret = \"\";\n\n          if (nodeType) {\n            if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n              // Use textContent || innerText for elements\n              if (typeof elem.textContent === 'string') {\n                return elem.textContent;\n              } else if (typeof elem.innerText === 'string') {\n                // Replace IE's carriage returns\n                return elem.innerText.replace(rReturn, '');\n              } else {\n                // Traverse it's children\n                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n                  ret += getText(elem);\n                }\n              }\n            } else if (nodeType === 3 || nodeType === 4) {\n              return elem.nodeValue;\n            }\n          } else {\n            // If no nodeType, this is expected to be an array\n            for (i = 0; node = elem[i]; i++) {\n              // Do not traverse comment nodes\n              if (node.nodeType !== 8) {\n                ret += getText(node);\n              }\n            }\n          }\n\n          return ret;\n        };\n\n        var Expr = _Sizzle2.selectors = {\n          order: [\"ID\", \"NAME\", \"TAG\"],\n          match: {\n            ID: /#((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\n            CLASS: /\\.((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\n            NAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)['\"]*\\]/,\n            ATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(?:(['\"])(.*?)\\3|(#?(?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)*)|)|)\\s*\\]/,\n            TAG: /^((?:[\\w\\u00c0-\\uFFFF\\*\\-]|\\\\.)+)/,\n            CHILD: /:(only|nth|last|first)-child(?:\\(\\s*(even|odd|(?:[+\\-]?\\d+|(?:[+\\-]?\\d*)?n\\s*(?:[+\\-]\\s*\\d+)?))\\s*\\))?/,\n            POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^\\-]|$)/,\n            PSEUDO: /:((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/\n          },\n          leftMatch: {},\n          attrMap: {\n            \"class\": \"className\",\n            \"for\": \"htmlFor\"\n          },\n          attrHandle: {\n            href: function href(elem) {\n              return elem.getAttribute(\"href\");\n            },\n            type: function type(elem) {\n              return elem.getAttribute(\"type\");\n            }\n          },\n          relative: {\n            \"+\": function _(checkSet, part) {\n              var isPartStr = typeof part === \"string\",\n                  isTag = isPartStr && !rNonWord.test(part),\n                  isPartStrNotTag = isPartStr && !isTag;\n\n              if (isTag) {\n                part = part.toLowerCase();\n              }\n\n              for (var i = 0, l = checkSet.length, elem; i < l; i++) {\n                if (elem = checkSet[i]) {\n                  while ((elem = elem.previousSibling) && elem.nodeType !== 1) {}\n\n                  checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ? elem || false : elem === part;\n                }\n              }\n\n              if (isPartStrNotTag) {\n                _Sizzle2.filter(part, checkSet, true);\n              }\n            },\n            \">\": function _(checkSet, part) {\n              var elem,\n                  isPartStr = typeof part === \"string\",\n                  i = 0,\n                  l = checkSet.length;\n\n              if (isPartStr && !rNonWord.test(part)) {\n                part = part.toLowerCase();\n\n                for (; i < l; i++) {\n                  elem = checkSet[i];\n\n                  if (elem) {\n                    var parent = elem.parentNode;\n                    checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;\n                  }\n                }\n              } else {\n                for (; i < l; i++) {\n                  elem = checkSet[i];\n\n                  if (elem) {\n                    checkSet[i] = isPartStr ? elem.parentNode : elem.parentNode === part;\n                  }\n                }\n\n                if (isPartStr) {\n                  _Sizzle2.filter(part, checkSet, true);\n                }\n              }\n            },\n            \"\": function _(checkSet, part, isXML) {\n              var nodeCheck,\n                  doneName = done++,\n                  checkFn = dirCheck;\n\n              if (typeof part === \"string\" && !rNonWord.test(part)) {\n                part = part.toLowerCase();\n                nodeCheck = part;\n                checkFn = dirNodeCheck;\n              }\n\n              checkFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML);\n            },\n            \"~\": function _(checkSet, part, isXML) {\n              var nodeCheck,\n                  doneName = done++,\n                  checkFn = dirCheck;\n\n              if (typeof part === \"string\" && !rNonWord.test(part)) {\n                part = part.toLowerCase();\n                nodeCheck = part;\n                checkFn = dirNodeCheck;\n              }\n\n              checkFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML);\n            }\n          },\n          find: {\n            ID: function ID(match, context, isXML) {\n              if (typeof context.getElementById !== \"undefined\" && !isXML) {\n                var m = context.getElementById(match[1]); // Check parentNode to catch when Blackberry 4.6 returns\n                // nodes that are no longer in the document #6963\n\n                return m && m.parentNode ? [m] : [];\n              }\n            },\n            NAME: function NAME(match, context) {\n              if (typeof context.getElementsByName !== \"undefined\") {\n                var ret = [],\n                    results = context.getElementsByName(match[1]);\n\n                for (var i = 0, l = results.length; i < l; i++) {\n                  if (results[i].getAttribute(\"name\") === match[1]) {\n                    ret.push(results[i]);\n                  }\n                }\n\n                return ret.length === 0 ? null : ret;\n              }\n            },\n            TAG: function TAG(match, context) {\n              if (typeof context.getElementsByTagName !== \"undefined\") {\n                return context.getElementsByTagName(match[1]);\n              }\n            }\n          },\n          preFilter: {\n            CLASS: function CLASS(match, curLoop, inplace, result, not, isXML) {\n              match = \" \" + match[1].replace(rBackslash, \"\") + \" \";\n\n              if (isXML) {\n                return match;\n              }\n\n              for (var i = 0, elem; (elem = curLoop[i]) != null; i++) {\n                if (elem) {\n                  if (not ^ (elem.className && (\" \" + elem.className + \" \").replace(/[\\t\\n\\r]/g, \" \").indexOf(match) >= 0)) {\n                    if (!inplace) {\n                      result.push(elem);\n                    }\n                  } else if (inplace) {\n                    curLoop[i] = false;\n                  }\n                }\n              }\n\n              return false;\n            },\n            ID: function ID(match) {\n              return match[1].replace(rBackslash, \"\");\n            },\n            TAG: function TAG(match, curLoop) {\n              return match[1].replace(rBackslash, \"\").toLowerCase();\n            },\n            CHILD: function CHILD(match) {\n              if (match[1] === \"nth\") {\n                if (!match[2]) {\n                  _Sizzle2.error(match[0]);\n                }\n\n                match[2] = match[2].replace(/^\\+|\\s*/g, ''); // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\n\n                var test = /(-?)(\\d*)(?:n([+\\-]?\\d*))?/.exec(match[2] === \"even\" && \"2n\" || match[2] === \"odd\" && \"2n+1\" || !/\\D/.test(match[2]) && \"0n+\" + match[2] || match[2]); // calculate the numbers (first)n+(last) including if they are negative\n\n                match[2] = test[1] + (test[2] || 1) - 0;\n                match[3] = test[3] - 0;\n              } else if (match[2]) {\n                _Sizzle2.error(match[0]);\n              } // TODO: Move to normal caching system\n\n\n              match[0] = done++;\n              return match;\n            },\n            ATTR: function ATTR(match, curLoop, inplace, result, not, isXML) {\n              var name = match[1] = match[1].replace(rBackslash, \"\");\n\n              if (!isXML && Expr.attrMap[name]) {\n                match[1] = Expr.attrMap[name];\n              } // Handle if an un-quoted value was used\n\n\n              match[4] = (match[4] || match[5] || \"\").replace(rBackslash, \"\");\n\n              if (match[2] === \"~=\") {\n                match[4] = \" \" + match[4] + \" \";\n              }\n\n              return match;\n            },\n            PSEUDO: function PSEUDO(match, curLoop, inplace, result, not) {\n              if (match[1] === \"not\") {\n                // If we're dealing with a complex expression, or a simple one\n                if ((chunker.exec(match[3]) || \"\").length > 1 || /^\\w/.test(match[3])) {\n                  match[3] = _Sizzle2(match[3], null, null, curLoop);\n                } else {\n                  var ret = _Sizzle2.filter(match[3], curLoop, inplace, true ^ not);\n\n                  if (!inplace) {\n                    result.push.apply(result, ret);\n                  }\n\n                  return false;\n                }\n              } else if (Expr.match.POS.test(match[0]) || Expr.match.CHILD.test(match[0])) {\n                return true;\n              }\n\n              return match;\n            },\n            POS: function POS(match) {\n              match.unshift(true);\n              return match;\n            }\n          },\n          filters: {\n            enabled: function enabled(elem) {\n              return elem.disabled === false && elem.type !== \"hidden\";\n            },\n            disabled: function disabled(elem) {\n              return elem.disabled === true;\n            },\n            checked: function checked(elem) {\n              return elem.checked === true;\n            },\n            selected: function selected(elem) {\n              // Accessing this property makes selected-by-default\n              // options in Safari work properly\n              if (elem.parentNode) {\n                elem.parentNode.selectedIndex;\n              }\n\n              return elem.selected === true;\n            },\n            parent: function parent(elem) {\n              return !!elem.firstChild;\n            },\n            empty: function empty(elem) {\n              return !elem.firstChild;\n            },\n            has: function has(elem, i, match) {\n              return !!_Sizzle2(match[3], elem).length;\n            },\n            header: function header(elem) {\n              return /h\\d/i.test(elem.nodeName);\n            },\n            text: function text(elem) {\n              var attr = elem.getAttribute(\"type\"),\n                  type = elem.type; // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\n              // use getAttribute instead to test this case\n\n              return elem.nodeName.toLowerCase() === \"input\" && \"text\" === type && (attr === type || attr === null);\n            },\n            radio: function radio(elem) {\n              return elem.nodeName.toLowerCase() === \"input\" && \"radio\" === elem.type;\n            },\n            checkbox: function checkbox(elem) {\n              return elem.nodeName.toLowerCase() === \"input\" && \"checkbox\" === elem.type;\n            },\n            file: function file(elem) {\n              return elem.nodeName.toLowerCase() === \"input\" && \"file\" === elem.type;\n            },\n            password: function password(elem) {\n              return elem.nodeName.toLowerCase() === \"input\" && \"password\" === elem.type;\n            },\n            submit: function submit(elem) {\n              var name = elem.nodeName.toLowerCase();\n              return (name === \"input\" || name === \"button\") && \"submit\" === elem.type;\n            },\n            image: function image(elem) {\n              return elem.nodeName.toLowerCase() === \"input\" && \"image\" === elem.type;\n            },\n            reset: function reset(elem) {\n              var name = elem.nodeName.toLowerCase();\n              return (name === \"input\" || name === \"button\") && \"reset\" === elem.type;\n            },\n            button: function button(elem) {\n              var name = elem.nodeName.toLowerCase();\n              return name === \"input\" && \"button\" === elem.type || name === \"button\";\n            },\n            input: function input(elem) {\n              return /input|select|textarea|button/i.test(elem.nodeName);\n            },\n            focus: function focus(elem) {\n              return elem === elem.ownerDocument.activeElement;\n            }\n          },\n          setFilters: {\n            first: function first(elem, i) {\n              return i === 0;\n            },\n            last: function last(elem, i, match, array) {\n              return i === array.length - 1;\n            },\n            even: function even(elem, i) {\n              return i % 2 === 0;\n            },\n            odd: function odd(elem, i) {\n              return i % 2 === 1;\n            },\n            lt: function lt(elem, i, match) {\n              return i < match[3] - 0;\n            },\n            gt: function gt(elem, i, match) {\n              return i > match[3] - 0;\n            },\n            nth: function nth(elem, i, match) {\n              return match[3] - 0 === i;\n            },\n            eq: function eq(elem, i, match) {\n              return match[3] - 0 === i;\n            }\n          },\n          filter: {\n            PSEUDO: function PSEUDO(elem, match, i, array) {\n              var name = match[1],\n                  filter = Expr.filters[name];\n\n              if (filter) {\n                return filter(elem, i, match, array);\n              } else if (name === \"contains\") {\n                return (elem.textContent || elem.innerText || getText([elem]) || \"\").indexOf(match[3]) >= 0;\n              } else if (name === \"not\") {\n                var not = match[3];\n\n                for (var j = 0, l = not.length; j < l; j++) {\n                  if (not[j] === elem) {\n                    return false;\n                  }\n                }\n\n                return true;\n              } else {\n                _Sizzle2.error(name);\n              }\n            },\n            CHILD: function CHILD(elem, match) {\n              var first,\n                  last,\n                  doneName,\n                  parent,\n                  cache,\n                  count,\n                  diff,\n                  type = match[1],\n                  node = elem;\n\n              switch (type) {\n                case \"only\":\n                case \"first\":\n                  while (node = node.previousSibling) {\n                    if (node.nodeType === 1) {\n                      return false;\n                    }\n                  }\n\n                  if (type === \"first\") {\n                    return true;\n                  }\n\n                  node = elem;\n\n                /* falls through */\n\n                case \"last\":\n                  while (node = node.nextSibling) {\n                    if (node.nodeType === 1) {\n                      return false;\n                    }\n                  }\n\n                  return true;\n\n                case \"nth\":\n                  first = match[2];\n                  last = match[3];\n\n                  if (first === 1 && last === 0) {\n                    return true;\n                  }\n\n                  doneName = match[0];\n                  parent = elem.parentNode;\n\n                  if (parent && (parent[expando] !== doneName || !elem.nodeIndex)) {\n                    count = 0;\n\n                    for (node = parent.firstChild; node; node = node.nextSibling) {\n                      if (node.nodeType === 1) {\n                        node.nodeIndex = ++count;\n                      }\n                    }\n\n                    parent[expando] = doneName;\n                  }\n\n                  diff = elem.nodeIndex - last;\n\n                  if (first === 0) {\n                    return diff === 0;\n                  } else {\n                    return diff % first === 0 && diff / first >= 0;\n                  }\n\n              }\n            },\n            ID: function ID(elem, match) {\n              return elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\n            },\n            TAG: function TAG(elem, match) {\n              return match === \"*\" && elem.nodeType === 1 || !!elem.nodeName && elem.nodeName.toLowerCase() === match;\n            },\n            CLASS: function CLASS(elem, match) {\n              return (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \").indexOf(match) > -1;\n            },\n            ATTR: function ATTR(elem, match) {\n              var name = match[1],\n                  result = _Sizzle2.attr ? _Sizzle2.attr(elem, name) : Expr.attrHandle[name] ? Expr.attrHandle[name](elem) : elem[name] != null ? elem[name] : elem.getAttribute(name),\n                  value = result + \"\",\n                  type = match[2],\n                  check = match[4];\n              return result == null ? type === \"!=\" : !type && _Sizzle2.attr ? result != null : type === \"=\" ? value === check : type === \"*=\" ? value.indexOf(check) >= 0 : type === \"~=\" ? (\" \" + value + \" \").indexOf(check) >= 0 : !check ? value && result !== false : type === \"!=\" ? value !== check : type === \"^=\" ? value.indexOf(check) === 0 : type === \"$=\" ? value.substr(value.length - check.length) === check : type === \"|=\" ? value === check || value.substr(0, check.length + 1) === check + \"-\" : false;\n            },\n            POS: function POS(elem, match, i, array) {\n              var name = match[2],\n                  filter = Expr.setFilters[name];\n\n              if (filter) {\n                return filter(elem, i, match, array);\n              }\n            }\n          }\n        };\n\n        var origPOS = Expr.match.POS,\n            fescape = function fescape(all, num) {\n          return \"\\\\\" + (num - 0 + 1);\n        };\n\n        for (var type in Expr.match) {\n          Expr.match[type] = new RegExp(Expr.match[type].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source);\n          Expr.leftMatch[type] = new RegExp(/(^(?:.|\\r|\\n)*?)/.source + Expr.match[type].source.replace(/\\\\(\\d+)/g, fescape));\n        } // Expose origPOS\n        // \"global\" as in regardless of relation to brackets/parens\n\n\n        Expr.match.globalPOS = origPOS;\n\n        var makeArray = function makeArray(array, results) {\n          array = Array.prototype.slice.call(array, 0);\n\n          if (results) {\n            results.push.apply(results, array);\n            return results;\n          }\n\n          return array;\n        }; // Perform a simple check to determine if the browser is capable of\n        // converting a NodeList to an array using builtin methods.\n        // Also verifies that the returned array holds DOM nodes\n        // (which is not the case in the Blackberry browser)\n\n\n        try {\n          Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType; // Provide a fallback method if it does not work\n        } catch (e) {\n          makeArray = function makeArray(array, results) {\n            var i = 0,\n                ret = results || [];\n\n            if (toString.call(array) === \"[object Array]\") {\n              Array.prototype.push.apply(ret, array);\n            } else {\n              if (typeof array.length === \"number\") {\n                for (var l = array.length; i < l; i++) {\n                  ret.push(array[i]);\n                }\n              } else {\n                for (; array[i]; i++) {\n                  ret.push(array[i]);\n                }\n              }\n            }\n\n            return ret;\n          };\n        }\n\n        var sortOrder, siblingCheck;\n\n        if (document.documentElement.compareDocumentPosition) {\n          sortOrder = function sortOrder(a, b) {\n            if (a === b) {\n              hasDuplicate = true;\n              return 0;\n            }\n\n            if (!a.compareDocumentPosition || !b.compareDocumentPosition) {\n              return a.compareDocumentPosition ? -1 : 1;\n            }\n\n            return a.compareDocumentPosition(b) & 4 ? -1 : 1;\n          };\n        } else {\n          sortOrder = function sortOrder(a, b) {\n            // The nodes are identical, we can exit early\n            if (a === b) {\n              hasDuplicate = true;\n              return 0; // Fallback to using sourceIndex (in IE) if it's available on both nodes\n            } else if (a.sourceIndex && b.sourceIndex) {\n              return a.sourceIndex - b.sourceIndex;\n            }\n\n            var al,\n                bl,\n                ap = [],\n                bp = [],\n                aup = a.parentNode,\n                bup = b.parentNode,\n                cur = aup; // If the nodes are siblings (or identical) we can do a quick check\n\n            if (aup === bup) {\n              return siblingCheck(a, b); // If no parents were found then the nodes are disconnected\n            } else if (!aup) {\n              return -1;\n            } else if (!bup) {\n              return 1;\n            } // Otherwise they're somewhere else in the tree so we need\n            // to build up a full list of the parentNodes for comparison\n\n\n            while (cur) {\n              ap.unshift(cur);\n              cur = cur.parentNode;\n            }\n\n            cur = bup;\n\n            while (cur) {\n              bp.unshift(cur);\n              cur = cur.parentNode;\n            }\n\n            al = ap.length;\n            bl = bp.length; // Start walking down the tree looking for a discrepancy\n\n            for (var i = 0; i < al && i < bl; i++) {\n              if (ap[i] !== bp[i]) {\n                return siblingCheck(ap[i], bp[i]);\n              }\n            } // We ended someplace up the tree so do a sibling check\n\n\n            return i === al ? siblingCheck(a, bp[i], -1) : siblingCheck(ap[i], b, 1);\n          };\n\n          siblingCheck = function siblingCheck(a, b, ret) {\n            if (a === b) {\n              return ret;\n            }\n\n            var cur = a.nextSibling;\n\n            while (cur) {\n              if (cur === b) {\n                return -1;\n              }\n\n              cur = cur.nextSibling;\n            }\n\n            return 1;\n          };\n        } // Check to see if the browser returns elements by name when\n        // querying by getElementById (and provide a workaround)\n\n\n        (function () {\n          // We're going to inject a fake input element with a specified name\n          var form = document.createElement(\"div\"),\n              id = \"script\" + new Date().getTime(),\n              root = document.documentElement;\n          form.innerHTML = \"<a name='\" + id + \"'/>\"; // Inject it into the root element, check its status, and remove it quickly\n\n          root.insertBefore(form, root.firstChild); // The workaround has to do additional checks after a getElementById\n          // Which slows things down for other browsers (hence the branching)\n\n          if (document.getElementById(id)) {\n            Expr.find.ID = function (match, context, isXML) {\n              if (typeof context.getElementById !== \"undefined\" && !isXML) {\n                var m = context.getElementById(match[1]);\n                return m ? m.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ? [m] : undefined : [];\n              }\n            };\n\n            Expr.filter.ID = function (elem, match) {\n              var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n              return elem.nodeType === 1 && node && node.nodeValue === match;\n            };\n          }\n\n          root.removeChild(form); // release memory in IE\n\n          root = form = null;\n        })();\n\n        (function () {\n          // Check to see if the browser returns only elements\n          // when doing getElementsByTagName(\"*\")\n          // Create a fake element\n          var div = document.createElement(\"div\");\n          div.appendChild(document.createComment(\"\")); // Make sure no comments are found\n\n          if (div.getElementsByTagName(\"*\").length > 0) {\n            Expr.find.TAG = function (match, context) {\n              var results = context.getElementsByTagName(match[1]); // Filter out possible comments\n\n              if (match[1] === \"*\") {\n                var tmp = [];\n\n                for (var i = 0; results[i]; i++) {\n                  if (results[i].nodeType === 1) {\n                    tmp.push(results[i]);\n                  }\n                }\n\n                results = tmp;\n              }\n\n              return results;\n            };\n          } // Check to see if an attribute returns normalized href attributes\n\n\n          div.innerHTML = \"<a href='#'></a>\";\n\n          if (div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" && div.firstChild.getAttribute(\"href\") !== \"#\") {\n            Expr.attrHandle.href = function (elem) {\n              return elem.getAttribute(\"href\", 2);\n            };\n          } // release memory in IE\n\n\n          div = null;\n        })();\n\n        if (document.querySelectorAll) {\n          (function () {\n            var oldSizzle = _Sizzle2,\n                div = document.createElement(\"div\"),\n                id = \"__sizzle__\";\n            div.innerHTML = \"<p class='TEST'></p>\"; // Safari can't handle uppercase or unicode characters when\n            // in quirks mode.\n\n            if (div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0) {\n              return;\n            }\n\n            _Sizzle2 = function _Sizzle(query, context, extra, seed) {\n              context = context || document; // Only use querySelectorAll on non-XML documents\n              // (ID selectors don't work in non-HTML documents)\n\n              if (!seed && !_Sizzle2.isXML(context)) {\n                // See if we find a selector to speed up\n                var match = /^(\\w+$)|^\\.([\\w\\-]+$)|^#([\\w\\-]+$)/.exec(query);\n\n                if (match && (context.nodeType === 1 || context.nodeType === 9)) {\n                  // Speed-up: Sizzle(\"TAG\")\n                  if (match[1]) {\n                    return makeArray(context.getElementsByTagName(query), extra); // Speed-up: Sizzle(\".CLASS\")\n                  } else if (match[2] && Expr.find.CLASS && context.getElementsByClassName) {\n                    return makeArray(context.getElementsByClassName(match[2]), extra);\n                  }\n                }\n\n                if (context.nodeType === 9) {\n                  // Speed-up: Sizzle(\"body\")\n                  // The body element only exists once, optimize finding it\n                  if (query === \"body\" && context.body) {\n                    return makeArray([context.body], extra); // Speed-up: Sizzle(\"#ID\")\n                  } else if (match && match[3]) {\n                    var elem = context.getElementById(match[3]); // Check parentNode to catch when Blackberry 4.6 returns\n                    // nodes that are no longer in the document #6963\n\n                    if (elem && elem.parentNode) {\n                      // Handle the case where IE and Opera return items\n                      // by name instead of ID\n                      if (elem.id === match[3]) {\n                        return makeArray([elem], extra);\n                      }\n                    } else {\n                      return makeArray([], extra);\n                    }\n                  }\n\n                  try {\n                    return makeArray(context.querySelectorAll(query), extra);\n                  } catch (qsaError) {} // qSA works strangely on Element-rooted queries\n                  // We can work around this by specifying an extra ID on the root\n                  // and working up from there (Thanks to Andrew Dupont for the technique)\n                  // IE 8 doesn't work on object elements\n\n                } else if (context.nodeType === 1 && context.nodeName.toLowerCase() !== \"object\") {\n                  var oldContext = context,\n                      old = context.getAttribute(\"id\"),\n                      nid = old || id,\n                      hasParent = context.parentNode,\n                      relativeHierarchySelector = /^\\s*[+~]/.test(query);\n\n                  if (!old) {\n                    context.setAttribute(\"id\", nid);\n                  } else {\n                    nid = nid.replace(/'/g, \"\\\\//JQUERY_SOURCE\");\n                  }\n\n                  if (relativeHierarchySelector && hasParent) {\n                    context = context.parentNode;\n                  }\n\n                  try {\n                    if (!relativeHierarchySelector || hasParent) {\n                      return makeArray(context.querySelectorAll(\"[id='\" + nid + \"'] \" + query), extra);\n                    }\n                  } catch (pseudoError) {} finally {\n                    if (!old) {\n                      oldContext.removeAttribute(\"id\");\n                    }\n                  }\n                }\n              }\n\n              return oldSizzle(query, context, extra, seed);\n            };\n\n            for (var prop in oldSizzle) {\n              _Sizzle2[prop] = oldSizzle[prop];\n            } // release memory in IE\n\n\n            div = null;\n          })();\n        }\n\n        (function () {\n          var html = document.documentElement,\n              matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;\n\n          if (matches) {\n            // Check to see if it's possible to do matchesSelector\n            // on a disconnected node (IE 9 fails this)\n            var disconnectedMatch = !matches.call(document.createElement(\"div\"), \"div\"),\n                pseudoWorks = false;\n\n            try {\n              // This should fail with an exception\n              // Gecko does not error, returns false instead\n              matches.call(document.documentElement, \"[test!='']:sizzle\");\n            } catch (pseudoError) {\n              pseudoWorks = true;\n            }\n\n            _Sizzle2.matchesSelector = function (node, expr) {\n              // Make sure that attribute selectors are quoted\n              expr = expr.replace(/\\=\\s*([^'\"\\]]*)\\s*\\]/g, \"='$1']\");\n\n              if (!_Sizzle2.isXML(node)) {\n                try {\n                  if (pseudoWorks || !Expr.match.PSEUDO.test(expr) && !/!=/.test(expr)) {\n                    var ret = matches.call(node, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n                    if (ret || !disconnectedMatch || // As well, disconnected nodes are said to be in a document\n                    // fragment in IE 9, so check for that\n                    node.document && node.document.nodeType !== 11) {\n                      return ret;\n                    }\n                  }\n                } catch (e) {}\n              }\n\n              return _Sizzle2(expr, null, null, [node]).length > 0;\n            };\n          }\n        })();\n\n        (function () {\n          var div = document.createElement(\"div\");\n          div.innerHTML = \"<div class='test e'></div><div class='test'></div>\"; // Opera can't find a second classname (in 9.6)\n          // Also, make sure that getElementsByClassName actually exists\n\n          if (!div.getElementsByClassName || div.getElementsByClassName(\"e\").length === 0) {\n            return;\n          } // Safari caches class attributes, doesn't catch changes (in 3.2)\n\n\n          div.lastChild.className = \"e\";\n\n          if (div.getElementsByClassName(\"e\").length === 1) {\n            return;\n          }\n\n          Expr.order.splice(1, 0, \"CLASS\");\n\n          Expr.find.CLASS = function (match, context, isXML) {\n            if (typeof context.getElementsByClassName !== \"undefined\" && !isXML) {\n              return context.getElementsByClassName(match[1]);\n            }\n          }; // release memory in IE\n\n\n          div = null;\n        })();\n\n        function dirNodeCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {\n          for (var i = 0, l = checkSet.length; i < l; i++) {\n            var elem = checkSet[i];\n\n            if (elem) {\n              var match = false;\n              elem = elem[dir];\n\n              while (elem) {\n                if (elem[expando] === doneName) {\n                  match = checkSet[elem.sizset];\n                  break;\n                }\n\n                if (elem.nodeType === 1 && !isXML) {\n                  elem[expando] = doneName;\n                  elem.sizset = i;\n                }\n\n                if (elem.nodeName.toLowerCase() === cur) {\n                  match = elem;\n                  break;\n                }\n\n                elem = elem[dir];\n              }\n\n              checkSet[i] = match;\n            }\n          }\n        }\n\n        function dirCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {\n          for (var i = 0, l = checkSet.length; i < l; i++) {\n            var elem = checkSet[i];\n\n            if (elem) {\n              var match = false;\n              elem = elem[dir];\n\n              while (elem) {\n                if (elem[expando] === doneName) {\n                  match = checkSet[elem.sizset];\n                  break;\n                }\n\n                if (elem.nodeType === 1) {\n                  if (!isXML) {\n                    elem[expando] = doneName;\n                    elem.sizset = i;\n                  }\n\n                  if (typeof cur !== \"string\") {\n                    if (elem === cur) {\n                      match = true;\n                      break;\n                    }\n                  } else if (_Sizzle2.filter(cur, [elem]).length > 0) {\n                    match = elem;\n                    break;\n                  }\n                }\n\n                elem = elem[dir];\n              }\n\n              checkSet[i] = match;\n            }\n          }\n        }\n\n        if (document.documentElement.contains) {\n          _Sizzle2.contains = function (a, b) {\n            return a !== b && (a.contains ? a.contains(b) : true);\n          };\n        } else if (document.documentElement.compareDocumentPosition) {\n          _Sizzle2.contains = function (a, b) {\n            return !!(a.compareDocumentPosition(b) & 16);\n          };\n        } else {\n          _Sizzle2.contains = function () {\n            return false;\n          };\n        }\n\n        _Sizzle2.isXML = function (elem) {\n          // documentElement is verified for cases where it doesn't yet exist\n          // (such as loading iframes in IE - #4833)\n          var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;\n          return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n        };\n\n        var posProcess = function posProcess(selector, context, seed) {\n          var match,\n              tmpSet = [],\n              later = \"\",\n              root = context.nodeType ? [context] : context; // Position selectors must be done after the filter\n          // And so must :not(positional) so we move all PSEUDOs to the end\n\n          while (match = Expr.match.PSEUDO.exec(selector)) {\n            later += match[0];\n            selector = selector.replace(Expr.match.PSEUDO, \"\");\n          }\n\n          selector = Expr.relative[selector] ? selector + \"*\" : selector;\n\n          for (var i = 0, l = root.length; i < l; i++) {\n            _Sizzle2(selector, root[i], tmpSet, seed);\n          }\n\n          return _Sizzle2.filter(later, tmpSet);\n        }; // EXPOSE\n        // Override sizzle attribute retrieval\n\n\n        _Sizzle2.attr = jQuery.attr;\n        _Sizzle2.selectors.attrMap = {};\n        jQuery.find = _Sizzle2;\n        jQuery.expr = _Sizzle2.selectors;\n        jQuery.expr[\":\"] = jQuery.expr.filters;\n        jQuery.unique = _Sizzle2.uniqueSort;\n        jQuery.text = _Sizzle2.getText;\n        jQuery.isXMLDoc = _Sizzle2.isXML;\n        jQuery.contains = _Sizzle2.contains;\n      })();\n\n      var runtil = /Until$/,\n          rparentsprev = /^(?:parents|prevUntil|prevAll)/,\n          // Note: This RegExp should be improved, or likely pulled from Sizzle\n      rmultiselector = /,/,\n          isSimple = /^.[^:#\\[\\.,]*$/,\n          slice = Array.prototype.slice,\n          POS = jQuery.expr.match.globalPOS,\n          // methods guaranteed to produce a unique set when starting from a unique set\n      guaranteedUnique = {\n        children: true,\n        contents: true,\n        next: true,\n        prev: true\n      };\n      jQuery.fn.extend({\n        find: function find(selector) {\n          var self = this,\n              i,\n              l;\n\n          if (typeof selector !== \"string\") {\n            return jQuery(selector).filter(function () {\n              for (i = 0, l = self.length; i < l; i++) {\n                if (jQuery.contains(self[i], this)) {\n                  return true;\n                }\n              }\n            });\n          }\n\n          var ret = this.pushStack(\"\", \"find\", selector),\n              length,\n              n,\n              r;\n\n          for (i = 0, l = this.length; i < l; i++) {\n            length = ret.length;\n            jQuery.find(selector, this[i], ret);\n\n            if (i > 0) {\n              // Make sure that the results are unique\n              for (n = length; n < ret.length; n++) {\n                for (r = 0; r < length; r++) {\n                  if (ret[r] === ret[n]) {\n                    ret.splice(n--, 1);\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          return ret;\n        },\n        has: function has(target) {\n          var targets = jQuery(target);\n          return this.filter(function () {\n            for (var i = 0, l = targets.length; i < l; i++) {\n              if (jQuery.contains(this, targets[i])) {\n                return true;\n              }\n            }\n          });\n        },\n        not: function not(selector) {\n          return this.pushStack(winnow(this, selector, false), \"not\", selector);\n        },\n        filter: function filter(selector) {\n          return this.pushStack(winnow(this, selector, true), \"filter\", selector);\n        },\n        is: function is(selector) {\n          return !!selector && (typeof selector === \"string\" ? // If this is a positional selector, check membership in the returned set\n          // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n          POS.test(selector) ? jQuery(selector, this.context).index(this[0]) >= 0 : jQuery.filter(selector, this).length > 0 : this.filter(selector).length > 0);\n        },\n        closest: function closest(selectors, context) {\n          var ret = [],\n              i,\n              l,\n              cur = this[0]; // Array (deprecated as of jQuery 1.7)\n\n          if (jQuery.isArray(selectors)) {\n            var level = 1;\n\n            while (cur && cur.ownerDocument && cur !== context) {\n              for (i = 0; i < selectors.length; i++) {\n                if (jQuery(cur).is(selectors[i])) {\n                  ret.push({\n                    selector: selectors[i],\n                    elem: cur,\n                    level: level\n                  });\n                }\n              }\n\n              cur = cur.parentNode;\n              level++;\n            }\n\n            return ret;\n          } // String\n\n\n          var pos = POS.test(selectors) || typeof selectors !== \"string\" ? jQuery(selectors, context || this.context) : 0;\n\n          for (i = 0, l = this.length; i < l; i++) {\n            cur = this[i];\n\n            while (cur) {\n              if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {\n                ret.push(cur);\n                break;\n              } else {\n                cur = cur.parentNode;\n\n                if (!cur || !cur.ownerDocument || cur === context || cur.nodeType === 11) {\n                  break;\n                }\n              }\n            }\n          }\n\n          ret = ret.length > 1 ? jQuery.unique(ret) : ret;\n          return this.pushStack(ret, \"closest\", selectors);\n        },\n        // Determine the position of an element within\n        // the matched set of elements\n        index: function index(elem) {\n          // No argument, return index in parent\n          if (!elem) {\n            return this[0] && this[0].parentNode ? this.prevAll().length : -1;\n          } // index in selector\n\n\n          if (typeof elem === \"string\") {\n            return jQuery.inArray(this[0], jQuery(elem));\n          } // Locate the position of the desired element\n\n\n          return jQuery.inArray( // If it receives a jQuery object, the first element is used\n          elem.jquery ? elem[0] : elem, this);\n        },\n        add: function add(selector, context) {\n          var set = typeof selector === \"string\" ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),\n              all = jQuery.merge(this.get(), set);\n          return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ? all : jQuery.unique(all));\n        },\n        andSelf: function andSelf() {\n          return this.add(this.prevObject);\n        }\n      }); // A painfully simple check to see if an element is disconnected\n      // from a document (should be improved, where feasible).\n\n      function isDisconnected(node) {\n        return !node || !node.parentNode || node.parentNode.nodeType === 11;\n      }\n\n      jQuery.each({\n        parent: function parent(elem) {\n          var parent = elem.parentNode;\n          return parent && parent.nodeType !== 11 ? parent : null;\n        },\n        parents: function parents(elem) {\n          return jQuery.dir(elem, \"parentNode\");\n        },\n        parentsUntil: function parentsUntil(elem, i, until) {\n          return jQuery.dir(elem, \"parentNode\", until);\n        },\n        next: function next(elem) {\n          return jQuery.nth(elem, 2, \"nextSibling\");\n        },\n        prev: function prev(elem) {\n          return jQuery.nth(elem, 2, \"previousSibling\");\n        },\n        nextAll: function nextAll(elem) {\n          return jQuery.dir(elem, \"nextSibling\");\n        },\n        prevAll: function prevAll(elem) {\n          return jQuery.dir(elem, \"previousSibling\");\n        },\n        nextUntil: function nextUntil(elem, i, until) {\n          return jQuery.dir(elem, \"nextSibling\", until);\n        },\n        prevUntil: function prevUntil(elem, i, until) {\n          return jQuery.dir(elem, \"previousSibling\", until);\n        },\n        siblings: function siblings(elem) {\n          return jQuery.sibling((elem.parentNode || {}).firstChild, elem);\n        },\n        children: function children(elem) {\n          return jQuery.sibling(elem.firstChild);\n        },\n        contents: function contents(elem) {\n          return jQuery.nodeName(elem, \"iframe\") ? elem.contentDocument || elem.contentWindow.document : jQuery.makeArray(elem.childNodes);\n        }\n      }, function (name, fn) {\n        jQuery.fn[name] = function (until, selector) {\n          var ret = jQuery.map(this, fn, until);\n\n          if (!runtil.test(name)) {\n            selector = until;\n          }\n\n          if (selector && typeof selector === \"string\") {\n            ret = jQuery.filter(selector, ret);\n          }\n\n          ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;\n\n          if ((this.length > 1 || rmultiselector.test(selector)) && rparentsprev.test(name)) {\n            ret = ret.reverse();\n          }\n\n          return this.pushStack(ret, name, slice.call(arguments).join(\",\"));\n        };\n      });\n      jQuery.extend({\n        filter: function filter(expr, elems, not) {\n          if (not) {\n            expr = \":not(\" + expr + \")\";\n          }\n\n          return elems.length === 1 ? jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] : jQuery.find.matches(expr, elems);\n        },\n        dir: function dir(elem, _dir, until) {\n          var matched = [],\n              cur = elem[_dir];\n\n          while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {\n            if (cur.nodeType === 1) {\n              matched.push(cur);\n            }\n\n            cur = cur[_dir];\n          }\n\n          return matched;\n        },\n        nth: function nth(cur, result, dir, elem) {\n          result = result || 1;\n          var num = 0;\n\n          for (; cur; cur = cur[dir]) {\n            if (cur.nodeType === 1 && ++num === result) {\n              break;\n            }\n          }\n\n          return cur;\n        },\n        sibling: function sibling(n, elem) {\n          var r = [];\n\n          for (; n; n = n.nextSibling) {\n            if (n.nodeType === 1 && n !== elem) {\n              r.push(n);\n            }\n          }\n\n          return r;\n        }\n      }); // Implement the identical functionality for filter and not\n\n      function winnow(elements, qualifier, keep) {\n        // Can't pass null or undefined to indexOf in Firefox 4\n        // Set to 0 to skip string check\n        qualifier = qualifier || 0;\n\n        if (jQuery.isFunction(qualifier)) {\n          return jQuery.grep(elements, function (elem, i) {\n            var retVal = !!qualifier.call(elem, i, elem);\n            return retVal === keep;\n          });\n        } else if (qualifier.nodeType) {\n          return jQuery.grep(elements, function (elem, i) {\n            return elem === qualifier === keep;\n          });\n        } else if (typeof qualifier === \"string\") {\n          var filtered = jQuery.grep(elements, function (elem) {\n            return elem.nodeType === 1;\n          });\n\n          if (isSimple.test(qualifier)) {\n            return jQuery.filter(qualifier, filtered, !keep);\n          } else {\n            qualifier = jQuery.filter(qualifier, filtered);\n          }\n        }\n\n        return jQuery.grep(elements, function (elem, i) {\n          return jQuery.inArray(elem, qualifier) >= 0 === keep;\n        });\n      }\n\n      function createSafeFragment(document) {\n        var list = nodeNames.split(\"|\"),\n            safeFrag = document.createDocumentFragment();\n\n        if (safeFrag.createElement) {\n          while (list.length) {\n            safeFrag.createElement(list.pop());\n          }\n        }\n\n        return safeFrag;\n      }\n\n      var nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" + \"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n          rinlinejQuery = / jQuery\\d+=\"(?:\\d+|null)\"/g,\n          rleadingWhitespace = /^\\s+/,\n          rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n          rtagName = /<([\\w:]+)/,\n          rtbody = /<tbody/i,\n          rhtml = /<|&#?\\w+;/,\n          rnoInnerhtml = /<(?:script|style)/i,\n          rnocache = /<(?:script|object|embed|option|style)/i,\n          rnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n          // checked=\"checked\" or checked\n      rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n          rscriptType = /\\/(java|ecma)script/i,\n          rcleanScript = /^\\s*<!(?:\\[CDATA\\[|\\-\\-)/,\n          wrapMap = {\n        option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n        legend: [1, \"<fieldset>\", \"</fieldset>\"],\n        thead: [1, \"<table>\", \"</table>\"],\n        tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n        td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n        col: [2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\"],\n        area: [1, \"<map>\", \"</map>\"],\n        _default: [0, \"\", \"\"]\n      },\n          safeFragment = createSafeFragment(document);\n      wrapMap.optgroup = wrapMap.option;\n      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n      wrapMap.th = wrapMap.td; // IE can't serialize <link> and <script> tags normally\n\n      if (!jQuery.support.htmlSerialize) {\n        wrapMap._default = [1, \"div<div>\", \"</div>\"];\n      }\n\n      jQuery.fn.extend({\n        text: function text(value) {\n          return jQuery.access(this, function (value) {\n            return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));\n          }, null, value, arguments.length);\n        },\n        wrapAll: function wrapAll(html) {\n          if (jQuery.isFunction(html)) {\n            return this.each(function (i) {\n              jQuery(this).wrapAll(html.call(this, i));\n            });\n          }\n\n          if (this[0]) {\n            // The elements to wrap the target around\n            var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n            if (this[0].parentNode) {\n              wrap.insertBefore(this[0]);\n            }\n\n            wrap.map(function () {\n              var elem = this;\n\n              while (elem.firstChild && elem.firstChild.nodeType === 1) {\n                elem = elem.firstChild;\n              }\n\n              return elem;\n            }).append(this);\n          }\n\n          return this;\n        },\n        wrapInner: function wrapInner(html) {\n          if (jQuery.isFunction(html)) {\n            return this.each(function (i) {\n              jQuery(this).wrapInner(html.call(this, i));\n            });\n          }\n\n          return this.each(function () {\n            var self = jQuery(this),\n                contents = self.contents();\n\n            if (contents.length) {\n              contents.wrapAll(html);\n            } else {\n              self.append(html);\n            }\n          });\n        },\n        wrap: function wrap(html) {\n          var isFunction = jQuery.isFunction(html);\n          return this.each(function (i) {\n            jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\n          });\n        },\n        unwrap: function unwrap() {\n          return this.parent().each(function () {\n            if (!jQuery.nodeName(this, \"body\")) {\n              jQuery(this).replaceWith(this.childNodes);\n            }\n          }).end();\n        },\n        append: function append() {\n          return this.domManip(arguments, true, function (elem) {\n            if (this.nodeType === 1) {\n              this.appendChild(elem);\n            }\n          });\n        },\n        prepend: function prepend() {\n          return this.domManip(arguments, true, function (elem) {\n            if (this.nodeType === 1) {\n              this.insertBefore(elem, this.firstChild);\n            }\n          });\n        },\n        before: function before() {\n          if (this[0] && this[0].parentNode) {\n            return this.domManip(arguments, false, function (elem) {\n              this.parentNode.insertBefore(elem, this);\n            });\n          } else if (arguments.length) {\n            var set = jQuery.clean(arguments);\n            set.push.apply(set, this.toArray());\n            return this.pushStack(set, \"before\", arguments);\n          }\n        },\n        after: function after() {\n          if (this[0] && this[0].parentNode) {\n            return this.domManip(arguments, false, function (elem) {\n              this.parentNode.insertBefore(elem, this.nextSibling);\n            });\n          } else if (arguments.length) {\n            var set = this.pushStack(this, \"after\", arguments);\n            set.push.apply(set, jQuery.clean(arguments));\n            return set;\n          }\n        },\n        // keepData is for internal use only--do not document\n        remove: function remove(selector, keepData) {\n          for (var i = 0, elem; (elem = this[i]) != null; i++) {\n            if (!selector || jQuery.filter(selector, [elem]).length) {\n              if (!keepData && elem.nodeType === 1) {\n                jQuery.cleanData(elem.getElementsByTagName(\"*\"));\n                jQuery.cleanData([elem]);\n              }\n\n              if (elem.parentNode) {\n                elem.parentNode.removeChild(elem);\n              }\n            }\n          }\n\n          return this;\n        },\n        empty: function empty() {\n          for (var i = 0, elem; (elem = this[i]) != null; i++) {\n            // Remove element nodes and prevent memory leaks\n            if (elem.nodeType === 1) {\n              jQuery.cleanData(elem.getElementsByTagName(\"*\"));\n            } // Remove any remaining nodes\n\n\n            while (elem.firstChild) {\n              elem.removeChild(elem.firstChild);\n            }\n          }\n\n          return this;\n        },\n        clone: function clone(dataAndEvents, deepDataAndEvents) {\n          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n          return this.map(function () {\n            return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n          });\n        },\n        html: function html(value) {\n          return jQuery.access(this, function (value) {\n            var elem = this[0] || {},\n                i = 0,\n                l = this.length;\n\n            if (value === undefined) {\n              return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, \"\") : null;\n            }\n\n            if (typeof value === \"string\" && !rnoInnerhtml.test(value) && (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n              value = value.replace(rxhtmlTag, \"<$1></$2>\");\n\n              try {\n                for (; i < l; i++) {\n                  // Remove element nodes and prevent memory leaks\n                  elem = this[i] || {};\n\n                  if (elem.nodeType === 1) {\n                    jQuery.cleanData(elem.getElementsByTagName(\"*\"));\n                    elem.innerHTML = value;\n                  }\n                }\n\n                elem = 0; // If using innerHTML throws an exception, use the fallback method\n              } catch (e) {}\n            }\n\n            if (elem) {\n              this.empty().append(value);\n            }\n          }, null, value, arguments.length);\n        },\n        replaceWith: function replaceWith(value) {\n          if (this[0] && this[0].parentNode) {\n            // Make sure that the elements are removed from the DOM before they are inserted\n            // this can help fix replacing a parent with child elements\n            if (jQuery.isFunction(value)) {\n              return this.each(function (i) {\n                var self = jQuery(this),\n                    old = self.html();\n                self.replaceWith(value.call(this, i, old));\n              });\n            }\n\n            if (typeof value !== \"string\") {\n              value = jQuery(value).detach();\n            }\n\n            return this.each(function () {\n              var next = this.nextSibling,\n                  parent = this.parentNode;\n              jQuery(this).remove();\n\n              if (next) {\n                jQuery(next).before(value);\n              } else {\n                jQuery(parent).append(value);\n              }\n            });\n          } else {\n            return this.length ? this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), \"replaceWith\", value) : this;\n          }\n        },\n        detach: function detach(selector) {\n          return this.remove(selector, true);\n        },\n        domManip: function domManip(args, table, callback) {\n          var results,\n              first,\n              fragment,\n              parent,\n              value = args[0],\n              scripts = []; // We can't cloneNode fragments that contain checked, in WebKit\n\n          if (!jQuery.support.checkClone && arguments.length === 3 && typeof value === \"string\" && rchecked.test(value)) {\n            return this.each(function () {\n              jQuery(this).domManip(args, table, callback, true);\n            });\n          }\n\n          if (jQuery.isFunction(value)) {\n            return this.each(function (i) {\n              var self = jQuery(this);\n              args[0] = value.call(this, i, table ? self.html() : undefined);\n              self.domManip(args, table, callback);\n            });\n          }\n\n          if (this[0]) {\n            parent = value && value.parentNode; // If we're in a fragment, just use that instead of building a new one\n\n            if (jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length) {\n              results = {\n                fragment: parent\n              };\n            } else {\n              results = jQuery.buildFragment(args, this, scripts);\n            }\n\n            fragment = results.fragment;\n\n            if (fragment.childNodes.length === 1) {\n              first = fragment = fragment.firstChild;\n            } else {\n              first = fragment.firstChild;\n            }\n\n            if (first) {\n              table = table && jQuery.nodeName(first, \"tr\");\n\n              for (var i = 0, l = this.length, lastIndex = l - 1; i < l; i++) {\n                callback.call(table ? root(this[i], first) : this[i], // Make sure that we do not leak memory by inadvertently discarding\n                // the original fragment (which might have attached data) instead of\n                // using it; in addition, use the original fragment object for the last\n                // item instead of first because it can end up being emptied incorrectly\n                // in certain situations (Bug #8070).\n                // Fragments from the fragment cache must always be cloned and never used\n                // in place.\n                results.cacheable || l > 1 && i < lastIndex ? jQuery.clone(fragment, true, true) : fragment);\n              }\n            }\n\n            if (scripts.length) {\n              jQuery.each(scripts, function (i, elem) {\n                if (elem.src) {\n                  jQuery.ajax({\n                    type: \"GET\",\n                    global: false,\n                    url: elem.src,\n                    async: false,\n                    dataType: \"script\"\n                  });\n                } else {\n                  jQuery.globalEval((elem.text || elem.textContent || elem.innerHTML || \"\").replace(rcleanScript, \"/*$0*/\"));\n                }\n\n                if (elem.parentNode) {\n                  elem.parentNode.removeChild(elem);\n                }\n              });\n            }\n          }\n\n          return this;\n        }\n      });\n\n      function root(elem, cur) {\n        return jQuery.nodeName(elem, \"table\") ? elem.getElementsByTagName(\"tbody\")[0] || elem.appendChild(elem.ownerDocument.createElement(\"tbody\")) : elem;\n      }\n\n      function cloneCopyEvent(src, dest) {\n        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {\n          return;\n        }\n\n        var type,\n            i,\n            l,\n            oldData = jQuery._data(src),\n            curData = jQuery._data(dest, oldData),\n            events = oldData.events;\n\n        if (events) {\n          delete curData.handle;\n          curData.events = {};\n\n          for (type in events) {\n            for (i = 0, l = events[type].length; i < l; i++) {\n              jQuery.event.add(dest, type, events[type][i]);\n            }\n          }\n        } // make the cloned public data object a copy from the original\n\n\n        if (curData.data) {\n          curData.data = jQuery.extend({}, curData.data);\n        }\n      }\n\n      function cloneFixAttributes(src, dest) {\n        var nodeName; // We do not need to do anything for non-Elements\n\n        if (dest.nodeType !== 1) {\n          return;\n        } // clearAttributes removes the attributes, which we don't want,\n        // but also removes the attachEvent events, which we *do* want\n\n\n        if (dest.clearAttributes) {\n          dest.clearAttributes();\n        } // mergeAttributes, in contrast, only merges back on the\n        // original attributes, not the events\n\n\n        if (dest.mergeAttributes) {\n          dest.mergeAttributes(src);\n        }\n\n        nodeName = dest.nodeName.toLowerCase(); // IE6-8 fail to clone children inside object elements that use\n        // the proprietary classid attribute value (rather than the type\n        // attribute) to identify the type of content to display\n\n        if (nodeName === \"object\") {\n          dest.outerHTML = src.outerHTML;\n        } else if (nodeName === \"input\" && (src.type === \"checkbox\" || src.type === \"radio\")) {\n          // IE6-8 fails to persist the checked state of a cloned checkbox\n          // or radio button. Worse, IE6-7 fail to give the cloned element\n          // a checked appearance if the defaultChecked value isn't also set\n          if (src.checked) {\n            dest.defaultChecked = dest.checked = src.checked;\n          } // IE6-7 get confused and end up setting the value of a cloned\n          // checkbox/radio button to an empty string instead of \"on\"\n\n\n          if (dest.value !== src.value) {\n            dest.value = src.value;\n          } // IE6-8 fails to return the selected option to the default selected\n          // state when cloning options\n\n        } else if (nodeName === \"option\") {\n          dest.selected = src.defaultSelected; // IE6-8 fails to set the defaultValue to the correct value when\n          // cloning other types of input fields\n        } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n          dest.defaultValue = src.defaultValue; // IE blanks contents when cloning scripts\n        } else if (nodeName === \"script\" && dest.text !== src.text) {\n          dest.text = src.text;\n        } // Event data gets referenced instead of copied if the expando\n        // gets copied too\n\n\n        dest.removeAttribute(jQuery.expando); // Clear flags for bubbling special change/submit events, they must\n        // be reattached when the newly cloned events are first activated\n\n        dest.removeAttribute(\"_submit_attached\");\n        dest.removeAttribute(\"_change_attached\");\n      }\n\n      jQuery.buildFragment = function (args, nodes, scripts) {\n        var fragment,\n            cacheable,\n            cacheresults,\n            doc,\n            first = args[0]; // nodes may contain either an explicit document object,\n        // a jQuery collection or context object.\n        // If nodes[0] contains a valid object to assign to doc\n\n        if (nodes && nodes[0]) {\n          doc = nodes[0].ownerDocument || nodes[0];\n        } // Ensure that an attr object doesn't incorrectly stand in as a document object\n        // Chrome and Firefox seem to allow this to occur and will throw exception\n        // Fixes #8950\n\n\n        if (!doc.createDocumentFragment) {\n          doc = document;\n        } // Only cache \"small\" (1/2 KB) HTML strings that are associated with the main document\n        // Cloning options loses the selected state, so don't cache them\n        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment\n        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache\n        // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501\n\n\n        if (args.length === 1 && typeof first === \"string\" && first.length < 512 && doc === document && first.charAt(0) === \"<\" && !rnocache.test(first) && (jQuery.support.checkClone || !rchecked.test(first)) && (jQuery.support.html5Clone || !rnoshimcache.test(first))) {\n          cacheable = true;\n          cacheresults = jQuery.fragments[first];\n\n          if (cacheresults && cacheresults !== 1) {\n            fragment = cacheresults;\n          }\n        }\n\n        if (!fragment) {\n          fragment = doc.createDocumentFragment();\n          jQuery.clean(args, doc, fragment, scripts);\n        }\n\n        if (cacheable) {\n          jQuery.fragments[first] = cacheresults ? fragment : 1;\n        }\n\n        return {\n          fragment: fragment,\n          cacheable: cacheable\n        };\n      };\n\n      jQuery.fragments = {};\n      jQuery.each({\n        appendTo: \"append\",\n        prependTo: \"prepend\",\n        insertBefore: \"before\",\n        insertAfter: \"after\",\n        replaceAll: \"replaceWith\"\n      }, function (name, original) {\n        jQuery.fn[name] = function (selector) {\n          var ret = [],\n              insert = jQuery(selector),\n              parent = this.length === 1 && this[0].parentNode;\n\n          if (parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {\n            insert[original](this[0]);\n            return this;\n          } else {\n            for (var i = 0, l = insert.length; i < l; i++) {\n              var elems = (i > 0 ? this.clone(true) : this).get();\n              jQuery(insert[i])[original](elems);\n              ret = ret.concat(elems);\n            }\n\n            return this.pushStack(ret, name, insert.selector);\n          }\n        };\n      });\n\n      function getAll(elem) {\n        if (typeof elem.getElementsByTagName !== \"undefined\") {\n          return elem.getElementsByTagName(\"*\");\n        } else if (typeof elem.querySelectorAll !== \"undefined\") {\n          return elem.querySelectorAll(\"*\");\n        } else {\n          return [];\n        }\n      } // Used in clean, fixes the defaultChecked property\n\n\n      function fixDefaultChecked(elem) {\n        if (elem.type === \"checkbox\" || elem.type === \"radio\") {\n          elem.defaultChecked = elem.checked;\n        }\n      } // Finds all inputs and passes them to fixDefaultChecked\n\n\n      function findInputs(elem) {\n        var nodeName = (elem.nodeName || \"\").toLowerCase();\n\n        if (nodeName === \"input\") {\n          fixDefaultChecked(elem); // Skip scripts, get other children\n        } else if (nodeName !== \"script\" && typeof elem.getElementsByTagName !== \"undefined\") {\n          jQuery.grep(elem.getElementsByTagName(\"input\"), fixDefaultChecked);\n        }\n      } // Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js\n\n\n      function shimCloneNode(elem) {\n        var div = document.createElement(\"div\");\n        safeFragment.appendChild(div);\n        div.innerHTML = elem.outerHTML;\n        return div.firstChild;\n      }\n\n      jQuery.extend({\n        clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n          var srcElements,\n              destElements,\n              i,\n              // IE<=8 does not properly clone detached, unknown element nodes\n          clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test(\"<\" + elem.nodeName + \">\") ? elem.cloneNode(true) : shimCloneNode(elem);\n\n          if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n            // IE copies events bound via attachEvent when using cloneNode.\n            // Calling detachEvent on the clone will also remove the events\n            // from the original. In order to get around this, we use some\n            // proprietary methods to clear the events. Thanks to MooTools\n            // guys for this hotness.\n            cloneFixAttributes(elem, clone); // Using Sizzle here is crazy slow, so we use getElementsByTagName instead\n\n            srcElements = getAll(elem);\n            destElements = getAll(clone); // Weird iteration because IE will replace the length property\n            // with an element if you are cloning the body and one of the\n            // elements on the page has a name or id of \"length\"\n\n            for (i = 0; srcElements[i]; ++i) {\n              // Ensure that the destination node is not null; Fixes #9587\n              if (destElements[i]) {\n                cloneFixAttributes(srcElements[i], destElements[i]);\n              }\n            }\n          } // Copy the events from the original to the clone\n\n\n          if (dataAndEvents) {\n            cloneCopyEvent(elem, clone);\n\n            if (deepDataAndEvents) {\n              srcElements = getAll(elem);\n              destElements = getAll(clone);\n\n              for (i = 0; srcElements[i]; ++i) {\n                cloneCopyEvent(srcElements[i], destElements[i]);\n              }\n            }\n          }\n\n          srcElements = destElements = null; // Return the cloned set\n\n          return clone;\n        },\n        clean: function clean(elems, context, fragment, scripts) {\n          var checkScriptType,\n              script,\n              j,\n              ret = [];\n          context = context || document; // !context.createElement fails in IE with an error but returns typeof 'object'\n\n          if (typeof context.createElement === \"undefined\") {\n            context = context.ownerDocument || context[0] && context[0].ownerDocument || document;\n          }\n\n          for (var i = 0, elem; (elem = elems[i]) != null; i++) {\n            if (typeof elem === \"number\") {\n              elem += \"\";\n            }\n\n            if (!elem) {\n              continue;\n            } // Convert html string into DOM nodes\n\n\n            if (typeof elem === \"string\") {\n              if (!rhtml.test(elem)) {\n                elem = context.createTextNode(elem);\n              } else {\n                // Fix \"XHTML\"-style tags in all browsers\n                elem = elem.replace(rxhtmlTag, \"<$1></$2>\"); // Trim whitespace, otherwise indexOf won't work as expected\n\n                var tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase(),\n                    wrap = wrapMap[tag] || wrapMap._default,\n                    depth = wrap[0],\n                    div = context.createElement(\"div\"),\n                    safeChildNodes = safeFragment.childNodes,\n                    remove; // Append wrapper element to unknown element safe doc fragment\n\n                if (context === document) {\n                  // Use the fragment we've already created for this document\n                  safeFragment.appendChild(div);\n                } else {\n                  // Use a fragment created with the owner document\n                  createSafeFragment(context).appendChild(div);\n                } // Go to html and back, then peel off extra wrappers\n\n\n                div.innerHTML = wrap[1] + elem + wrap[2]; // Move to the right depth\n\n                while (depth--) {\n                  div = div.lastChild;\n                } // Remove IE's autoinserted <tbody> from table fragments\n\n\n                if (!jQuery.support.tbody) {\n                  // String was a <table>, *may* have spurious <tbody>\n                  var hasBody = rtbody.test(elem),\n                      tbody = tag === \"table\" && !hasBody ? div.firstChild && div.firstChild.childNodes : // String was a bare <thead> or <tfoot>\n                  wrap[1] === \"<table>\" && !hasBody ? div.childNodes : [];\n\n                  for (j = tbody.length - 1; j >= 0; --j) {\n                    if (jQuery.nodeName(tbody[j], \"tbody\") && !tbody[j].childNodes.length) {\n                      tbody[j].parentNode.removeChild(tbody[j]);\n                    }\n                  }\n                } // IE completely kills leading whitespace when innerHTML is used\n\n\n                if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {\n                  div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);\n                }\n\n                elem = div.childNodes; // Clear elements from DocumentFragment (safeFragment or otherwise)\n                // to avoid hoarding elements. Fixes #11356\n\n                if (div) {\n                  div.parentNode.removeChild(div); // Guard against -1 index exceptions in FF3.6\n\n                  if (safeChildNodes.length > 0) {\n                    remove = safeChildNodes[safeChildNodes.length - 1];\n\n                    if (remove && remove.parentNode) {\n                      remove.parentNode.removeChild(remove);\n                    }\n                  }\n                }\n              }\n            } // Resets defaultChecked for any radios and checkboxes\n            // about to be appended to the DOM in IE 6/7 (#8060)\n\n\n            var len;\n\n            if (!jQuery.support.appendChecked) {\n              if (elem[0] && typeof (len = elem.length) === \"number\") {\n                for (j = 0; j < len; j++) {\n                  findInputs(elem[j]);\n                }\n              } else {\n                findInputs(elem);\n              }\n            }\n\n            if (elem.nodeType) {\n              ret.push(elem);\n            } else {\n              ret = jQuery.merge(ret, elem);\n            }\n          }\n\n          if (fragment) {\n            checkScriptType = function checkScriptType(elem) {\n              return !elem.type || rscriptType.test(elem.type);\n            };\n\n            for (i = 0; ret[i]; i++) {\n              script = ret[i];\n\n              if (scripts && jQuery.nodeName(script, \"script\") && (!script.type || rscriptType.test(script.type))) {\n                scripts.push(script.parentNode ? script.parentNode.removeChild(script) : script);\n              } else {\n                if (script.nodeType === 1) {\n                  var jsTags = jQuery.grep(script.getElementsByTagName(\"script\"), checkScriptType);\n                  ret.splice.apply(ret, [i + 1, 0].concat(jsTags));\n                }\n\n                fragment.appendChild(script);\n              }\n            }\n          }\n\n          return ret;\n        },\n        cleanData: function cleanData(elems) {\n          var data,\n              id,\n              cache = jQuery.cache,\n              special = jQuery.event.special,\n              deleteExpando = jQuery.support.deleteExpando;\n\n          for (var i = 0, elem; (elem = elems[i]) != null; i++) {\n            if (elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) {\n              continue;\n            }\n\n            id = elem[jQuery.expando];\n\n            if (id) {\n              data = cache[id];\n\n              if (data && data.events) {\n                for (var type in data.events) {\n                  if (special[type]) {\n                    jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead\n                  } else {\n                    jQuery.removeEvent(elem, type, data.handle);\n                  }\n                } // Null the DOM reference to avoid IE6/7/8 leak (#7054)\n\n\n                if (data.handle) {\n                  data.handle.elem = null;\n                }\n              }\n\n              if (deleteExpando) {\n                delete elem[jQuery.expando];\n              } else if (elem.removeAttribute) {\n                elem.removeAttribute(jQuery.expando);\n              }\n\n              delete cache[id];\n            }\n          }\n        }\n      });\n      var ralpha = /alpha\\([^)]*\\)/i,\n          ropacity = /opacity=([^)]*)/,\n          // fixed for IE9, see #8346\n      rupper = /([A-Z]|^ms)/g,\n          rnum = /^[\\-+]?(?:\\d*\\.)?\\d+$/i,\n          rnumnonpx = /^-?(?:\\d*\\.)?\\d+(?!px)[^\\d\\s]+$/i,\n          rrelNum = /^([\\-+])=([\\-+.\\de]+)/,\n          rmargin = /^margin/,\n          cssShow = {\n        position: \"absolute\",\n        visibility: \"hidden\",\n        display: \"block\"\n      },\n          // order is important!\n      cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n          curCSS,\n          getComputedStyle,\n          currentStyle;\n\n      jQuery.fn.css = function (name, value) {\n        return jQuery.access(this, function (elem, name, value) {\n          return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n        }, name, value, arguments.length > 1);\n      };\n\n      jQuery.extend({\n        // Add in style property hooks for overriding the default\n        // behavior of getting and setting a style property\n        cssHooks: {\n          opacity: {\n            get: function get(elem, computed) {\n              if (computed) {\n                // We should always get a number back from opacity\n                var ret = curCSS(elem, \"opacity\");\n                return ret === \"\" ? \"1\" : ret;\n              } else {\n                return elem.style.opacity;\n              }\n            }\n          }\n        },\n        // Exclude the following css properties to add px\n        cssNumber: {\n          \"fillOpacity\": true,\n          \"fontWeight\": true,\n          \"lineHeight\": true,\n          \"opacity\": true,\n          \"orphans\": true,\n          \"widows\": true,\n          \"zIndex\": true,\n          \"zoom\": true\n        },\n        // Add in properties whose names you wish to fix before\n        // setting or getting the value\n        cssProps: {\n          // normalize float css property\n          \"float\": jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n        },\n        // Get and set the style property on a DOM Node\n        style: function style(elem, name, value, extra) {\n          // Don't set styles on text and comment nodes\n          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n            return;\n          } // Make sure that we're working with the right name\n\n\n          var ret,\n              type,\n              origName = jQuery.camelCase(name),\n              style = elem.style,\n              hooks = jQuery.cssHooks[origName];\n          name = jQuery.cssProps[origName] || origName; // Check if we're setting a value\n\n          if (value !== undefined) {\n            type = typeof value; // convert relative number strings (+= or -=) to relative numbers. #7345\n\n            if (type === \"string\" && (ret = rrelNum.exec(value))) {\n              value = +(ret[1] + 1) * +ret[2] + parseFloat(jQuery.css(elem, name)); // Fixes bug #9237\n\n              type = \"number\";\n            } // Make sure that NaN and null values aren't set. See: #7116\n\n\n            if (value == null || type === \"number\" && isNaN(value)) {\n              return;\n            } // If a number was passed in, add 'px' to the (except for certain CSS properties)\n\n\n            if (type === \"number\" && !jQuery.cssNumber[origName]) {\n              value += \"px\";\n            } // If a hook was provided, use that value, otherwise just set the specified value\n\n\n            if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value)) !== undefined) {\n              // Wrapped to prevent IE from throwing errors when 'invalid' values are provided\n              // Fixes bug #5509\n              try {\n                style[name] = value;\n              } catch (e) {}\n            }\n          } else {\n            // If a hook was provided get the non-computed value from there\n            if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n              return ret;\n            } // Otherwise just get the value from the style object\n\n\n            return style[name];\n          }\n        },\n        css: function css(elem, name, extra) {\n          var ret, hooks; // Make sure that we're working with the right name\n\n          name = jQuery.camelCase(name);\n          hooks = jQuery.cssHooks[name];\n          name = jQuery.cssProps[name] || name; // cssFloat needs a special treatment\n\n          if (name === \"cssFloat\") {\n            name = \"float\";\n          } // If a hook was provided get the computed value from there\n\n\n          if (hooks && \"get\" in hooks && (ret = hooks.get(elem, true, extra)) !== undefined) {\n            return ret; // Otherwise, if a way to get the computed value exists, use that\n          } else if (curCSS) {\n            return curCSS(elem, name);\n          }\n        },\n        // A method for quickly swapping in/out CSS properties to get correct calculations\n        swap: function swap(elem, options, callback) {\n          var old = {},\n              ret,\n              name; // Remember the old values, and insert the new ones\n\n          for (name in options) {\n            old[name] = elem.style[name];\n            elem.style[name] = options[name];\n          }\n\n          ret = callback.call(elem); // Revert the old values\n\n          for (name in options) {\n            elem.style[name] = old[name];\n          }\n\n          return ret;\n        }\n      }); // DEPRECATED in 1.3, Use jQuery.css() instead\n\n      jQuery.curCSS = jQuery.css;\n\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        getComputedStyle = function getComputedStyle(elem, name) {\n          var ret,\n              defaultView,\n              computedStyle,\n              width,\n              style = elem.style;\n          name = name.replace(rupper, \"-$1\").toLowerCase();\n\n          if ((defaultView = elem.ownerDocument.defaultView) && (computedStyle = defaultView.getComputedStyle(elem, null))) {\n            ret = computedStyle.getPropertyValue(name);\n\n            if (ret === \"\" && !jQuery.contains(elem.ownerDocument.documentElement, elem)) {\n              ret = jQuery.style(elem, name);\n            }\n          } // A tribute to the \"awesome hack by Dean Edwards\"\n          // WebKit uses \"computed value (percentage if specified)\" instead of \"used value\" for margins\n          // which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\n\n          if (!jQuery.support.pixelMargin && computedStyle && rmargin.test(name) && rnumnonpx.test(ret)) {\n            width = style.width;\n            style.width = ret;\n            ret = computedStyle.width;\n            style.width = width;\n          }\n\n          return ret;\n        };\n      }\n\n      if (document.documentElement.currentStyle) {\n        currentStyle = function currentStyle(elem, name) {\n          var left,\n              rsLeft,\n              uncomputed,\n              ret = elem.currentStyle && elem.currentStyle[name],\n              style = elem.style; // Avoid setting ret to empty string here\n          // so we don't default to auto\n\n          if (ret == null && style && (uncomputed = style[name])) {\n            ret = uncomputed;\n          } // From the awesome hack by Dean Edwards\n          // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n          // If we're not dealing with a regular pixel number\n          // but a number that has a weird ending, we need to convert it to pixels\n\n\n          if (rnumnonpx.test(ret)) {\n            // Remember the original values\n            left = style.left;\n            rsLeft = elem.runtimeStyle && elem.runtimeStyle.left; // Put in the new values to get a computed value out\n\n            if (rsLeft) {\n              elem.runtimeStyle.left = elem.currentStyle.left;\n            }\n\n            style.left = name === \"fontSize\" ? \"1em\" : ret;\n            ret = style.pixelLeft + \"px\"; // Revert the changed values\n\n            style.left = left;\n\n            if (rsLeft) {\n              elem.runtimeStyle.left = rsLeft;\n            }\n          }\n\n          return ret === \"\" ? \"auto\" : ret;\n        };\n      }\n\n      curCSS = getComputedStyle || currentStyle;\n\n      function getWidthOrHeight(elem, name, extra) {\n        // Start with offset property\n        var val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n            i = name === \"width\" ? 1 : 0,\n            len = 4;\n\n        if (val > 0) {\n          if (extra !== \"border\") {\n            for (; i < len; i += 2) {\n              if (!extra) {\n                val -= parseFloat(jQuery.css(elem, \"padding\" + cssExpand[i])) || 0;\n              }\n\n              if (extra === \"margin\") {\n                val += parseFloat(jQuery.css(elem, extra + cssExpand[i])) || 0;\n              } else {\n                val -= parseFloat(jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\")) || 0;\n              }\n            }\n          }\n\n          return val + \"px\";\n        } // Fall back to computed then uncomputed css if necessary\n\n\n        val = curCSS(elem, name);\n\n        if (val < 0 || val == null) {\n          val = elem.style[name];\n        } // Computed unit is not pixels. Stop here and return.\n\n\n        if (rnumnonpx.test(val)) {\n          return val;\n        } // Normalize \"\", auto, and prepare for extra\n\n\n        val = parseFloat(val) || 0; // Add padding, border, margin\n\n        if (extra) {\n          for (; i < len; i += 2) {\n            val += parseFloat(jQuery.css(elem, \"padding\" + cssExpand[i])) || 0;\n\n            if (extra !== \"padding\") {\n              val += parseFloat(jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\")) || 0;\n            }\n\n            if (extra === \"margin\") {\n              val += parseFloat(jQuery.css(elem, extra + cssExpand[i])) || 0;\n            }\n          }\n        }\n\n        return val + \"px\";\n      }\n\n      jQuery.each([\"height\", \"width\"], function (i, name) {\n        jQuery.cssHooks[name] = {\n          get: function get(elem, computed, extra) {\n            if (computed) {\n              if (elem.offsetWidth !== 0) {\n                return getWidthOrHeight(elem, name, extra);\n              } else {\n                return jQuery.swap(elem, cssShow, function () {\n                  return getWidthOrHeight(elem, name, extra);\n                });\n              }\n            }\n          },\n          set: function set(elem, value) {\n            return rnum.test(value) ? value + \"px\" : value;\n          }\n        };\n      });\n\n      if (!jQuery.support.opacity) {\n        jQuery.cssHooks.opacity = {\n          get: function get(elem, computed) {\n            // IE uses filters for opacity\n            return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\") ? parseFloat(RegExp.$1) / 100 + \"\" : computed ? \"1\" : \"\";\n          },\n          set: function set(elem, value) {\n            var style = elem.style,\n                currentStyle = elem.currentStyle,\n                opacity = jQuery.isNumeric(value) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n                filter = currentStyle && currentStyle.filter || style.filter || \"\"; // IE has trouble with opacity if it does not have layout\n            // Force it by setting the zoom level\n\n            style.zoom = 1; // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n\n            if (value >= 1 && jQuery.trim(filter.replace(ralpha, \"\")) === \"\") {\n              // Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n              // if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n              // style.removeAttribute is IE Only, but so apparently is this code path...\n              style.removeAttribute(\"filter\"); // if there there is no filter style applied in a css rule, we are done\n\n              if (currentStyle && !currentStyle.filter) {\n                return;\n              }\n            } // otherwise, set new filter values\n\n\n            style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + \" \" + opacity;\n          }\n        };\n      }\n\n      jQuery(function () {\n        // This hook cannot be added until DOM ready because the support test\n        // for it is not run until after DOM ready\n        if (!jQuery.support.reliableMarginRight) {\n          jQuery.cssHooks.marginRight = {\n            get: function get(elem, computed) {\n              // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n              // Work around by temporarily setting element display to inline-block\n              return jQuery.swap(elem, {\n                \"display\": \"inline-block\"\n              }, function () {\n                if (computed) {\n                  return curCSS(elem, \"margin-right\");\n                } else {\n                  return elem.style.marginRight;\n                }\n              });\n            }\n          };\n        }\n      });\n\n      if (jQuery.expr && jQuery.expr.filters) {\n        jQuery.expr.filters.hidden = function (elem) {\n          var width = elem.offsetWidth,\n              height = elem.offsetHeight;\n          return width === 0 && height === 0 || !jQuery.support.reliableHiddenOffsets && (elem.style && elem.style.display || jQuery.css(elem, \"display\")) === \"none\";\n        };\n\n        jQuery.expr.filters.visible = function (elem) {\n          return !jQuery.expr.filters.hidden(elem);\n        };\n      } // These hooks are used by animate to expand properties\n\n\n      jQuery.each({\n        margin: \"\",\n        padding: \"\",\n        border: \"Width\"\n      }, function (prefix, suffix) {\n        jQuery.cssHooks[prefix + suffix] = {\n          expand: function expand(value) {\n            var i,\n                // assumes a single number if not a string\n            parts = typeof value === \"string\" ? value.split(\" \") : [value],\n                expanded = {};\n\n            for (i = 0; i < 4; i++) {\n              expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n            }\n\n            return expanded;\n          }\n        };\n      });\n      var r20 = /%20/g,\n          rbracket = /\\[\\]$/,\n          rCRLF = /\\r?\\n/g,\n          rhash = /#.*$/,\n          rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg,\n          // IE leaves an \\r character at EOL\n      rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,\n          // #7653, #8125, #8152: local protocol detection\n      rlocalProtocol = /^(?:about|app|app\\-storage|.+\\-extension|file|res|widget):$/,\n          rnoContent = /^(?:GET|HEAD)$/,\n          rprotocol = /^\\/\\//,\n          rquery = /\\?/,\n          rscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n          rselectTextarea = /^(?:select|textarea)/i,\n          rspacesAjax = /\\s+/,\n          rts = /([?&])_=[^&]*/,\n          rurl = /^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+))?)?/,\n          // Keep a copy of the old load method\n      _load = jQuery.fn.load,\n\n      /* Prefilters\n       * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n       * 2) These are called:\n       *    - BEFORE asking for a transport\n       *    - AFTER param serialization (s.data is a string if s.processData is true)\n       * 3) key is the dataType\n       * 4) the catchall symbol \"*\" can be used\n       * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n       */\n      prefilters = {},\n\n      /* Transports bindings\n       * 1) key is the dataType\n       * 2) the catchall symbol \"*\" can be used\n       * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n       */\n      transports = {},\n          // Document location\n      ajaxLocation,\n          // Document location segments\n      ajaxLocParts,\n          // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n      allTypes = [\"*/\"] + [\"*\"]; // #8138, IE may throw an exception when accessing\n      // a field from window.location if document.domain has been set\n\n      try {\n        ajaxLocation = location.href;\n      } catch (e) {\n        // Use the href attribute of an A element\n        // since IE will modify it given document.location\n        ajaxLocation = document.createElement(\"a\");\n        ajaxLocation.href = \"\";\n        ajaxLocation = ajaxLocation.href;\n      } // Segment location into parts\n\n\n      ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n      function addToPrefiltersOrTransports(structure) {\n        // dataTypeExpression is optional and defaults to \"*\"\n        return function (dataTypeExpression, func) {\n          if (typeof dataTypeExpression !== \"string\") {\n            func = dataTypeExpression;\n            dataTypeExpression = \"*\";\n          }\n\n          if (jQuery.isFunction(func)) {\n            var dataTypes = dataTypeExpression.toLowerCase().split(rspacesAjax),\n                i = 0,\n                length = dataTypes.length,\n                dataType,\n                list,\n                placeBefore; // For each dataType in the dataTypeExpression\n\n            for (; i < length; i++) {\n              dataType = dataTypes[i]; // We control if we're asked to add before\n              // any existing element\n\n              placeBefore = /^\\+/.test(dataType);\n\n              if (placeBefore) {\n                dataType = dataType.substr(1) || \"*\";\n              }\n\n              list = structure[dataType] = structure[dataType] || []; // then we add to the structure accordingly\n\n              list[placeBefore ? \"unshift\" : \"push\"](func);\n            }\n          }\n        };\n      } // Base inspection function for prefilters and transports\n\n\n      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, dataType\n      /* internal */\n      , inspected\n      /* internal */\n      ) {\n        dataType = dataType || options.dataTypes[0];\n        inspected = inspected || {};\n        inspected[dataType] = true;\n        var list = structure[dataType],\n            i = 0,\n            length = list ? list.length : 0,\n            executeOnly = structure === prefilters,\n            selection;\n\n        for (; i < length && (executeOnly || !selection); i++) {\n          selection = list[i](options, originalOptions, jqXHR); // If we got redirected to another dataType\n          // we try there if executing only and not done already\n\n          if (typeof selection === \"string\") {\n            if (!executeOnly || inspected[selection]) {\n              selection = undefined;\n            } else {\n              options.dataTypes.unshift(selection);\n              selection = inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, selection, inspected);\n            }\n          }\n        } // If we're only executing or nothing was selected\n        // we try the catchall dataType if not done already\n\n\n        if ((executeOnly || !selection) && !inspected[\"*\"]) {\n          selection = inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, \"*\", inspected);\n        } // unnecessary when only executing (prefilters)\n        // but it'll be ignored by the caller in that case\n\n\n        return selection;\n      } // A special extend for ajax options\n      // that takes \"flat\" options (not to be deep extended)\n      // Fixes #9887\n\n\n      function ajaxExtend(target, src) {\n        var key,\n            deep,\n            flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n        for (key in src) {\n          if (src[key] !== undefined) {\n            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n          }\n        }\n\n        if (deep) {\n          jQuery.extend(true, target, deep);\n        }\n      }\n\n      jQuery.fn.extend({\n        load: function load(url, params, callback) {\n          if (typeof url !== \"string\" && _load) {\n            return _load.apply(this, arguments); // Don't do a request if no elements are being requested\n          } else if (!this.length) {\n            return this;\n          }\n\n          var off = url.indexOf(\" \");\n\n          if (off >= 0) {\n            var selector = url.slice(off, url.length);\n            url = url.slice(0, off);\n          } // Default to a GET request\n\n\n          var type = \"GET\"; // If the second parameter was provided\n\n          if (params) {\n            // If it's a function\n            if (jQuery.isFunction(params)) {\n              // We assume that it's the callback\n              callback = params;\n              params = undefined; // Otherwise, build a param string\n            } else if (typeof params === \"object\") {\n              params = jQuery.param(params, jQuery.ajaxSettings.traditional);\n              type = \"POST\";\n            }\n          }\n\n          var self = this; // Request the remote document\n\n          jQuery.ajax({\n            url: url,\n            type: type,\n            dataType: \"html\",\n            data: params,\n            // Complete callback (responseText is used internally)\n            complete: function complete(jqXHR, status, responseText) {\n              // Store the response as specified by the jqXHR object\n              responseText = jqXHR.responseText; // If successful, inject the HTML into all the matched elements\n\n              if (jqXHR.isResolved()) {\n                // #4825: Get the actual response in case\n                // a dataFilter is present in ajaxSettings\n                jqXHR.done(function (r) {\n                  responseText = r;\n                }); // See if a selector was specified\n\n                self.html(selector ? // Create a dummy div to hold the results\n                jQuery(\"<div>\") // inject the contents of the document in, removing the scripts\n                // to avoid any 'Permission Denied' errors in IE\n                .append(responseText.replace(rscript, \"\")) // Locate the specified elements\n                .find(selector) : // If not, just inject the full result\n                responseText);\n              }\n\n              if (callback) {\n                self.each(callback, [responseText, status, jqXHR]);\n              }\n            }\n          });\n          return this;\n        },\n        serialize: function serialize() {\n          return jQuery.param(this.serializeArray());\n        },\n        serializeArray: function serializeArray() {\n          return this.map(function () {\n            return this.elements ? jQuery.makeArray(this.elements) : this;\n          }).filter(function () {\n            return this.name && !this.disabled && (this.checked || rselectTextarea.test(this.nodeName) || rinput.test(this.type));\n          }).map(function (i, elem) {\n            var val = jQuery(this).val();\n            return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val, i) {\n              return {\n                name: elem.name,\n                value: val.replace(rCRLF, \"\\r\\n\")\n              };\n            }) : {\n              name: elem.name,\n              value: val.replace(rCRLF, \"\\r\\n\")\n            };\n          }).get();\n        }\n      }); // Attach a bunch of functions for handling common AJAX events\n\n      jQuery.each(\"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split(\" \"), function (i, o) {\n        jQuery.fn[o] = function (f) {\n          return this.on(o, f);\n        };\n      });\n      jQuery.each([\"get\", \"post\"], function (i, method) {\n        jQuery[method] = function (url, data, callback, type) {\n          // shift arguments if data argument was omitted\n          if (jQuery.isFunction(data)) {\n            type = type || callback;\n            callback = data;\n            data = undefined;\n          }\n\n          return jQuery.ajax({\n            type: method,\n            url: url,\n            data: data,\n            success: callback,\n            dataType: type\n          });\n        };\n      });\n      jQuery.extend({\n        getScript: function getScript(url, callback) {\n          return jQuery.get(url, undefined, callback, \"script\");\n        },\n        getJSON: function getJSON(url, data, callback) {\n          return jQuery.get(url, data, callback, \"json\");\n        },\n        // Creates a full fledged settings object into target\n        // with both ajaxSettings and settings fields.\n        // If target is omitted, writes into ajaxSettings.\n        ajaxSetup: function ajaxSetup(target, settings) {\n          if (settings) {\n            // Building a settings object\n            ajaxExtend(target, jQuery.ajaxSettings);\n          } else {\n            // Extending ajaxSettings\n            settings = target;\n            target = jQuery.ajaxSettings;\n          }\n\n          ajaxExtend(target, settings);\n          return target;\n        },\n        ajaxSettings: {\n          url: ajaxLocation,\n          isLocal: rlocalProtocol.test(ajaxLocParts[1]),\n          global: true,\n          type: \"GET\",\n          contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n          processData: true,\n          async: true,\n\n          /*\n          timeout: 0,\n          data: null,\n          dataType: null,\n          username: null,\n          password: null,\n          cache: null,\n          traditional: false,\n          headers: {},\n          */\n          accepts: {\n            xml: \"application/xml, text/xml\",\n            html: \"text/html\",\n            text: \"text/plain\",\n            json: \"application/json, text/javascript\",\n            \"*\": allTypes\n          },\n          contents: {\n            xml: /xml/,\n            html: /html/,\n            json: /json/\n          },\n          responseFields: {\n            xml: \"responseXML\",\n            text: \"responseText\"\n          },\n          // List of data converters\n          // 1) key format is \"source_type destination_type\" (a single space in-between)\n          // 2) the catchall symbol \"*\" can be used for source_type\n          converters: {\n            // Convert anything to text\n            \"* text\": window.String,\n            // Text to html (true = no transformation)\n            \"text html\": true,\n            // Evaluate text as a json expression\n            \"text json\": jQuery.parseJSON,\n            // Parse text as xml\n            \"text xml\": jQuery.parseXML\n          },\n          // For options that shouldn't be deep extended:\n          // you can add your own custom options here if\n          // and when you create one that shouldn't be\n          // deep extended (see ajaxExtend)\n          flatOptions: {\n            context: true,\n            url: true\n          }\n        },\n        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n        ajaxTransport: addToPrefiltersOrTransports(transports),\n        // Main method\n        ajax: function ajax(url, options) {\n          // If url is an object, simulate pre-1.5 signature\n          if (typeof url === \"object\") {\n            options = url;\n            url = undefined;\n          } // Force options to be an object\n\n\n          options = options || {};\n          var // Create the final options object\n          s = jQuery.ajaxSetup({}, options),\n              // Callbacks context\n          callbackContext = s.context || s,\n              // Context for global events\n          // It's the callbackContext if one was provided in the options\n          // and if it's a DOM node or a jQuery collection\n          globalEventContext = callbackContext !== s && (callbackContext.nodeType || callbackContext instanceof jQuery) ? jQuery(callbackContext) : jQuery.event,\n              // Deferreds\n          deferred = jQuery.Deferred(),\n              completeDeferred = jQuery.Callbacks(\"once memory\"),\n              // Status-dependent callbacks\n          statusCode = s.statusCode || {},\n              // ifModified key\n          ifModifiedKey,\n              // Headers (they are sent all at once)\n          requestHeaders = {},\n              requestHeadersNames = {},\n              // Response headers\n          responseHeadersString,\n              responseHeaders,\n              // transport\n          transport,\n              // timeout handle\n          timeoutTimer,\n              // Cross-domain detection vars\n          parts,\n              // The jqXHR state\n          state = 0,\n              // To know if global events are to be dispatched\n          fireGlobals,\n              // Loop variable\n          i,\n              // Fake xhr\n          jqXHR = {\n            readyState: 0,\n            // Caches the header\n            setRequestHeader: function setRequestHeader(name, value) {\n              if (!state) {\n                var lname = name.toLowerCase();\n                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;\n                requestHeaders[name] = value;\n              }\n\n              return this;\n            },\n            // Raw string\n            getAllResponseHeaders: function getAllResponseHeaders() {\n              return state === 2 ? responseHeadersString : null;\n            },\n            // Builds headers hashtable if needed\n            getResponseHeader: function getResponseHeader(key) {\n              var match;\n\n              if (state === 2) {\n                if (!responseHeaders) {\n                  responseHeaders = {};\n\n                  while (match = rheaders.exec(responseHeadersString)) {\n                    responseHeaders[match[1].toLowerCase()] = match[2];\n                  }\n                }\n\n                match = responseHeaders[key.toLowerCase()];\n              }\n\n              return match === undefined ? null : match;\n            },\n            // Overrides response content-type header\n            overrideMimeType: function overrideMimeType(type) {\n              if (!state) {\n                s.mimeType = type;\n              }\n\n              return this;\n            },\n            // Cancel the request\n            abort: function abort(statusText) {\n              statusText = statusText || \"abort\";\n\n              if (transport) {\n                transport.abort(statusText);\n              }\n\n              done(0, statusText);\n              return this;\n            }\n          }; // Callback for when everything is done\n          // It is defined here because jslint complains if it is declared\n          // at the end of the function (which would be more logical and readable)\n\n          function done(status, nativeStatusText, responses, headers) {\n            // Called once\n            if (state === 2) {\n              return;\n            } // State is \"done\" now\n\n\n            state = 2; // Clear timeout if it exists\n\n            if (timeoutTimer) {\n              clearTimeout(timeoutTimer);\n            } // Dereference transport for early garbage collection\n            // (no matter how long the jqXHR object will be used)\n\n\n            transport = undefined; // Cache response headers\n\n            responseHeadersString = headers || \"\"; // Set readyState\n\n            jqXHR.readyState = status > 0 ? 4 : 0;\n            var isSuccess,\n                success,\n                error,\n                statusText = nativeStatusText,\n                response = responses ? ajaxHandleResponses(s, jqXHR, responses) : undefined,\n                lastModified,\n                etag; // If successful, handle type chaining\n\n            if (status >= 200 && status < 300 || status === 304) {\n              // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n              if (s.ifModified) {\n                if (lastModified = jqXHR.getResponseHeader(\"Last-Modified\")) {\n                  jQuery.lastModified[ifModifiedKey] = lastModified;\n                }\n\n                if (etag = jqXHR.getResponseHeader(\"Etag\")) {\n                  jQuery.etag[ifModifiedKey] = etag;\n                }\n              } // If not modified\n\n\n              if (status === 304) {\n                statusText = \"notmodified\";\n                isSuccess = true; // If we have data\n              } else {\n                try {\n                  success = ajaxConvert(s, response);\n                  statusText = \"success\";\n                  isSuccess = true;\n                } catch (e) {\n                  // We have a parsererror\n                  statusText = \"parsererror\";\n                  error = e;\n                }\n              }\n            } else {\n              // We extract error from statusText\n              // then normalize statusText and status for non-aborts\n              error = statusText;\n\n              if (!statusText || status) {\n                statusText = \"error\";\n\n                if (status < 0) {\n                  status = 0;\n                }\n              }\n            } // Set data for the fake xhr object\n\n\n            jqXHR.status = status;\n            jqXHR.statusText = \"\" + (nativeStatusText || statusText); // Success/Error\n\n            if (isSuccess) {\n              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n            } else {\n              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n            } // Status-dependent callbacks\n\n\n            jqXHR.statusCode(statusCode);\n            statusCode = undefined;\n\n            if (fireGlobals) {\n              globalEventContext.trigger(\"ajax\" + (isSuccess ? \"Success\" : \"Error\"), [jqXHR, s, isSuccess ? success : error]);\n            } // Complete\n\n\n            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n            if (fireGlobals) {\n              globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n              if (! --jQuery.active) {\n                jQuery.event.trigger(\"ajaxStop\");\n              }\n            }\n          } // Attach deferreds\n\n\n          deferred.promise(jqXHR);\n          jqXHR.success = jqXHR.done;\n          jqXHR.error = jqXHR.fail;\n          jqXHR.complete = completeDeferred.add; // Status-dependent callbacks\n\n          jqXHR.statusCode = function (map) {\n            if (map) {\n              var tmp;\n\n              if (state < 2) {\n                for (tmp in map) {\n                  statusCode[tmp] = [statusCode[tmp], map[tmp]];\n                }\n              } else {\n                tmp = map[jqXHR.status];\n                jqXHR.then(tmp, tmp);\n              }\n            }\n\n            return this;\n          }; // Remove hash character (#7531: and string promotion)\n          // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n          // We also use the url parameter if available\n\n\n          s.url = ((url || s.url) + \"\").replace(rhash, \"\").replace(rprotocol, ajaxLocParts[1] + \"//\"); // Extract dataTypes list\n\n          s.dataTypes = jQuery.trim(s.dataType || \"*\").toLowerCase().split(rspacesAjax); // Determine if a cross-domain request is in order\n\n          if (s.crossDomain == null) {\n            parts = rurl.exec(s.url.toLowerCase());\n            s.crossDomain = !!(parts && (parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] || (parts[3] || (parts[1] === \"http:\" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? 80 : 443))));\n          } // Convert data if not already a string\n\n\n          if (s.data && s.processData && typeof s.data !== \"string\") {\n            s.data = jQuery.param(s.data, s.traditional);\n          } // Apply prefilters\n\n\n          inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n          if (state === 2) {\n            return false;\n          } // We can fire global events as of now if asked to\n\n\n          fireGlobals = s.global; // Uppercase the type\n\n          s.type = s.type.toUpperCase(); // Determine if request has content\n\n          s.hasContent = !rnoContent.test(s.type); // Watch for a new set of requests\n\n          if (fireGlobals && jQuery.active++ === 0) {\n            jQuery.event.trigger(\"ajaxStart\");\n          } // More options handling for requests with no content\n\n\n          if (!s.hasContent) {\n            // If data is available, append data to url\n            if (s.data) {\n              s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n              delete s.data;\n            } // Get ifModifiedKey before adding the anti-cache parameter\n\n\n            ifModifiedKey = s.url; // Add anti-cache in url if needed\n\n            if (s.cache === false) {\n              var ts = jQuery.now(),\n                  // try replacing _= if it is there\n              ret = s.url.replace(rts, \"$1_=\" + ts); // if nothing was replaced, add timestamp to the end\n\n              s.url = ret + (ret === s.url ? (rquery.test(s.url) ? \"&\" : \"?\") + \"_=\" + ts : \"\");\n            }\n          } // Set the correct header, if data is being sent\n\n\n          if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n            jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n          } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n          if (s.ifModified) {\n            ifModifiedKey = ifModifiedKey || s.url;\n\n            if (jQuery.lastModified[ifModifiedKey]) {\n              jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[ifModifiedKey]);\n            }\n\n            if (jQuery.etag[ifModifiedKey]) {\n              jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[ifModifiedKey]);\n            }\n          } // Set the Accepts header for the server, depending on the dataType\n\n\n          jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n          for (i in s.headers) {\n            jqXHR.setRequestHeader(i, s.headers[i]);\n          } // Allow custom headers/mimetypes and early abort\n\n\n          if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {\n            // Abort if not done already\n            jqXHR.abort();\n            return false;\n          } // Install callbacks on deferreds\n\n\n          for (i in {\n            success: 1,\n            error: 1,\n            complete: 1\n          }) {\n            jqXHR[i](s[i]);\n          } // Get transport\n\n\n          transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n          if (!transport) {\n            done(-1, \"No Transport\");\n          } else {\n            jqXHR.readyState = 1; // Send global event\n\n            if (fireGlobals) {\n              globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n            } // Timeout\n\n\n            if (s.async && s.timeout > 0) {\n              timeoutTimer = setTimeout(function () {\n                jqXHR.abort(\"timeout\");\n              }, s.timeout);\n            }\n\n            try {\n              state = 1;\n              transport.send(requestHeaders, done);\n            } catch (e) {\n              // Propagate exception as error if not done\n              if (state < 2) {\n                done(-1, e); // Simply rethrow otherwise\n              } else {\n                throw e;\n              }\n            }\n          }\n\n          return jqXHR;\n        },\n        // Serialize an array of form elements or a set of\n        // key/values into a query string\n        param: function param(a, traditional) {\n          var s = [],\n              add = function add(key, value) {\n            // If value is a function, invoke it and return its value\n            value = jQuery.isFunction(value) ? value() : value;\n            s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\n          }; // Set traditional to true for jQuery <= 1.3.2 behavior.\n\n\n          if (traditional === undefined) {\n            traditional = jQuery.ajaxSettings.traditional;\n          } // If an array was passed in, assume that it is an array of form elements.\n\n\n          if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n            // Serialize the form elements\n            jQuery.each(a, function () {\n              add(this.name, this.value);\n            });\n          } else {\n            // If traditional, encode the \"old\" way (the way 1.3.2 or older\n            // did it), otherwise encode params recursively.\n            for (var prefix in a) {\n              buildParams(prefix, a[prefix], traditional, add);\n            }\n          } // Return the resulting serialization\n\n\n          return s.join(\"&\").replace(r20, \"+\");\n        }\n      });\n\n      function buildParams(prefix, obj, traditional, add) {\n        if (jQuery.isArray(obj)) {\n          // Serialize array item.\n          jQuery.each(obj, function (i, v) {\n            if (traditional || rbracket.test(prefix)) {\n              // Treat each array item as a scalar.\n              add(prefix, v);\n            } else {\n              // If array item is non-scalar (array or object), encode its\n              // numeric index to resolve deserialization ambiguity issues.\n              // Note that rack (as of 1.0.0) can't currently deserialize\n              // nested arrays properly, and attempting to do so may cause\n              // a server error. Possible fixes are to modify rack's\n              // deserialization algorithm or to provide an option or flag\n              // to force array serialization to be shallow.\n              buildParams(prefix + \"[\" + (typeof v === \"object\" ? i : \"\") + \"]\", v, traditional, add);\n            }\n          });\n        } else if (!traditional && jQuery.type(obj) === \"object\") {\n          // Serialize object item.\n          for (var name in obj) {\n            buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n          }\n        } else {\n          // Serialize scalar item.\n          add(prefix, obj);\n        }\n      } // This is still on the jQuery object... for now\n      // Want to move this to jQuery.ajax some day\n\n\n      jQuery.extend({\n        // Counter for holding the number of active queries\n        active: 0,\n        // Last-Modified header cache for next request\n        lastModified: {},\n        etag: {}\n      });\n      /* Handles responses to an ajax request:\n       * - sets all responseXXX fields accordingly\n       * - finds the right dataType (mediates between content-type and expected dataType)\n       * - returns the corresponding response\n       */\n\n      function ajaxHandleResponses(s, jqXHR, responses) {\n        var contents = s.contents,\n            dataTypes = s.dataTypes,\n            responseFields = s.responseFields,\n            ct,\n            type,\n            finalDataType,\n            firstDataType; // Fill responseXXX fields\n\n        for (type in responseFields) {\n          if (type in responses) {\n            jqXHR[responseFields[type]] = responses[type];\n          }\n        } // Remove auto dataType and get content-type in the process\n\n\n        while (dataTypes[0] === \"*\") {\n          dataTypes.shift();\n\n          if (ct === undefined) {\n            ct = s.mimeType || jqXHR.getResponseHeader(\"content-type\");\n          }\n        } // Check if we're dealing with a known content-type\n\n\n        if (ct) {\n          for (type in contents) {\n            if (contents[type] && contents[type].test(ct)) {\n              dataTypes.unshift(type);\n              break;\n            }\n          }\n        } // Check to see if we have a response for the expected dataType\n\n\n        if (dataTypes[0] in responses) {\n          finalDataType = dataTypes[0];\n        } else {\n          // Try convertible dataTypes\n          for (type in responses) {\n            if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n              finalDataType = type;\n              break;\n            }\n\n            if (!firstDataType) {\n              firstDataType = type;\n            }\n          } // Or just use first one\n\n\n          finalDataType = finalDataType || firstDataType;\n        } // If we found a dataType\n        // We add the dataType to the list if needed\n        // and return the corresponding response\n\n\n        if (finalDataType) {\n          if (finalDataType !== dataTypes[0]) {\n            dataTypes.unshift(finalDataType);\n          }\n\n          return responses[finalDataType];\n        }\n      } // Chain conversions given the request and the original response\n\n\n      function ajaxConvert(s, response) {\n        // Apply the dataFilter if provided\n        if (s.dataFilter) {\n          response = s.dataFilter(response, s.dataType);\n        }\n\n        var dataTypes = s.dataTypes,\n            converters = {},\n            i,\n            key,\n            length = dataTypes.length,\n            tmp,\n            // Current and previous dataTypes\n        current = dataTypes[0],\n            prev,\n            // Conversion expression\n        conversion,\n            // Conversion function\n        conv,\n            // Conversion functions (transitive conversion)\n        conv1,\n            conv2; // For each dataType in the chain\n\n        for (i = 1; i < length; i++) {\n          // Create converters map\n          // with lowercased keys\n          if (i === 1) {\n            for (key in s.converters) {\n              if (typeof key === \"string\") {\n                converters[key.toLowerCase()] = s.converters[key];\n              }\n            }\n          } // Get the dataTypes\n\n\n          prev = current;\n          current = dataTypes[i]; // If current is auto dataType, update it to prev\n\n          if (current === \"*\") {\n            current = prev; // If no auto and dataTypes are actually different\n          } else if (prev !== \"*\" && prev !== current) {\n            // Get the converter\n            conversion = prev + \" \" + current;\n            conv = converters[conversion] || converters[\"* \" + current]; // If there is no direct converter, search transitively\n\n            if (!conv) {\n              conv2 = undefined;\n\n              for (conv1 in converters) {\n                tmp = conv1.split(\" \");\n\n                if (tmp[0] === prev || tmp[0] === \"*\") {\n                  conv2 = converters[tmp[1] + \" \" + current];\n\n                  if (conv2) {\n                    conv1 = converters[conv1];\n\n                    if (conv1 === true) {\n                      conv = conv2;\n                    } else if (conv2 === true) {\n                      conv = conv1;\n                    }\n\n                    break;\n                  }\n                }\n              }\n            } // If we found no converter, dispatch an error\n\n\n            if (!(conv || conv2)) {\n              jQuery.error(\"No conversion from \" + conversion.replace(\" \", \" to \"));\n            } // If found converter is not an equivalence\n\n\n            if (conv !== true) {\n              // Convert with 1 or 2 converters accordingly\n              response = conv ? conv(response) : conv2(conv1(response));\n            }\n          }\n        }\n\n        return response;\n      }\n\n      var jsc = jQuery.now(),\n          jsre = /(\\=)\\?(&|$)|\\?\\?/i; // Default jsonp settings\n\n      jQuery.ajaxSetup({\n        jsonp: \"callback\",\n        jsonpCallback: function jsonpCallback() {\n          return jQuery.expando + \"_\" + jsc++;\n        }\n      }); // Detect, normalize options and install callbacks for jsonp requests\n\n      jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n        var inspectData = typeof s.data === \"string\" && /^application\\/x\\-www\\-form\\-urlencoded/.test(s.contentType);\n\n        if (s.dataTypes[0] === \"jsonp\" || s.jsonp !== false && (jsre.test(s.url) || inspectData && jsre.test(s.data))) {\n          var responseContainer,\n              jsonpCallback = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback,\n              previous = window[jsonpCallback],\n              url = s.url,\n              data = s.data,\n              replace = \"$1\" + jsonpCallback + \"$2\";\n\n          if (s.jsonp !== false) {\n            url = url.replace(jsre, replace);\n\n            if (s.url === url) {\n              if (inspectData) {\n                data = data.replace(jsre, replace);\n              }\n\n              if (s.data === data) {\n                // Add callback manually\n                url += (/\\?/.test(url) ? \"&\" : \"?\") + s.jsonp + \"=\" + jsonpCallback;\n              }\n            }\n          }\n\n          s.url = url;\n          s.data = data; // Install callback\n\n          window[jsonpCallback] = function (response) {\n            responseContainer = [response];\n          }; // Clean-up function\n\n\n          jqXHR.always(function () {\n            // Set callback back to previous value\n            window[jsonpCallback] = previous; // Call if it was a function and we have a response\n\n            if (responseContainer && jQuery.isFunction(previous)) {\n              window[jsonpCallback](responseContainer[0]);\n            }\n          }); // Use data converter to retrieve json after script execution\n\n          s.converters[\"script json\"] = function () {\n            if (!responseContainer) {\n              jQuery.error(jsonpCallback + \" was not called\");\n            }\n\n            return responseContainer[0];\n          }; // force json dataType\n\n\n          s.dataTypes[0] = \"json\"; // Delegate to script\n\n          return \"script\";\n        }\n      }); // Install script dataType\n\n      jQuery.ajaxSetup({\n        accepts: {\n          script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n        },\n        contents: {\n          script: /javascript|ecmascript/\n        },\n        converters: {\n          \"text script\": function textScript(text) {\n            jQuery.globalEval(text);\n            return text;\n          }\n        }\n      }); // Handle cache's special case and global\n\n      jQuery.ajaxPrefilter(\"script\", function (s) {\n        if (s.cache === undefined) {\n          s.cache = false;\n        }\n\n        if (s.crossDomain) {\n          s.type = \"GET\";\n          s.global = false;\n        }\n      }); // Bind script tag hack transport\n\n      jQuery.ajaxTransport(\"script\", function (s) {\n        // This transport only deals with cross domain requests\n        if (s.crossDomain) {\n          var script,\n              head = document.head || document.getElementsByTagName(\"head\")[0] || document.documentElement;\n          return {\n            send: function send(_, callback) {\n              script = document.createElement(\"script\");\n              script.async = \"async\";\n\n              if (s.scriptCharset) {\n                script.charset = s.scriptCharset;\n              }\n\n              script.src = s.url; // Attach handlers for all browsers\n\n              script.onload = script.onreadystatechange = function (_, isAbort) {\n                if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {\n                  // Handle memory leak in IE\n                  script.onload = script.onreadystatechange = null; // Remove the script\n\n                  if (head && script.parentNode) {\n                    head.removeChild(script);\n                  } // Dereference the script\n\n\n                  script = undefined; // Callback if not abort\n\n                  if (!isAbort) {\n                    callback(200, \"success\");\n                  }\n                }\n              }; // Use insertBefore instead of appendChild  to circumvent an IE6 bug.\n              // This arises when a base node is used (#2709 and #4378).\n\n\n              head.insertBefore(script, head.firstChild);\n            },\n            abort: function abort() {\n              if (script) {\n                script.onload(0, 1);\n              }\n            }\n          };\n        }\n      });\n      var // #5280: Internet Explorer will keep connections alive if we don't abort on unload\n      xhrOnUnloadAbort = window.ActiveXObject ? function () {\n        // Abort all pending requests\n        for (var key in xhrCallbacks) {\n          xhrCallbacks[key](0, 1);\n        }\n      } : false,\n          xhrId = 0,\n          xhrCallbacks; // Functions to create xhrs\n\n      function createStandardXHR() {\n        try {\n          return new window.XMLHttpRequest();\n        } catch (e) {}\n      }\n\n      function createActiveXHR() {\n        try {\n          return new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n        } catch (e) {}\n      } // Create the request object\n      // (This is still attached to ajaxSettings for backward compatibility)\n\n\n      jQuery.ajaxSettings.xhr = window.ActiveXObject ?\n      /* Microsoft failed to properly\n       * implement the XMLHttpRequest in IE7 (can't request local files),\n       * so we use the ActiveXObject when it is available\n       * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n       * we need a fallback.\n       */\n      function () {\n        return !this.isLocal && createStandardXHR() || createActiveXHR();\n      } : // For all other browsers, use the standard XMLHttpRequest object\n      createStandardXHR; // Determine support properties\n\n      (function (xhr) {\n        jQuery.extend(jQuery.support, {\n          ajax: !!xhr,\n          cors: !!xhr && \"withCredentials\" in xhr\n        });\n      })(jQuery.ajaxSettings.xhr()); // Create transport if the browser can provide an xhr\n\n\n      if (jQuery.support.ajax) {\n        jQuery.ajaxTransport(function (s) {\n          // Cross domain only allowed if supported through XMLHttpRequest\n          if (!s.crossDomain || jQuery.support.cors) {\n            var _callback;\n\n            return {\n              send: function send(headers, complete) {\n                // Get a new xhr\n                var xhr = s.xhr(),\n                    handle,\n                    i; // Open the socket\n                // Passing null username, generates a login popup on Opera (#2865)\n\n                if (s.username) {\n                  xhr.open(s.type, s.url, s.async, s.username, s.password);\n                } else {\n                  xhr.open(s.type, s.url, s.async);\n                } // Apply custom fields if provided\n\n\n                if (s.xhrFields) {\n                  for (i in s.xhrFields) {\n                    xhr[i] = s.xhrFields[i];\n                  }\n                } // Override mime type if needed\n\n\n                if (s.mimeType && xhr.overrideMimeType) {\n                  xhr.overrideMimeType(s.mimeType);\n                } // X-Requested-With header\n                // For cross-domain requests, seeing as conditions for a preflight are\n                // akin to a jigsaw puzzle, we simply never set it to be sure.\n                // (it can always be set on a per-request basis or even using ajaxSetup)\n                // For same-domain requests, won't change header if already provided.\n\n\n                if (!s.crossDomain && !headers[\"X-Requested-With\"]) {\n                  headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n                } // Need an extra try/catch for cross domain requests in Firefox 3\n\n\n                try {\n                  for (i in headers) {\n                    xhr.setRequestHeader(i, headers[i]);\n                  }\n                } catch (_) {} // Do send the request\n                // This may raise an exception which is actually\n                // handled in jQuery.ajax (so no try/catch here)\n\n\n                xhr.send(s.hasContent && s.data || null); // Listener\n\n                _callback = function callback(_, isAbort) {\n                  var status, statusText, responseHeaders, responses, xml; // Firefox throws exceptions when accessing properties\n                  // of an xhr when a network error occured\n                  // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)\n\n                  try {\n                    // Was never called and is aborted or complete\n                    if (_callback && (isAbort || xhr.readyState === 4)) {\n                      // Only called once\n                      _callback = undefined; // Do not keep as active anymore\n\n                      if (handle) {\n                        xhr.onreadystatechange = jQuery.noop;\n\n                        if (xhrOnUnloadAbort) {\n                          delete xhrCallbacks[handle];\n                        }\n                      } // If it's an abort\n\n\n                      if (isAbort) {\n                        // Abort it manually if needed\n                        if (xhr.readyState !== 4) {\n                          xhr.abort();\n                        }\n                      } else {\n                        status = xhr.status;\n                        responseHeaders = xhr.getAllResponseHeaders();\n                        responses = {};\n                        xml = xhr.responseXML; // Construct response list\n\n                        if (xml && xml.documentElement\n                        /* #4958 */\n                        ) {\n                            responses.xml = xml;\n                          } // When requesting binary data, IE6-9 will throw an exception\n                        // on any attempt to access responseText (#11426)\n\n\n                        try {\n                          responses.text = xhr.responseText;\n                        } catch (_) {} // Firefox throws an exception when accessing\n                        // statusText for faulty cross-domain requests\n\n\n                        try {\n                          statusText = xhr.statusText;\n                        } catch (e) {\n                          // We normalize with Webkit giving an empty statusText\n                          statusText = \"\";\n                        } // Filter status for non standard behaviors\n                        // If the request is local and we have data: assume a success\n                        // (success with no data won't get notified, that's the best we\n                        // can do given current implementations)\n\n\n                        if (!status && s.isLocal && !s.crossDomain) {\n                          status = responses.text ? 200 : 404; // IE - #1450: sometimes returns 1223 when it should be 204\n                        } else if (status === 1223) {\n                          status = 204;\n                        }\n                      }\n                    }\n                  } catch (firefoxAccessException) {\n                    if (!isAbort) {\n                      complete(-1, firefoxAccessException);\n                    }\n                  } // Call complete if needed\n\n\n                  if (responses) {\n                    complete(status, statusText, responses, responseHeaders);\n                  }\n                }; // if we're in sync mode or it's in cache\n                // and has been retrieved directly (IE6 & IE7)\n                // we need to manually fire the callback\n\n\n                if (!s.async || xhr.readyState === 4) {\n                  _callback();\n                } else {\n                  handle = ++xhrId;\n\n                  if (xhrOnUnloadAbort) {\n                    // Create the active xhrs callbacks list if needed\n                    // and attach the unload handler\n                    if (!xhrCallbacks) {\n                      xhrCallbacks = {};\n                      jQuery(window).unload(xhrOnUnloadAbort);\n                    } // Add to list of active xhrs callbacks\n\n\n                    xhrCallbacks[handle] = _callback;\n                  }\n\n                  xhr.onreadystatechange = _callback;\n                }\n              },\n              abort: function abort() {\n                if (_callback) {\n                  _callback(0, 1);\n                }\n              }\n            };\n          }\n        });\n      }\n\n      var elemdisplay = {},\n          iframe,\n          iframeDoc,\n          rfxtypes = /^(?:toggle|show|hide)$/,\n          rfxnum = /^([+\\-]=)?([\\d+.\\-]+)([a-z%]*)$/i,\n          timerId,\n          fxAttrs = [// height animations\n      [\"height\", \"marginTop\", \"marginBottom\", \"paddingTop\", \"paddingBottom\"], // width animations\n      [\"width\", \"marginLeft\", \"marginRight\", \"paddingLeft\", \"paddingRight\"], // opacity animations\n      [\"opacity\"]],\n          fxNow;\n      jQuery.fn.extend({\n        show: function show(speed, easing, callback) {\n          var elem, display;\n\n          if (speed || speed === 0) {\n            return this.animate(genFx(\"show\", 3), speed, easing, callback);\n          } else {\n            for (var i = 0, j = this.length; i < j; i++) {\n              elem = this[i];\n\n              if (elem.style) {\n                display = elem.style.display; // Reset the inline display of this element to learn if it is\n                // being hidden by cascaded rules or not\n\n                if (!jQuery._data(elem, \"olddisplay\") && display === \"none\") {\n                  display = elem.style.display = \"\";\n                } // Set elements which have been overridden with display: none\n                // in a stylesheet to whatever the default browser style is\n                // for such an element\n\n\n                if (display === \"\" && jQuery.css(elem, \"display\") === \"none\" || !jQuery.contains(elem.ownerDocument.documentElement, elem)) {\n                  jQuery._data(elem, \"olddisplay\", defaultDisplay(elem.nodeName));\n                }\n              }\n            } // Set the display of most of the elements in a second loop\n            // to avoid the constant reflow\n\n\n            for (i = 0; i < j; i++) {\n              elem = this[i];\n\n              if (elem.style) {\n                display = elem.style.display;\n\n                if (display === \"\" || display === \"none\") {\n                  elem.style.display = jQuery._data(elem, \"olddisplay\") || \"\";\n                }\n              }\n            }\n\n            return this;\n          }\n        },\n        hide: function hide(speed, easing, callback) {\n          if (speed || speed === 0) {\n            return this.animate(genFx(\"hide\", 3), speed, easing, callback);\n          } else {\n            var elem,\n                display,\n                i = 0,\n                j = this.length;\n\n            for (; i < j; i++) {\n              elem = this[i];\n\n              if (elem.style) {\n                display = jQuery.css(elem, \"display\");\n\n                if (display !== \"none\" && !jQuery._data(elem, \"olddisplay\")) {\n                  jQuery._data(elem, \"olddisplay\", display);\n                }\n              }\n            } // Set the display of the elements in a second loop\n            // to avoid the constant reflow\n\n\n            for (i = 0; i < j; i++) {\n              if (this[i].style) {\n                this[i].style.display = \"none\";\n              }\n            }\n\n            return this;\n          }\n        },\n        // Save the old toggle function\n        _toggle: jQuery.fn.toggle,\n        toggle: function toggle(fn, fn2, callback) {\n          var bool = typeof fn === \"boolean\";\n\n          if (jQuery.isFunction(fn) && jQuery.isFunction(fn2)) {\n            this._toggle.apply(this, arguments);\n          } else if (fn == null || bool) {\n            this.each(function () {\n              var state = bool ? fn : jQuery(this).is(\":hidden\");\n              jQuery(this)[state ? \"show\" : \"hide\"]();\n            });\n          } else {\n            this.animate(genFx(\"toggle\", 3), fn, fn2, callback);\n          }\n\n          return this;\n        },\n        fadeTo: function fadeTo(speed, to, easing, callback) {\n          return this.filter(\":hidden\").css(\"opacity\", 0).show().end().animate({\n            opacity: to\n          }, speed, easing, callback);\n        },\n        animate: function animate(prop, speed, easing, callback) {\n          var optall = jQuery.speed(speed, easing, callback);\n\n          if (jQuery.isEmptyObject(prop)) {\n            return this.each(optall.complete, [false]);\n          } // Do not change referenced properties as per-property easing will be lost\n\n\n          prop = jQuery.extend({}, prop);\n\n          function doAnimation() {\n            // XXX 'this' does not always have a nodeName when running the\n            // test suite\n            if (optall.queue === false) {\n              jQuery._mark(this);\n            }\n\n            var opt = jQuery.extend({}, optall),\n                isElement = this.nodeType === 1,\n                hidden = isElement && jQuery(this).is(\":hidden\"),\n                name,\n                val,\n                p,\n                e,\n                hooks,\n                replace,\n                parts,\n                start,\n                end,\n                unit,\n                method; // will store per property easing and be used to determine when an animation is complete\n\n            opt.animatedProperties = {}; // first pass over propertys to expand / normalize\n\n            for (p in prop) {\n              name = jQuery.camelCase(p);\n\n              if (p !== name) {\n                prop[name] = prop[p];\n                delete prop[p];\n              }\n\n              if ((hooks = jQuery.cssHooks[name]) && \"expand\" in hooks) {\n                replace = hooks.expand(prop[name]);\n                delete prop[name]; // not quite $.extend, this wont overwrite keys already present.\n                // also - reusing 'p' from above because we have the correct \"name\"\n\n                for (p in replace) {\n                  if (!(p in prop)) {\n                    prop[p] = replace[p];\n                  }\n                }\n              }\n            }\n\n            for (name in prop) {\n              val = prop[name]; // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)\n\n              if (jQuery.isArray(val)) {\n                opt.animatedProperties[name] = val[1];\n                val = prop[name] = val[0];\n              } else {\n                opt.animatedProperties[name] = opt.specialEasing && opt.specialEasing[name] || opt.easing || 'swing';\n              }\n\n              if (val === \"hide\" && hidden || val === \"show\" && !hidden) {\n                return opt.complete.call(this);\n              }\n\n              if (isElement && (name === \"height\" || name === \"width\")) {\n                // Make sure that nothing sneaks out\n                // Record all 3 overflow attributes because IE does not\n                // change the overflow attribute when overflowX and\n                // overflowY are set to the same value\n                opt.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY]; // Set display property to inline-block for height/width\n                // animations on inline elements that are having width/height animated\n\n                if (jQuery.css(this, \"display\") === \"inline\" && jQuery.css(this, \"float\") === \"none\") {\n                  // inline-level elements accept inline-block;\n                  // block-level elements need to be inline with layout\n                  if (!jQuery.support.inlineBlockNeedsLayout || defaultDisplay(this.nodeName) === \"inline\") {\n                    this.style.display = \"inline-block\";\n                  } else {\n                    this.style.zoom = 1;\n                  }\n                }\n              }\n            }\n\n            if (opt.overflow != null) {\n              this.style.overflow = \"hidden\";\n            }\n\n            for (p in prop) {\n              e = new jQuery.fx(this, opt, p);\n              val = prop[p];\n\n              if (rfxtypes.test(val)) {\n                // Tracks whether to show or hide based on private\n                // data attached to the element\n                method = jQuery._data(this, \"toggle\" + p) || (val === \"toggle\" ? hidden ? \"show\" : \"hide\" : 0);\n\n                if (method) {\n                  jQuery._data(this, \"toggle\" + p, method === \"show\" ? \"hide\" : \"show\");\n\n                  e[method]();\n                } else {\n                  e[val]();\n                }\n              } else {\n                parts = rfxnum.exec(val);\n                start = e.cur();\n\n                if (parts) {\n                  end = parseFloat(parts[2]);\n                  unit = parts[3] || (jQuery.cssNumber[p] ? \"\" : \"px\"); // We need to compute starting value\n\n                  if (unit !== \"px\") {\n                    jQuery.style(this, p, (end || 1) + unit);\n                    start = (end || 1) / e.cur() * start;\n                    jQuery.style(this, p, start + unit);\n                  } // If a +=/-= token was provided, we're doing a relative animation\n\n\n                  if (parts[1]) {\n                    end = (parts[1] === \"-=\" ? -1 : 1) * end + start;\n                  }\n\n                  e.custom(start, end, unit);\n                } else {\n                  e.custom(start, val, \"\");\n                }\n              }\n            } // For JS strict compliance\n\n\n            return true;\n          }\n\n          return optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n        },\n        stop: function stop(type, clearQueue, gotoEnd) {\n          if (typeof type !== \"string\") {\n            gotoEnd = clearQueue;\n            clearQueue = type;\n            type = undefined;\n          }\n\n          if (clearQueue && type !== false) {\n            this.queue(type || \"fx\", []);\n          }\n\n          return this.each(function () {\n            var index,\n                hadTimers = false,\n                timers = jQuery.timers,\n                data = jQuery._data(this); // clear marker counters if we know they won't be\n\n\n            if (!gotoEnd) {\n              jQuery._unmark(true, this);\n            }\n\n            function stopQueue(elem, data, index) {\n              var hooks = data[index];\n              jQuery.removeData(elem, index, true);\n              hooks.stop(gotoEnd);\n            }\n\n            if (type == null) {\n              for (index in data) {\n                if (data[index] && data[index].stop && index.indexOf(\".run\") === index.length - 4) {\n                  stopQueue(this, data, index);\n                }\n              }\n            } else if (data[index = type + \".run\"] && data[index].stop) {\n              stopQueue(this, data, index);\n            }\n\n            for (index = timers.length; index--;) {\n              if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n                if (gotoEnd) {\n                  // force the next step to be the last\n                  timers[index](true);\n                } else {\n                  timers[index].saveState();\n                }\n\n                hadTimers = true;\n                timers.splice(index, 1);\n              }\n            } // start the next in the queue if the last step wasn't forced\n            // timers currently will call their complete callbacks, which will dequeue\n            // but only if they were gotoEnd\n\n\n            if (!(gotoEnd && hadTimers)) {\n              jQuery.dequeue(this, type);\n            }\n          });\n        }\n      }); // Animations created synchronously will run synchronously\n\n      function createFxNow() {\n        setTimeout(clearFxNow, 0);\n        return fxNow = jQuery.now();\n      }\n\n      function clearFxNow() {\n        fxNow = undefined;\n      } // Generate parameters to create a standard animation\n\n\n      function genFx(type, num) {\n        var obj = {};\n        jQuery.each(fxAttrs.concat.apply([], fxAttrs.slice(0, num)), function () {\n          obj[this] = type;\n        });\n        return obj;\n      } // Generate shortcuts for custom animations\n\n\n      jQuery.each({\n        slideDown: genFx(\"show\", 1),\n        slideUp: genFx(\"hide\", 1),\n        slideToggle: genFx(\"toggle\", 1),\n        fadeIn: {\n          opacity: \"show\"\n        },\n        fadeOut: {\n          opacity: \"hide\"\n        },\n        fadeToggle: {\n          opacity: \"toggle\"\n        }\n      }, function (name, props) {\n        jQuery.fn[name] = function (speed, easing, callback) {\n          return this.animate(props, speed, easing, callback);\n        };\n      });\n      jQuery.extend({\n        speed: function speed(_speed, easing, fn) {\n          var opt = _speed && typeof _speed === \"object\" ? jQuery.extend({}, _speed) : {\n            complete: fn || !fn && easing || jQuery.isFunction(_speed) && _speed,\n            duration: _speed,\n            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n          };\n          opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default; // normalize opt.queue - true/undefined/null -> \"fx\"\n\n          if (opt.queue == null || opt.queue === true) {\n            opt.queue = \"fx\";\n          } // Queueing\n\n\n          opt.old = opt.complete;\n\n          opt.complete = function (noUnmark) {\n            if (jQuery.isFunction(opt.old)) {\n              opt.old.call(this);\n            }\n\n            if (opt.queue) {\n              jQuery.dequeue(this, opt.queue);\n            } else if (noUnmark !== false) {\n              jQuery._unmark(this);\n            }\n          };\n\n          return opt;\n        },\n        easing: {\n          linear: function linear(p) {\n            return p;\n          },\n          swing: function swing(p) {\n            return -Math.cos(p * Math.PI) / 2 + 0.5;\n          }\n        },\n        timers: [],\n        fx: function fx(elem, options, prop) {\n          this.options = options;\n          this.elem = elem;\n          this.prop = prop;\n          options.orig = options.orig || {};\n        }\n      });\n      jQuery.fx.prototype = {\n        // Simple function for setting a style value\n        update: function update() {\n          if (this.options.step) {\n            this.options.step.call(this.elem, this.now, this);\n          }\n\n          (jQuery.fx.step[this.prop] || jQuery.fx.step._default)(this);\n        },\n        // Get the current size\n        cur: function cur() {\n          if (this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null)) {\n            return this.elem[this.prop];\n          }\n\n          var parsed,\n              r = jQuery.css(this.elem, this.prop); // Empty strings, null, undefined and \"auto\" are converted to 0,\n          // complex values such as \"rotate(1rad)\" are returned as is,\n          // simple values such as \"10px\" are parsed to Float.\n\n          return isNaN(parsed = parseFloat(r)) ? !r || r === \"auto\" ? 0 : r : parsed;\n        },\n        // Start an animation from one number to another\n        custom: function custom(from, to, unit) {\n          var self = this,\n              fx = jQuery.fx;\n          this.startTime = fxNow || createFxNow();\n          this.end = to;\n          this.now = this.start = from;\n          this.pos = this.state = 0;\n          this.unit = unit || this.unit || (jQuery.cssNumber[this.prop] ? \"\" : \"px\");\n\n          function t(gotoEnd) {\n            return self.step(gotoEnd);\n          }\n\n          t.queue = this.options.queue;\n          t.elem = this.elem;\n\n          t.saveState = function () {\n            if (jQuery._data(self.elem, \"fxshow\" + self.prop) === undefined) {\n              if (self.options.hide) {\n                jQuery._data(self.elem, \"fxshow\" + self.prop, self.start);\n              } else if (self.options.show) {\n                jQuery._data(self.elem, \"fxshow\" + self.prop, self.end);\n              }\n            }\n          };\n\n          if (t() && jQuery.timers.push(t) && !timerId) {\n            timerId = setInterval(fx.tick, fx.interval);\n          }\n        },\n        // Simple 'show' function\n        show: function show() {\n          var dataShow = jQuery._data(this.elem, \"fxshow\" + this.prop); // Remember where we started, so that we can go back to it later\n\n\n          this.options.orig[this.prop] = dataShow || jQuery.style(this.elem, this.prop);\n          this.options.show = true; // Begin the animation\n          // Make sure that we start at a small width/height to avoid any flash of content\n\n          if (dataShow !== undefined) {\n            // This show is picking up where a previous hide or show left off\n            this.custom(this.cur(), dataShow);\n          } else {\n            this.custom(this.prop === \"width\" || this.prop === \"height\" ? 1 : 0, this.cur());\n          } // Start by showing the element\n\n\n          jQuery(this.elem).show();\n        },\n        // Simple 'hide' function\n        hide: function hide() {\n          // Remember where we started, so that we can go back to it later\n          this.options.orig[this.prop] = jQuery._data(this.elem, \"fxshow\" + this.prop) || jQuery.style(this.elem, this.prop);\n          this.options.hide = true; // Begin the animation\n\n          this.custom(this.cur(), 0);\n        },\n        // Each step of an animation\n        step: function step(gotoEnd) {\n          var p,\n              n,\n              complete,\n              t = fxNow || createFxNow(),\n              done = true,\n              elem = this.elem,\n              options = this.options;\n\n          if (gotoEnd || t >= options.duration + this.startTime) {\n            this.now = this.end;\n            this.pos = this.state = 1;\n            this.update();\n            options.animatedProperties[this.prop] = true;\n\n            for (p in options.animatedProperties) {\n              if (options.animatedProperties[p] !== true) {\n                done = false;\n              }\n            }\n\n            if (done) {\n              // Reset the overflow\n              if (options.overflow != null && !jQuery.support.shrinkWrapBlocks) {\n                jQuery.each([\"\", \"X\", \"Y\"], function (index, value) {\n                  elem.style[\"overflow\" + value] = options.overflow[index];\n                });\n              } // Hide the element if the \"hide\" operation was done\n\n\n              if (options.hide) {\n                jQuery(elem).hide();\n              } // Reset the properties, if the item has been hidden or shown\n\n\n              if (options.hide || options.show) {\n                for (p in options.animatedProperties) {\n                  jQuery.style(elem, p, options.orig[p]);\n                  jQuery.removeData(elem, \"fxshow\" + p, true); // Toggle data is no longer needed\n\n                  jQuery.removeData(elem, \"toggle\" + p, true);\n                }\n              } // Execute the complete function\n              // in the event that the complete function throws an exception\n              // we must ensure it won't be called twice. #5684\n\n\n              complete = options.complete;\n\n              if (complete) {\n                options.complete = false;\n                complete.call(elem);\n              }\n            }\n\n            return false;\n          } else {\n            // classical easing cannot be used with an Infinity duration\n            if (options.duration == Infinity) {\n              this.now = t;\n            } else {\n              n = t - this.startTime;\n              this.state = n / options.duration; // Perform the easing function, defaults to swing\n\n              this.pos = jQuery.easing[options.animatedProperties[this.prop]](this.state, n, 0, 1, options.duration);\n              this.now = this.start + (this.end - this.start) * this.pos;\n            } // Perform the next step of the animation\n\n\n            this.update();\n          }\n\n          return true;\n        }\n      };\n      jQuery.extend(jQuery.fx, {\n        tick: function tick() {\n          var timer,\n              timers = jQuery.timers,\n              i = 0;\n\n          for (; i < timers.length; i++) {\n            timer = timers[i]; // Checks the timer has not already been removed\n\n            if (!timer() && timers[i] === timer) {\n              timers.splice(i--, 1);\n            }\n          }\n\n          if (!timers.length) {\n            jQuery.fx.stop();\n          }\n        },\n        interval: 13,\n        stop: function stop() {\n          clearInterval(timerId);\n          timerId = null;\n        },\n        speeds: {\n          slow: 600,\n          fast: 200,\n          // Default speed\n          _default: 400\n        },\n        step: {\n          opacity: function opacity(fx) {\n            jQuery.style(fx.elem, \"opacity\", fx.now);\n          },\n          _default: function _default(fx) {\n            if (fx.elem.style && fx.elem.style[fx.prop] != null) {\n              fx.elem.style[fx.prop] = fx.now + fx.unit;\n            } else {\n              fx.elem[fx.prop] = fx.now;\n            }\n          }\n        }\n      }); // Ensure props that can't be negative don't go there on undershoot easing\n\n      jQuery.each(fxAttrs.concat.apply([], fxAttrs), function (i, prop) {\n        // exclude marginTop, marginLeft, marginBottom and marginRight from this list\n        if (prop.indexOf(\"margin\")) {\n          jQuery.fx.step[prop] = function (fx) {\n            jQuery.style(fx.elem, prop, Math.max(0, fx.now) + fx.unit);\n          };\n        }\n      });\n\n      if (jQuery.expr && jQuery.expr.filters) {\n        jQuery.expr.filters.animated = function (elem) {\n          return jQuery.grep(jQuery.timers, function (fn) {\n            return elem === fn.elem;\n          }).length;\n        };\n      } // Try to restore the default display value of an element\n\n\n      function defaultDisplay(nodeName) {\n        if (!elemdisplay[nodeName]) {\n          var body = document.body,\n              elem = jQuery(\"<\" + nodeName + \">\").appendTo(body),\n              display = elem.css(\"display\");\n          elem.remove(); // If the simple way fails,\n          // get element's real default display by attaching it to a temp iframe\n\n          if (display === \"none\" || display === \"\") {\n            // No iframe to use yet, so create it\n            if (!iframe) {\n              iframe = document.createElement(\"iframe\");\n              iframe.frameBorder = iframe.width = iframe.height = 0;\n            }\n\n            body.appendChild(iframe); // Create a cacheable copy of the iframe document on first call.\n            // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML\n            // document to it; WebKit & Firefox won't allow reusing the iframe document.\n\n            if (!iframeDoc || !iframe.createElement) {\n              iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;\n              iframeDoc.write((jQuery.support.boxModel ? \"<!doctype html>\" : \"\") + \"<html><body>\");\n              iframeDoc.close();\n            }\n\n            elem = iframeDoc.createElement(nodeName);\n            iframeDoc.body.appendChild(elem);\n            display = jQuery.css(elem, \"display\");\n            body.removeChild(iframe);\n          } // Store the correct default display\n\n\n          elemdisplay[nodeName] = display;\n        }\n\n        return elemdisplay[nodeName];\n      }\n\n      var getOffset,\n          rtable = /^t(?:able|d|h)$/i,\n          rroot = /^(?:body|html)$/i;\n\n      if (\"getBoundingClientRect\" in document.documentElement) {\n        getOffset = function getOffset(elem, doc, docElem, box) {\n          try {\n            box = elem.getBoundingClientRect();\n          } catch (e) {} // Make sure we're not dealing with a disconnected DOM node\n\n\n          if (!box || !jQuery.contains(docElem, elem)) {\n            return box ? {\n              top: box.top,\n              left: box.left\n            } : {\n              top: 0,\n              left: 0\n            };\n          }\n\n          var body = doc.body,\n              win = getWindow(doc),\n              clientTop = docElem.clientTop || body.clientTop || 0,\n              clientLeft = docElem.clientLeft || body.clientLeft || 0,\n              scrollTop = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop || body.scrollTop,\n              scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,\n              top = box.top + scrollTop - clientTop,\n              left = box.left + scrollLeft - clientLeft;\n          return {\n            top: top,\n            left: left\n          };\n        };\n      } else {\n        getOffset = function getOffset(elem, doc, docElem) {\n          var computedStyle,\n              offsetParent = elem.offsetParent,\n              prevOffsetParent = elem,\n              body = doc.body,\n              defaultView = doc.defaultView,\n              prevComputedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle,\n              top = elem.offsetTop,\n              left = elem.offsetLeft;\n\n          while ((elem = elem.parentNode) && elem !== body && elem !== docElem) {\n            if (jQuery.support.fixedPosition && prevComputedStyle.position === \"fixed\") {\n              break;\n            }\n\n            computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;\n            top -= elem.scrollTop;\n            left -= elem.scrollLeft;\n\n            if (elem === offsetParent) {\n              top += elem.offsetTop;\n              left += elem.offsetLeft;\n\n              if (jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName))) {\n                top += parseFloat(computedStyle.borderTopWidth) || 0;\n                left += parseFloat(computedStyle.borderLeftWidth) || 0;\n              }\n\n              prevOffsetParent = offsetParent;\n              offsetParent = elem.offsetParent;\n            }\n\n            if (jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== \"visible\") {\n              top += parseFloat(computedStyle.borderTopWidth) || 0;\n              left += parseFloat(computedStyle.borderLeftWidth) || 0;\n            }\n\n            prevComputedStyle = computedStyle;\n          }\n\n          if (prevComputedStyle.position === \"relative\" || prevComputedStyle.position === \"static\") {\n            top += body.offsetTop;\n            left += body.offsetLeft;\n          }\n\n          if (jQuery.support.fixedPosition && prevComputedStyle.position === \"fixed\") {\n            top += Math.max(docElem.scrollTop, body.scrollTop);\n            left += Math.max(docElem.scrollLeft, body.scrollLeft);\n          }\n\n          return {\n            top: top,\n            left: left\n          };\n        };\n      }\n\n      jQuery.fn.offset = function (options) {\n        if (arguments.length) {\n          return options === undefined ? this : this.each(function (i) {\n            jQuery.offset.setOffset(this, options, i);\n          });\n        }\n\n        var elem = this[0],\n            doc = elem && elem.ownerDocument;\n\n        if (!doc) {\n          return null;\n        }\n\n        if (elem === doc.body) {\n          return jQuery.offset.bodyOffset(elem);\n        }\n\n        return getOffset(elem, doc, doc.documentElement);\n      };\n\n      jQuery.offset = {\n        bodyOffset: function bodyOffset(body) {\n          var top = body.offsetTop,\n              left = body.offsetLeft;\n\n          if (jQuery.support.doesNotIncludeMarginInBodyOffset) {\n            top += parseFloat(jQuery.css(body, \"marginTop\")) || 0;\n            left += parseFloat(jQuery.css(body, \"marginLeft\")) || 0;\n          }\n\n          return {\n            top: top,\n            left: left\n          };\n        },\n        setOffset: function setOffset(elem, options, i) {\n          var position = jQuery.css(elem, \"position\"); // set position first, in-case top/left are set even on static elem\n\n          if (position === \"static\") {\n            elem.style.position = \"relative\";\n          }\n\n          var curElem = jQuery(elem),\n              curOffset = curElem.offset(),\n              curCSSTop = jQuery.css(elem, \"top\"),\n              curCSSLeft = jQuery.css(elem, \"left\"),\n              calculatePosition = (position === \"absolute\" || position === \"fixed\") && jQuery.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1,\n              props = {},\n              curPosition = {},\n              curTop,\n              curLeft; // need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\n          if (calculatePosition) {\n            curPosition = curElem.position();\n            curTop = curPosition.top;\n            curLeft = curPosition.left;\n          } else {\n            curTop = parseFloat(curCSSTop) || 0;\n            curLeft = parseFloat(curCSSLeft) || 0;\n          }\n\n          if (jQuery.isFunction(options)) {\n            options = options.call(elem, i, curOffset);\n          }\n\n          if (options.top != null) {\n            props.top = options.top - curOffset.top + curTop;\n          }\n\n          if (options.left != null) {\n            props.left = options.left - curOffset.left + curLeft;\n          }\n\n          if (\"using\" in options) {\n            options.using.call(elem, props);\n          } else {\n            curElem.css(props);\n          }\n        }\n      };\n      jQuery.fn.extend({\n        position: function position() {\n          if (!this[0]) {\n            return null;\n          }\n\n          var elem = this[0],\n              // Get *real* offsetParent\n          offsetParent = this.offsetParent(),\n              // Get correct offsets\n          offset = this.offset(),\n              parentOffset = rroot.test(offsetParent[0].nodeName) ? {\n            top: 0,\n            left: 0\n          } : offsetParent.offset(); // Subtract element margins\n          // note: when an element has margin: auto the offsetLeft and marginLeft\n          // are the same in Safari causing offset.left to incorrectly be 0\n\n          offset.top -= parseFloat(jQuery.css(elem, \"marginTop\")) || 0;\n          offset.left -= parseFloat(jQuery.css(elem, \"marginLeft\")) || 0; // Add offsetParent borders\n\n          parentOffset.top += parseFloat(jQuery.css(offsetParent[0], \"borderTopWidth\")) || 0;\n          parentOffset.left += parseFloat(jQuery.css(offsetParent[0], \"borderLeftWidth\")) || 0; // Subtract the two offsets\n\n          return {\n            top: offset.top - parentOffset.top,\n            left: offset.left - parentOffset.left\n          };\n        },\n        offsetParent: function offsetParent() {\n          return this.map(function () {\n            var offsetParent = this.offsetParent || document.body;\n\n            while (offsetParent && !rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, \"position\") === \"static\") {\n              offsetParent = offsetParent.offsetParent;\n            }\n\n            return offsetParent;\n          });\n        }\n      }); // Create scrollLeft and scrollTop methods\n\n      jQuery.each({\n        scrollLeft: \"pageXOffset\",\n        scrollTop: \"pageYOffset\"\n      }, function (method, prop) {\n        var top = /Y/.test(prop);\n\n        jQuery.fn[method] = function (val) {\n          return jQuery.access(this, function (elem, method, val) {\n            var win = getWindow(elem);\n\n            if (val === undefined) {\n              return win ? prop in win ? win[prop] : jQuery.support.boxModel && win.document.documentElement[method] || win.document.body[method] : elem[method];\n            }\n\n            if (win) {\n              win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());\n            } else {\n              elem[method] = val;\n            }\n          }, method, val, arguments.length, null);\n        };\n      });\n\n      function getWindow(elem) {\n        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;\n      } // Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods\n\n\n      jQuery.each({\n        Height: \"height\",\n        Width: \"width\"\n      }, function (name, type) {\n        var clientProp = \"client\" + name,\n            scrollProp = \"scroll\" + name,\n            offsetProp = \"offset\" + name; // innerHeight and innerWidth\n\n        jQuery.fn[\"inner\" + name] = function () {\n          var elem = this[0];\n          return elem ? elem.style ? parseFloat(jQuery.css(elem, type, \"padding\")) : this[type]() : null;\n        }; // outerHeight and outerWidth\n\n\n        jQuery.fn[\"outer\" + name] = function (margin) {\n          var elem = this[0];\n          return elem ? elem.style ? parseFloat(jQuery.css(elem, type, margin ? \"margin\" : \"border\")) : this[type]() : null;\n        };\n\n        jQuery.fn[type] = function (value) {\n          return jQuery.access(this, function (elem, type, value) {\n            var doc, docElemProp, orig, ret;\n\n            if (jQuery.isWindow(elem)) {\n              // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat\n              doc = elem.document;\n              docElemProp = doc.documentElement[clientProp];\n              return jQuery.support.boxModel && docElemProp || doc.body && doc.body[clientProp] || docElemProp;\n            } // Get document width or height\n\n\n            if (elem.nodeType === 9) {\n              // Either scroll[Width/Height] or offset[Width/Height], whichever is greater\n              doc = elem.documentElement; // when a window > document, IE6 reports a offset[Width/Height] > client[Width/Height]\n              // so we can't use max, as it'll choose the incorrect offset[Width/Height]\n              // instead we use the correct client[Width/Height]\n              // support:IE6\n\n              if (doc[clientProp] >= doc[scrollProp]) {\n                return doc[clientProp];\n              }\n\n              return Math.max(elem.body[scrollProp], doc[scrollProp], elem.body[offsetProp], doc[offsetProp]);\n            } // Get width or height on the element\n\n\n            if (value === undefined) {\n              orig = jQuery.css(elem, type);\n              ret = parseFloat(orig);\n              return jQuery.isNumeric(ret) ? ret : orig;\n            } // Set the width or height on the element\n\n\n            jQuery(elem).css(type, value);\n          }, type, value, arguments.length, null);\n        };\n      }); // Expose jQuery to the global object\n\n      window.jQuery = window.$ = jQuery; // Expose jQuery as an AMD module, but only for AMD loaders that\n      // understand the issues with loading multiple versions of jQuery\n      // in a page that all might call define(). The loader will indicate\n      // they have special allowances for multiple jQuery versions by\n      // specifying define.amd.jQuery = true. Register as a named module,\n      // since jQuery can be concatenated with other files that may use define,\n      // but not use a proper concatenation script that understands anonymous\n      // AMD modules. A named AMD is safest and most robust way to register.\n      // Lowercase jquery is used because AMD module names are derived from\n      // file names, and jQuery is normally delivered in a lowercase file name.\n      // Do this after creating the global so that if an AMD module wants to call\n      // noConflict to hide this version of jQuery, it will work.\n\n      if (typeof define === \"function\" && define.amd && define.amd.jQuery) {\n        define(\"jquery\", [], function () {\n          return jQuery;\n        });\n      }\n    })(window);\n\n    window.jQuery.noConflict();\n    return window.jQuery;\n  }\n\n  module.exports = create('undefined' === typeof window ? undefined : window);\n  module.exports.create = create;\n})();","map":null,"metadata":{},"sourceType":"script"}